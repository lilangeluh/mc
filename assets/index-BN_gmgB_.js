import{a as oC,g as aC}from"./index-BXVGENJY.js";function iC(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const o=Object.getOwnPropertyDescriptor(s,r);o&&Object.defineProperty(n,r,o.get?o:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}const lC=1e-7,uC=1e-4;class zf{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Yc{refCount(e){return rn("refCount")}incRef(e){return rn("incRef")}timerAvailable(){return!0}time(e){return rn("time")}read(e){return rn("read")}readSync(e){return rn("readSync")}readToGPU(e,t){return rn("readToGPU")}numDataIds(){return rn("numDataIds")}disposeData(e,t){return rn("disposeData")}write(e,t,s){return rn("write")}move(e,t,s,r,o){return rn("move")}createTensorFromGPUData(e,t,s){return rn("createTensorFromGPUData")}memory(){return rn("memory")}floatPrecision(){return rn("floatPrecision")}epsilon(){return this.floatPrecision()===32?lC:uC}dispose(){return rn("dispose")}}function rn(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Mf(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Ss(n,e,t)}function cC(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,Ss(n,t,s),Ss(e,t,s)}function nr(n,e,t){return Math.max(n,Math.min(e,t))}function Zc(n){return n%2===0?n:n+1}function Ss(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function Z0(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function hC(n,e){const t=Math.random();return e*t+(1-t)*n}function dC(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function I(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Ot(n,e,t=""){I(Ce(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function ro(n){I(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function G(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function pC(n){return n.length===0}function J0(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Ce(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Br(n){return n%1===0}function fC(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function wc(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function mC(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return Mf(e),e}function Fr(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Vp(n,e=r=>0,t,s){return new Promise((r,o)=>{let a=0;const i=()=>{if(n()){r();return}a++;const l=e(a);if(t!=null&&a>=t){o();return}s!=null?s(i,l):setTimeout(i,l)};i()})}function Bf(n,e){let t=1,s=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function Ie(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),I(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),I(n.every(s=>Br(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Os(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:Ie(e,n).sort();let a=0;for(let i=0;i<n.length;++i){if(o!=null){if(o[a]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(o[a]==null||o[a]>i)&&n[i]===1&&(t.push(n[i]),s.push(i)),o[a]<=i&&a++}n[i]!==1&&(t.push(n[i]),s.push(i))}return{newShape:t,keptDims:s}}function vt(n,e){return tt(n,e)}function tt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Q0(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function ew(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Vf(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function wi(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function tw(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function rs(n){return typeof n=="string"||n instanceof String}function nw(n){return typeof n=="boolean"}function vc(n){return typeof n=="number"}function oo(n){return Array.isArray(n)?oo(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":vc(n)?"float32":rs(n)?"string":nw(n)?"bool":"float32"}function sr(n){return!!(n&&n.constructor&&n.call&&n.apply)}function $c(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function de(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function sw(n,e,t,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let a=0;a<o;a++)r[a]=t[n+a]}else{const o=e[0],a=e.slice(1),i=a.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<o;l++)r[l]=sw(n+l*i,a,t,s)}return r}function Sn(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,o)=>r*o)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return sw(0,n,e,t)}function rw(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function Jc(n,e){const t=Dt(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Dt(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Wf(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Sn(n,new Float32Array(t));if(e==="int32")return Sn(n,new Int32Array(t));if(e==="bool")return Sn(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function mn(n){n.forEach(e=>{I(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Un(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function ao(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Cs(n){return n&&n.then&&typeof n.then=="function"}const qx="tfjsflags";class ow{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=gC,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Cs(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);qx in e&&e[qx].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=xC(r,o)})}}function gC(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(yC(e,s[0],s[1]),s.join("="))),e}function yC(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function xC(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function V(){return Uf}let Uf=null;function bC(n){Uf=n}let $p;function aw(){if($p==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");$p=n}return $p}function wC(){const n=aw();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Gf(n,e){const t=wC();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const Bi="Abs",Vo="Acos",Wo="Acosh",io="Add",Vi="AddN",Qc="All",eh="Any",Wi="ArgMax",Ui="ArgMin",Uo="Asin",Go="Asinh",Ho="Atan",jo="Atanh",qo="Atan2",Gi="AvgPool",th="AvgPoolGrad",Hi="AvgPool3D",nh="AvgPool3DGrad",ji="BatchMatMul",qi="BatchToSpaceND",sh="Bincount",Ki="BitwiseAnd",iw="BroadcastTo",rh="BroadcastArgs",Ko="Cast",Xo="Ceil",Yo="ClipByValue",oh="Complex",Xi="ComplexAbs",Yi="Concat",Zi="Conv2D",ah="Conv2DBackpropFilter",Ji="Conv2DBackpropInput",Qi="Conv3D",ih="Conv3DBackpropFilterV2",lh="Conv3DBackpropInputV2",Zo="Cos",Jo="Cosh",uh="Cumprod",el="Cumsum",ch="CropAndResize",hh="DenseBincount",dh="DepthToSpace",tl="DepthwiseConv2dNative",ph="DepthwiseConv2dNativeBackpropFilter",fh="DepthwiseConv2dNativeBackpropInput",mh="Diag",nl="Dilation2D",Sc="Dilation2DBackpropInput",Ic="Dilation2DBackpropFilter",gh="Draw",Qo="RealDiv",yh="Einsum",ea="Elu",xh="EluGrad",ta="Erf",sl="Equal",na="Exp",rl="ExpandDims",sa="Expm1",bh="FFT",wh="Fill",vh="FlipLeftRight",ra="Floor",oa="FloorDiv",ol="FusedBatchNorm",al="GatherV2",$h="GatherNd",il="Greater",aa="GreaterEqual",ia="Identity",Sh="IFFT",Ih="Imag",la="IsFinite",ua="IsInf",ca="IsNan",ll="LeakyRelu",ul="Less",cl="LessEqual",Nh="LinSpace",ha="Log",da="Log1p",hl="LogicalAnd",dl="LogicalNot",pl="LogicalOr",vC="LogicalXor",lw="LogSoftmax",$C="LowerBound",fl="LRN",Ch="LRNGrad",SC="MatrixBandPart",ml="Max",pa="Maximum",gl="MaxPool",kh="MaxPoolGrad",yl="MaxPool3D",Th="MaxPool3DGrad",Eh="MaxPoolWithArgmax",xl="Mean",bl="Min",fa="Minimum",wl="MirrorPad",ma="Mod",Ah="Multinomial",ga="Multiply",vl="Neg",$l="NotEqual",Rh="NonMaxSuppressionV3",Dh="NonMaxSuppressionV4",Oh="NonMaxSuppressionV5",Sl="OnesLike",Il="OneHot",Nl="Pack",Cl="PadV2",IC="Pool",ya="Pow",kl="Prelu",Tl="Prod",_h="RaggedGather",Fh="RaggedRange",Lh="RaggedTensorToTensor",Ph="Range",zh="Real",xa="Reciprocal",ba="Relu",El="Reshape",Al="ResizeNearestNeighbor",Mh="ResizeNearestNeighborGrad",Rl="ResizeBilinear",Bh="ResizeBilinearGrad",wa="Relu6",Dl="Reverse",va="Round",$a="Rsqrt",Vh="ScatterNd",Wh="TensorScatterUpdate",Uh="SearchSorted",Ol="Select",Sa="Selu",_l="Slice",Ia="Sin",Na="Sinh",Ca="Sign",ka="Sigmoid",Ta="Softplus",Ea="Sqrt",Fl="Sum",Ll="SpaceToBatchND",Pl="SplitV",zl="Softmax",Gh="SparseFillEmptyRows",Hh="SparseReshape",jh="SparseSegmentMean",qh="SparseSegmentSum",Kh="SparseToDense",Aa="SquaredDifference",Xh="Square",Ml="StaticRegexReplace",Yh="StridedSlice",Zh="StringNGrams",Jh="StringSplit",Qh="StringToHashBucketFast",Ra="Sub",Da="Tan",Oa="Tanh",_a="Tile",ed="TopK",td="Transform",Lr="Transpose",nd="Unique",Bl="Unpack",Vl="UnsortedSegmentSum",NC="UpperBound",Wl="ZerosLike",Fa="Step",Nc="FromPixels",sd="RotateWithOffset",vi="_FusedMatMul",$i="FusedConv2D",Si="FusedDepthwiseConv2D";function xn(...n){V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(...n)}function CC(...n){V().getBool("IS_TEST")||V().getBool("PROD")||console.log(...n)}const ko=Gf("kernelRegistry",()=>new Map),Ii=Gf("gradRegistry",()=>new Map);function Ni(n,e){const t=Hf(n,e);return ko.get(t)}function Wp(n){return Ii.get(n)}function Cc(n){const e=ko.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,a]=r,[i]=o.split("_");i===n&&t.push(a)}return t}function rd(n){const{kernelName:e,backendName:t}=n,s=Hf(e,t);ko.has(s)&&xn(`The kernel '${e}' for backend '${t}' is already registered`),ko.set(s,n)}function uw(n){const{kernelName:e}=n;Ii.has(e)&&V().getBool("DEBUG")&&xn(`Overriding the gradient for '${e}'`),Ii.set(e,n)}function kC(n,e){const t=Hf(n,e);if(!ko.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);ko.delete(t)}function TC(n){if(!Ii.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Ii.delete(n)}function EC(n,e){Cc(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});rd(r)})}function Hf(n,e){return`${e}_${n}`}function cw(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Sp,Kx;function AC(){if(Kx)return Sp;Kx=1,Sp=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(E,S,D){this.low=E|0,this.high=S|0,this.unsigned=!!D}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(E){return(E&&E.__isLong__)===!0}e.isLong=t;var s={},r={};function o(E,S){var D,F,z;return S?(E>>>=0,(z=0<=E&&E<256)&&(F=r[E],F)?F:(D=i(E,(E|0)<0?-1:0,!0),z&&(r[E]=D),D)):(E|=0,(z=-128<=E&&E<128)&&(F=s[E],F)?F:(D=i(E,E<0?-1:0,!1),z&&(s[E]=D),D))}e.fromInt=o;function a(E,S){if(isNaN(E))return S?x:y;if(S){if(E<0)return x;if(E>=f)return T}else{if(E<=-m)return A;if(E+1>=m)return N}return E<0?a(-E,S).neg():i(E%p|0,E/p|0,S)}e.fromNumber=a;function i(E,S,D){return new e(E,S,D)}e.fromBits=i;var l=Math.pow;function u(E,S,D){if(E.length===0)throw Error("empty string");if(E==="NaN"||E==="Infinity"||E==="+Infinity"||E==="-Infinity")return y;if(typeof S=="number"?(D=S,S=!1):S=!!S,D=D||10,D<2||36<D)throw RangeError("radix");var F;if((F=E.indexOf("-"))>0)throw Error("interior hyphen");if(F===0)return u(E.substring(1),S,D).neg();for(var z=a(l(D,8)),M=y,W=0;W<E.length;W+=8){var j=Math.min(8,E.length-W),U=parseInt(E.substring(W,W+j),D);if(j<8){var q=a(l(D,j));M=M.mul(q).add(a(U))}else M=M.mul(z),M=M.add(a(U))}return M.unsigned=S,M}e.fromString=u;function c(E,S){return typeof E=="number"?a(E,S):typeof E=="string"?u(E,S):i(E.low,E.high,typeof S=="boolean"?S:E.unsigned)}e.fromValue=c;var h=65536,d=1<<24,p=h*h,f=p*p,m=f/2,g=o(d),y=o(0);e.ZERO=y;var x=o(0,!0);e.UZERO=x;var w=o(1);e.ONE=w;var b=o(1,!0);e.UONE=b;var $=o(-1);e.NEG_ONE=$;var N=i(-1,2147483647,!1);e.MAX_VALUE=N;var T=i(-1,-1,!0);e.MAX_UNSIGNED_VALUE=T;var A=i(0,-2147483648,!1);e.MIN_VALUE=A;var k=e.prototype;return k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},k.toString=function(S){if(S=S||10,S<2||36<S)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(A)){var D=a(S),F=this.div(D),z=F.mul(D).sub(this);return F.toString(S)+z.toInt().toString(S)}else return"-"+this.neg().toString(S);for(var M=a(l(S,6),this.unsigned),W=this,j="";;){var U=W.div(M),q=W.sub(U.mul(M)).toInt()>>>0,K=q.toString(S);if(W=U,W.isZero())return K+j;for(;K.length<6;)K="0"+K;j=""+K+j}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(A)?64:this.neg().getNumBitsAbs();for(var S=this.high!=0?this.high:this.low,D=31;D>0&&(S&1<<D)==0;D--);return this.high!=0?D+33:D+1},k.isZero=function(){return this.high===0&&this.low===0},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return(this.low&1)===1},k.isEven=function(){return(this.low&1)===0},k.equals=function(S){return t(S)||(S=c(S)),this.unsigned!==S.unsigned&&this.high>>>31===1&&S.high>>>31===1?!1:this.high===S.high&&this.low===S.low},k.eq=k.equals,k.notEquals=function(S){return!this.eq(S)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(S){return this.comp(S)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(S){return this.comp(S)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(S){return this.comp(S)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(S){return this.comp(S)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(S){if(t(S)||(S=c(S)),this.eq(S))return 0;var D=this.isNegative(),F=S.isNegative();return D&&!F?-1:!D&&F?1:this.unsigned?S.high>>>0>this.high>>>0||S.high===this.high&&S.low>>>0>this.low>>>0?-1:1:this.sub(S).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(A)?A:this.not().add(w)},k.neg=k.negate,k.add=function(S){t(S)||(S=c(S));var D=this.high>>>16,F=this.high&65535,z=this.low>>>16,M=this.low&65535,W=S.high>>>16,j=S.high&65535,U=S.low>>>16,q=S.low&65535,K=0,X=0,J=0,Q=0;return Q+=M+q,J+=Q>>>16,Q&=65535,J+=z+U,X+=J>>>16,J&=65535,X+=F+j,K+=X>>>16,X&=65535,K+=D+W,K&=65535,i(J<<16|Q,K<<16|X,this.unsigned)},k.subtract=function(S){return t(S)||(S=c(S)),this.add(S.neg())},k.sub=k.subtract,k.multiply=function(S){if(this.isZero())return y;if(t(S)||(S=c(S)),n){var D=n.mul(this.low,this.high,S.low,S.high);return i(D,n.get_high(),this.unsigned)}if(S.isZero())return y;if(this.eq(A))return S.isOdd()?A:y;if(S.eq(A))return this.isOdd()?A:y;if(this.isNegative())return S.isNegative()?this.neg().mul(S.neg()):this.neg().mul(S).neg();if(S.isNegative())return this.mul(S.neg()).neg();if(this.lt(g)&&S.lt(g))return a(this.toNumber()*S.toNumber(),this.unsigned);var F=this.high>>>16,z=this.high&65535,M=this.low>>>16,W=this.low&65535,j=S.high>>>16,U=S.high&65535,q=S.low>>>16,K=S.low&65535,X=0,J=0,Q=0,ne=0;return ne+=W*K,Q+=ne>>>16,ne&=65535,Q+=M*K,J+=Q>>>16,Q&=65535,Q+=W*q,J+=Q>>>16,Q&=65535,J+=z*K,X+=J>>>16,J&=65535,J+=M*q,X+=J>>>16,J&=65535,J+=W*U,X+=J>>>16,J&=65535,X+=F*K+z*q+M*U+W*j,X&=65535,i(Q<<16|ne,X<<16|J,this.unsigned)},k.mul=k.multiply,k.divide=function(S){if(t(S)||(S=c(S)),S.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&S.low===-1&&S.high===-1)return this;var D=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,S.low,S.high);return i(D,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:y;var F,z,M;if(this.unsigned){if(S.unsigned||(S=S.toUnsigned()),S.gt(this))return x;if(S.gt(this.shru(1)))return b;M=x}else{if(this.eq(A)){if(S.eq(w)||S.eq($))return A;if(S.eq(A))return w;var W=this.shr(1);return F=W.div(S).shl(1),F.eq(y)?S.isNegative()?w:$:(z=this.sub(S.mul(F)),M=F.add(z.div(S)),M)}else if(S.eq(A))return this.unsigned?x:y;if(this.isNegative())return S.isNegative()?this.neg().div(S.neg()):this.neg().div(S).neg();if(S.isNegative())return this.div(S.neg()).neg();M=y}for(z=this;z.gte(S);){F=Math.max(1,Math.floor(z.toNumber()/S.toNumber()));for(var j=Math.ceil(Math.log(F)/Math.LN2),U=j<=48?1:l(2,j-48),q=a(F),K=q.mul(S);K.isNegative()||K.gt(z);)F-=U,q=a(F,this.unsigned),K=q.mul(S);q.isZero()&&(q=w),M=M.add(q),z=z.sub(K)}return M},k.div=k.divide,k.modulo=function(S){if(t(S)||(S=c(S)),n){var D=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,S.low,S.high);return i(D,n.get_high(),this.unsigned)}return this.sub(this.div(S).mul(S))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return i(~this.low,~this.high,this.unsigned)},k.and=function(S){return t(S)||(S=c(S)),i(this.low&S.low,this.high&S.high,this.unsigned)},k.or=function(S){return t(S)||(S=c(S)),i(this.low|S.low,this.high|S.high,this.unsigned)},k.xor=function(S){return t(S)||(S=c(S)),i(this.low^S.low,this.high^S.high,this.unsigned)},k.shiftLeft=function(S){return t(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?i(this.low<<S,this.high<<S|this.low>>>32-S,this.unsigned):i(0,this.low<<S-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(S){return t(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?i(this.low>>>S|this.high<<32-S,this.high>>S,this.unsigned):i(this.high>>S-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(S){if(t(S)&&(S=S.toInt()),S&=63,S===0)return this;var D=this.high;if(S<32){var F=this.low;return i(F>>>S|D<<32-S,D>>>S,this.unsigned)}else return S===32?i(D,0,this.unsigned):i(D>>>S-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?i(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:i(this.low,this.high,!0)},k.toBytes=function(S){return S?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var S=this.high,D=this.low;return[D&255,D>>>8&255,D>>>16&255,D>>>24,S&255,S>>>8&255,S>>>16&255,S>>>24]},k.toBytesBE=function(){var S=this.high,D=this.low;return[S>>>24,S>>>16&255,S>>>8&255,S&255,D>>>24,D>>>16&255,D>>>8&255,D&255]},e.fromBytes=function(S,D,F){return F?e.fromBytesLE(S,D):e.fromBytesBE(S,D)},e.fromBytesLE=function(S,D){return new e(S[0]|S[1]<<8|S[2]<<16|S[3]<<24,S[4]|S[5]<<8|S[6]<<16|S[7]<<24,D)},e.fromBytesBE=function(S,D){return new e(S[4]<<24|S[5]<<16|S[6]<<8|S[7],S[0]<<24|S[1]<<16|S[2]<<8|S[3],D)},Sp}var hw=AC();const dw=oC(hw),RC=iC({__proto__:null,default:dw},[hw]);const Tr=dw||RC;function Ul(n){return Tr.fromString(n,!0,16)}const pw=Ul("c3a5c85c97cb3127"),Cr=Ul("b492b66fbe98f273"),Vt=Ul("9ae16a3b2f90404f");function Up(n){return n.xor(n.shru(47))}function fw(n,e,t){const s=n.slice(e,e+t);return Tr.fromBytes(Array.from(s),!0,!0)}function We(n,e){return fw(n,e,8)}function Xx(n,e){return fw(n,e,4)}function xt(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Js(n,e,t=Ul("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function DC(n,e,t,s,r,o){r=r.add(n),o=xt(o.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(t),o=o.add(xt(r,44)),[r.add(s),o.add(a)]}function Eu(n,e,t,s){return DC(We(n,e),We(n,e+8),We(n,e+16),We(n,e+24),t,s)}function OC(n,e=n.length){if(e>=8){const t=Vt.add(e*2),s=We(n,0).add(Vt),r=We(n,e-8),o=xt(r,37).mul(t).add(s),a=xt(s,25).add(r).mul(t);return Js(o,a,t)}if(e>=4){const t=Vt.add(e*2),s=Xx(n,0);return Js(s.shl(3).add(e),Xx(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],o=t+(s<<8),a=e+(r<<2);return Up(Vt.mul(o).xor(pw.mul(a))).mul(Vt)}return Vt}function _C(n,e=n.length){const t=Vt.add(e*2),s=We(n,0).mul(Cr),r=We(n,8),o=We(n,e-8).mul(t),a=We(n,e-16).mul(Vt);return Js(xt(s.add(r),43).add(xt(o,30)).add(a),s.add(xt(r.add(Vt),18)).add(o),t)}function FC(n,e=n.length){const t=Vt.add(e*2),s=We(n,0).mul(Vt),r=We(n,8),o=We(n,e-8).mul(t),a=We(n,e-16).mul(Vt),i=xt(s.add(r),43).add(xt(o,30)).add(a),l=Js(i,s.add(xt(r.add(Vt),18)).add(o),t),u=We(n,16).mul(t),c=We(n,24),h=i.add(We(n,e-32)).mul(t),d=l.add(We(n,e-24)).mul(t);return Js(xt(u.add(c),43).add(xt(h,30)).add(d),u.add(xt(c.add(s),18)).add(h),t)}function mw(n,e=n.length){const t=Tr.fromNumber(81,!0);if(e<=32)return e<=16?OC(n,e):_C(n,e);if(e<=64)return FC(n,e);let s=t,r=t.mul(Cr).add(113),o=Up(r.mul(Vt).add(113)).mul(Vt),a=[Tr.UZERO,Tr.UZERO],i=[Tr.UZERO,Tr.UZERO];s=s.mul(Vt).add(We(n,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do s=xt(s.add(r).add(a[0]).add(We(n,l+8)),37).mul(Cr),r=xt(r.add(a[1]).add(We(n,l+48)),42).mul(Cr),s=s.xor(i[1]),r=r.add(a[0]).add(We(n,l+40)),o=xt(o.add(i[0]),33).mul(Cr),a=Eu(n,l,a[1].mul(Cr),s.add(i[0])),i=Eu(n,l+32,o.add(i[1]),r.add(We(n,l+16))),[o,s]=[s,o],l+=64;while(l!==u);const h=Cr.add(o.and(255).shl(1));return l=c,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),s=xt(s.add(r).add(a[0]).add(We(n,l+8)),37).mul(h),r=xt(r.add(a[1]).add(We(n,l+48)),42).mul(h),s=s.xor(i[1].mul(9)),r=r.add(a[0].mul(9).add(We(n,l+40))),o=xt(o.add(i[0]),33).mul(h),a=Eu(n,l,a[1].mul(h),s.add(i[0])),i=Eu(n,l+32,o.add(i[1]),r.add(We(n,l+16))),[o,s]=[s,o],Js(Js(a[0],i[0],h).add(Up(r).mul(pw)).add(o),Js(a[1],i[1],h).add(s),h)}function _s(n,e){return e==="string"?as(n):pr([n],e)}function LC(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function pr(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=hs(n)),V().getBool("DEBUG")&&Q0(n,e),LC(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function kt(){return V().platform.now()}function gw(n,e){return V().platform.fetch(n,e)}function as(n,e="utf-8"){return e=e||"utf-8",V().platform.encode(n,e)}function ks(n,e="utf-8"){return e=e||"utf-8",V().platform.decode(n,e)}function dt(n){return V().platform.isTypedArray!=null?V().platform.isTypedArray(n):cw(n)}function hs(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Cs(n)||n==null||dt(n)&&t)e.push(n);else if(Array.isArray(n)||dt(n))for(let s=0;s<n.length;++s)hs(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)hs(n[r],e,t)}return e}const PC=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Ce,arraysEqualWithNull:J0,assert:I,assertNonNegativeIntegerDimensions:mn,assertNonNull:ro,assertShapesMatch:Ot,bytesFromStringArray:tw,bytesPerElement:wi,checkConversionForErrors:Q0,clamp:nr,computeStrides:de,convertBackendValuesAndArrayBuffer:rw,createScalarValue:_s,createShuffledIndices:mC,decodeString:ks,distSquared:dC,encodeString:as,fetch:gw,fingerPrint64:mw,flatten:hs,getArrayFromDType:tt,getTypedArrayFromDType:vt,hasEncodingLoss:Vf,hexToLong:Ul,indexToLoc:ao,inferDtype:oo,inferFromImplicitShape:Bf,isBoolean:nw,isFunction:sr,isInt:Br,isNumber:vc,isPromise:Cs,isScalarShape:pC,isString:rs,isTypedArray:dt,isValidDtype:ew,locToIndex:Un,makeOnesTypedArray:Jc,makeZerosNestedTypedArray:Wf,makeZerosTypedArray:Dt,nearestDivisor:$c,nearestLargerEven:Zc,now:kt,parseAxisParam:Ie,randUniform:hC,repeatedTry:Vp,rightPad:Fr,shuffle:Mf,shuffleCombo:cC,sizeFromShape:G,sizeToSquarishShape:wc,squeezeShape:Os,sum:Z0,swap:Ss,tanh:fC,toNestedArray:Sn,toTypedArray:pr},Symbol.toStringTag,{value:"Module"}));class zC{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new BC)}profileKernel(e,t,s){let r;const o=()=>{r=s()};let a;const i=kt();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const u of r)u.dataSync();a=Promise.resolve({kernelMs:kt()-i})}if(V().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(h=>{MC(h,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:o,extraInfo:a}=e;s.forEach(i=>{Promise.all([i.data(),r,a]).then(l=>{this.logger.logKernelProfile(t,i,l[0],l[1],o,l[2])})})}}function MC(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class BC{logKernelProfile(e,t,s,r,o,a){const i=typeof r=="number"?Fr(`${r}ms`,9):r.error,l=Fr(e,25),u=t.rank,c=t.size,h=Fr(t.shape.toString(),14);let d="";for(const p in o){const f=o[p];if(f!=null){const m=f.shape||t.shape,g=m.length;d+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${i}	%c${u}D ${h}	%c${c}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function VC(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const h in c){const d=c[h];let p=!1;for(let f=0;f<e.length;f++)if(s[d.id]){u.outputs.forEach(m=>s[m.id]=!0),p=!0,r[u.id]=!0;break}if(p)break}}const o={};o[t.id]=!0;const a={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(o[u.outputs[h].id]){for(const d in c)o[c[d].id]=!0,a[u.id]=!0;break}}const i=[];for(let l=0;l<n.length;l++){const u=n[l];if(r[u.id]&&a[u.id]){const c={};for(const d in u.inputs){const p=u.inputs[d];s[p.id]&&(c[d]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,i.push(h)}}return i}function WC(n,e,t,s){for(let r=e.length-1;r>=0;r--){const o=e[r],a=[];if(o.outputs.forEach(l=>{const u=n[l.id];u!=null?a.push(u):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const l in o.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);const u=t(()=>i[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!Ce(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{const h=n[c.id];n[c.id]=s(h,u),h.dispose()}}}}const Yx=20,oi=3,Ip=7;function UC(n,e,t,s){const r=de(e),o=GC(n,e,t,r),a=e.length,i=Gu(n,e,t,r,o),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(i.map(u=>"    "+u).join(`
`)),l.join(`
`)}function GC(n,e,t,s){const r=G(e),o=s[s.length-1],a=new Array(o).fill(0),i=e.length,l=t==="complex64"?hi(n):n;if(i>1)for(let u=0;u<r/o;u++){const c=u*o;for(let h=0;h<o;h++)a[h]=Math.max(a[h],ci(l[c+h],0,t).length)}return a}function ci(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Ip))} + ${parseFloat(n[1].toFixed(Ip))}j`:rs(n)?s=`'${n}'`:t==="bool"?s=yw(n):s=parseFloat(n.toFixed(Ip)).toString(),Fr(s,e)}function yw(n){return n===0?"false":"true"}function Gu(n,e,t,s,r,o=!0){const a=t==="complex64"?2:1,i=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=hi(n);return[ci(m[0],0,t)]}return t==="bool"?[yw(n[0])]:[n[0].toString()]}if(l===1){if(i>Yx){const g=oi*a;let y=Array.from(n.slice(0,g)),x=Array.from(n.slice((i-oi)*a,i*a));return t==="complex64"&&(y=hi(y),x=hi(x)),["["+y.map((w,b)=>ci(w,r[b],t)).join(", ")+", ..., "+x.map((w,b)=>ci(w,r[i-oi+b],t)).join(", ")+"]"]}return["["+(t==="complex64"?hi(n):Array.from(n)).map((g,y)=>ci(g,r[y],t)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*a,d=[];if(i>Yx){for(let m=0;m<oi;m++){const g=m*h,y=g+h;d.push(...Gu(n.slice(g,y),u,t,c,r,!1))}d.push("...");for(let m=i-oi;m<i;m++){const g=m*h,y=g+h;d.push(...Gu(n.slice(g,y),u,t,c,r,m===i-1))}}else for(let m=0;m<i;m++){const g=m*h,y=g+h;d.push(...Gu(n.slice(g,y),u,t,c,r,m===i-1))}const p=l===2?",":"";d[0]="["+(i>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function hi(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class ct{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=G(e),s!=null){const r=s.length;I(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||tt(t,this.size),this.strides=de(e)}set(e,...t){t.length===0&&(t=[0]),I(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Vn().makeTensor(this.values,this.shape,this.dtype)}}let Vn=null,$o=null;function HC(n){Vn=n}function jC(n){$o=n}class Ae{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=G(e),this.strides=de(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return $o.buffer(this.shape,this.dtype,e)}bufferSync(){return $o.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Sn(this.shape,e,this.dtype==="complex64")}arraySync(){return Sn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Vn().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>ks(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Vn().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Vn().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ks(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Vn().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Vn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return $o.print(this,e)}clone(){return this.throwIfDisposed(),$o.clone(this)}toString(e=!1){const t=this.dataSync();return UC(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),$o.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Vn().makeVariable(this,e,t,s)}}Object.defineProperty(Ae,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function H(){return Gf("Tensor",()=>Ae)}H();class Ci extends Ae{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Vn().disposeTensor(this),this.dataId=e.dataId,Vn().incRef(this,null)}dispose(){Vn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ci,Symbol.hasInstance,{value:n=>n instanceof Ae&&n.assign!=null&&n.assign instanceof Function});var Gp;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Gp||(Gp={}));var Hp;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Hp||(Hp={}));var jp;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(jp||(jp={}));var qp;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(qp||(qp={}));var Kp;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Kp||(Kp={}));const qC={float32:qp,int32:Hp,bool:jp,complex64:Kp};function Jt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return qC[n][e]}function od(n){return Jt(n,"int32")}function xw(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function bw(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Je(n,e){if(n.dtype===e.dtype)return[n,e];const t=Jt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function ww(n,e){I(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function ad(n,e){return e.some(t=>t.id===n.id)}function Ts(n){const e=[];return vw(n,e,new Set),e}function vw(n,e,t){if(n==null)return;if(n instanceof Ae){e.push(n);return}if(!KC(n))return;const s=n;for(const r in s){const o=s[r];t.has(o)||(t.add(o),vw(o,e,t))}}function KC(n){return Array.isArray(n)||typeof n=="object"}const XC=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:ww,getTensorsInContainer:Ts,isTensorInList:ad,makeTypesMatch:Je},Symbol.toStringTag,{value:"Module"}));function Np(n){return n.kernelName!=null}class Zx{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class To{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Zx}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(xn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new zC(this.backendInstance),!0}setupRegisteredKernels(){Cc(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Cc(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Yc)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,xn(`Initialization of backend ${e} failed`),xn(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return xn(`Initialization of backend ${e} failed`),xn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,o=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return To.nextTensorId++}nextVariableId(){return To.nextVariableId++}clone(e){const t=R.runKernel(ia,{x:e}),s={x:e},r=a=>({x:()=>{const i="float32",l={x:a},u={dtype:i};return R.runKernel(Ko,l,u)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,o,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(Ni(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let o=0;s.forEach(l=>{o+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let l;const u=Np(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Np(e)){const{kernelName:f,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=Ni(f,this.backendName);I(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{const x=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const w=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,x,w);const b=w.map($=>$.rank!=null?$:this.makeTensorFromTensorInfo($));if(r){const $=this.getTensorsForGradient(f,m,b);s=this.saveTensorsForBackwardMode($)}return b}}else{const{forwardFunc:f}=e,m=g=>{r&&(s=g.map(y=>this.keep(this.clone(y))))};i=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}const{inputs:c,attrs:h}=e,d=Np(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(p=this.profiler.profileKernel(u,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(u,c,t,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=Wp(e);if(r!=null){const o=r.inputsToSave||[],a=r.outputsToSave||[];let i;r.saveAllInputs?(I(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(u=>t[u])):i=o.map(u=>t[u]);const l=s.filter((u,c)=>a[c]);return i.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&rs(e[0])&&(o=e.map(l=>as(l)));const a=r.write(o,t,s),i=new Ae(t,s,a,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const l=this.state.tensorInfo.get(a),u=tw(o);this.state.numBytes+=u-l.bytes,l.bytes=u}return i}makeTensorFromDataId(e,t,s,r){s=s||"float32";const o={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:o}=e,a=new Ae(r,o,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new Ci(e,t,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*wi(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Ci||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*wi(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,o,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:o},l=Wp(e);l!=null&&(r=l.gradFunc),r!=null&&(i.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=s[h],p=Dt(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),r(u.length>1?u:u[0],o,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Ts(e),s=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,t,s,r=!1){if(I(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));I(o instanceof Ae,()=>"The result y returned by f() must be a tensor.");const a=VC(this.state.activeTape,t,o);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[o.id]=s??YC(o.shape),WC(i,a,u=>this.tidy(u),ZC);const l=t.map(u=>i[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:l}})}customGrad(e){return I(sr(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{I(t.every(i=>i instanceof Ae),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((i,l)=>{r[l]=i});const o=(i,l)=>(s=e(...t,l),I(s.value instanceof Ae,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(sr(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(i,l)=>{const u=s.gradFunc(i,l),c=Array.isArray(u)?u:[u];I(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(c.every(d=>d instanceof Ae),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=kt(),s=await this.backend.time(e);return s.wallMs=kt()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Zx;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}To.nextTensorId=0;To.nextVariableId=0;function YC(n){const e=Jc(G(n),"float32");return R.makeTensor(e,n,"float32")}function $w(){const n=aw();if(n._tfengine==null){const e=new ow(n);n._tfengine=new To(e)}return bC(n._tfengine.ENV),HC(()=>n._tfengine),n._tfengine}const R=$w();function ZC(n,e){const t={a:n,b:e};return R.runKernel(io,t)}function JC(){return typeof navigator<"u"&&navigator!=null}let Xp;function QC(n){Xp=n}function jf(n){if(Xp!==void 0)return Xp;if(n||JC()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function qf(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const ek=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:qf,isMobile:jf,mockIsMobile:QC},Symbol.toStringTag,{value:"Module"}));const Qt=V();Qt.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Qt.registerFlag("IS_BROWSER",()=>qf());Qt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Qt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Qt.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Qt.registerFlag("PROD",()=>!1);Qt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Qt.getBool("DEBUG"));Qt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Qt.registerFlag("IS_TEST",()=>!1);Qt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Qt.getBool("DEBUG"));Qt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Qt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Qt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function ds(n,e){let t=n;if(dt(n))return e==="string"?[]:[n.length];if(xw(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(bw(n))return[n.buffer.size/(e==null?4:wi(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||dt(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Sw(n,s,[]),s}function Sw(n,e,t){if(t=t||[],!Array.isArray(n)&&!dt(n)){I(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}I(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),I(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)Sw(n[r],s,t.concat(r))}function Jx(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function C(n,e,t,s="numeric"){if(n instanceof H())return Jx(s,n.dtype,e,t),n;let r=oo(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),Jx(s,r,e,t),n==null||!dt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const o=ds(n,r);!dt(n)&&!Array.isArray(n)&&(n=[n]);const i=r!=="string"?pr(n,r):hs(n,[],!0);return R.makeTensor(i,o,r)}function ki(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,a)=>C(o,`${e}[${a}]`,t,s))}const Kf="__op";function O(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Kf;const r=(...o)=>{R.startScope(t);try{const a=s(...o);return Cs(a)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(a),a}catch(a){throw R.endScope(null),a}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}function tk(n,e){const t=C(n,"real","complex"),s=C(e,"imag","complex");Ot(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return R.runKernel(oh,r)}const Es=O({complex_:tk});function fr(n,e,t,s){if(s==null)s=oo(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(bw(n)||xw(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return R.backend.createTensorFromGPUData(n,e||t,s)}if(!dt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){mn(e);const r=G(e),o=G(t);I(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let a=0;a<t.length;++a){const i=t[a],l=a===t.length-1?i!==G(e.slice(a)):!0;I(t[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!dt(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?pr(n,s):hs(n,[],!0),R.makeTensor(n,e,s)}function cn(n,e,t){const s=ds(n,t);return fr(n,e,s,t)}const Vr={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Zn{static join(e){return new Zn(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>dt(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+r.byteLength;this.shards.push({buffer:r,start:t,end:o}),t=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,o=new ArrayBuffer(r),a=new Uint8Array(o);let i=0;for(let l=s;l<this.shards.length;l++){const u=this.shards[l],h=e+i-u.start,d=i,f=Math.min(t,u.end)-u.start,m=new Uint8Array(u.buffer,h,f-h);if(a.set(m,d),i+=m.length,t<u.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=nk(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function nk(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,o=e(n[r]);if(o===0)return r;o<0?s=r:t=r+1}return-1}function sk(){V().set("PROD",!0)}function rk(){V().set("DEBUG",!0)}function ok(){V().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ak(n){V().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function ik(){R.disposeVariables()}function Bn(){return R}function Yp(){return R.memory()}function lk(n){return R.profile(n)}function B(n,e){return R.tidy(n,e)}function ye(n){Ts(n).forEach(t=>t.dispose())}function pt(n){return R.keep(n)}function uk(n){return R.time(n)}function ck(n){return R.setBackend(n)}function hk(){return R.ready()}function Iw(){return R.backendName}function dk(n){R.removeBackend(n)}function pk(n){return R.findBackend(n)}function fk(n){return R.findBackendFactory(n)}function Xf(n,e,t=1){return R.registerBackend(n,e,t)}function Yf(){return R.backend}function mk(n,e){V().setPlatform(n,e)}const rr=4;async function Zp(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const i=r[a],l=Array.isArray(n)?n[a].tensor:n[i];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);const u={name:i,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((g,y)=>g+y.length,0)+rr*d.length,f=new Uint8Array(p);let m=0;for(let g=0;g<d.length;g++){const y=d[g],x=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(x,m),m+=rr,f.set(y,m),m+=y.length}h(f)});s.push(c)}else s.push(l.data());e!=null&&(u.group=e),t.push(u)}const o=await Promise.all(s);return{data:xk(o),specs:t}}function Zf(n,e){const t=new Zn(n),s={};let r=0;for(const o of e){const a=gk(o,(i,l)=>t.slice(r+i,r+l));s[o.name]=Nw(o,t.slice(r,r+a)),r+=a}return s}function gk(n,e){const t=G(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Vr[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=rr+new Uint32Array(e(r,r+rr))[0];return r}else s=Vr[n.dtype];return t*s}async function yk(n,e){const t=G(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Vr[r.dtype]}else if(n.dtype==="string"){let r=0;for(let o=0;o<t;o++)r+=rr+new Uint32Array(await e(r,r+rr))[0];return r}else s=Vr[n.dtype];return t*s}function Nw(n,e){const t=n.name,s=n.dtype,r=n.shape,o=G(r);let a,i=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=Vr[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){a=new Float32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];a[h]=d*l.scale+l.min}}else if(l.dtype==="float16")a=Ik()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);a=new Int32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];a[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);i+=o*u}else if(s==="string"){const l=G(n.shape);a=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(i,i+rr))[0];i+=rr;const h=new Uint8Array(e.slice(i,i+c));a.push(h),i+=c}}else{const l=Vr[s];if(s==="float32")a=new Float32Array(e);else if(s==="int32")a=new Int32Array(e);else if(s==="bool")a=new Uint8Array(e);else if(s==="complex64"){a=new Float32Array(e);const u=new Float32Array(a.length/2),c=new Float32Array(a.length/2);for(let f=0;f<u.length;f++)u[f]=a[f*2],c[f]=a[f*2+1];const h=cn(u,r,"float32"),d=cn(c,r,"float32"),p=Es(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);i+=o*l}return cn(a,r,s)}async function Qx(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:o}=await n.read();if(r&&o==null){const i=t-s.byteLength;throw new Error(`Reader is done but ${i} bytes are still expected`)}const a=new Uint8Array(s.length+o.byteLength);a.set(s,0),a.set(new Uint8Array(o),s.length),s=a}return s.buffer}async function Cw(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const o of e){const a=await yk(o,async(u,c)=>(r=await Qx(s,r,c),r.slice(u,c)));r=await Qx(s,r,a);const i=r.slice(0,a);r=r.slice(a);const l=Nw(o,i);if(t[o.name]=l,Iw()==="webgpu"){const u=Yf();"uploadToGPU"in u&&G(l.shape)>=V().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return t}function xk(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const Jf=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function eb(n){return Jf?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function bk(n){if(Jf)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function wk(n){if(Jf){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function kw(n){return Zn.join(n)}function tb(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function Tw(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Qf(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function em(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),Qf(n,t,s)}function Gl(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:eb(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:eb(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Zn(n.weightData).byteLength}}function kc(n){const e=[];for(const t of n)e.push(...t.weights);return e}function vk(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function $k(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Sk(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Ik(){const n=vk(),e=$k(),t=Sk();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let a=0;a<s.length;a++){const i=s[a],l=n[t[i>>10]+(i&1023)]+e[i>>10];o[a]=l}return new Float32Array(r)}}class Xe{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Xe.instance==null&&(Xe.instance=new Xe),Xe.instance}static registerSaveRouter(e){Xe.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Xe.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Xe.getHandlers(e,"save")}static getLoadHandlers(e,t){return Xe.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?Xe.getInstance().loadRouters:Xe.getInstance().saveRouters).forEach(a=>{const i=a(e,s);i!==null&&r.push(i)}),r}}const Nk=n=>Xe.registerSaveRouter(n),Ck=n=>Xe.registerLoadRouter(n),Ew=n=>Xe.getSaveHandlers(n),Aw=(n,e)=>Xe.getLoadHandlers(n,e);const Jp="tensorflowjs",Qp=1,Or="models_store",Ks="model_info_store";function Rw(){if(!V().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function ef(n){const e=n.result;e.createObjectStore(Or,{keyPath:"modelPath"}),e.createObjectStore(Ks,{keyPath:"modelPath"})}class Wr{constructor(e){if(this.indexedDB=Rw(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const o=this.indexedDB.open(Jp,Qp);o.onupgradeneeded=()=>ef(o),o.onsuccess=()=>{const a=o.result;if(t==null){const i=a.transaction(Or,"readonly"),u=i.objectStore(Or).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=c=>(a.close(),r(u.error)),i.oncomplete=()=>a.close()}else{t.weightData=Zn.join(t.weightData);const i=Gl(t),l=a.transaction(Ks,"readwrite");let u=l.objectStore(Ks),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return r(d)}let h;c.onsuccess=()=>{h=a.transaction(Or,"readwrite");const d=h.objectStore(Or);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(f){return r(f)}p.onsuccess=()=>s({modelArtifactsInfo:i}),p.onerror=f=>{u=l.objectStore(Ks);const m=u.delete(this.modelPath);m.onsuccess=()=>(a.close(),r(p.error)),m.onerror=g=>(a.close(),r(p.error))}},c.onerror=d=>(a.close(),r(c.error)),l.oncomplete=()=>{h==null?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>r(o.error)})}}Wr.URL_SCHEME="indexeddb://";const Dw=n=>V().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Wr.URL_SCHEME)?kk(n.slice(Wr.URL_SCHEME.length)):null;Xe.registerSaveRouter(Dw);Xe.registerLoadRouter(Dw);function kk(n){return new Wr(n)}function Tk(n){return n.startsWith(Wr.URL_SCHEME)?n.slice(Wr.URL_SCHEME.length):n}class Ek{constructor(){this.indexedDB=Rw()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(Jp,Qp);s.onupgradeneeded=()=>ef(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(Ks,"readonly"),i=o.objectStore(Ks).getAll();i.onsuccess=()=>{const l={};for(const u of i.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},i.onerror=l=>(r.close(),t(i.error)),o.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=Tk(e),new Promise((t,s)=>{const r=this.indexedDB.open(Jp,Qp);r.onupgradeneeded=()=>ef(r),r.onsuccess=()=>{const o=r.result,a=o.transaction(Ks,"readwrite"),i=a.objectStore(Ks),l=i.get(e);let u;l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=i.delete(e),h=()=>{u=o.transaction(Or,"readwrite");const p=u.objectStore(Or).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};c.onsuccess=h,c.onerror=d=>(h(),o.close(),s(l.error))}},l.onerror=c=>(o.close(),s(l.error)),a.oncomplete=()=>{u==null?o.close():u.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}const Is="/",So="tensorflowjs_models",Ow="info",Ak="model_topology",Rk="weight_specs",Dk="weight_data",Ok="model_metadata";function _w(n){return{info:[So,n,Ow].join(Is),topology:[So,n,Ak].join(Is),weightSpecs:[So,n,Rk].join(Is),weightData:[So,n,Dk].join(Is),modelMetadata:[So,n,Ok].join(Is)}}function Fw(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function _k(n){const e=n.split(Is);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Is)}function Fk(n){return n.startsWith(Ur.URL_SCHEME)?n.slice(Ur.URL_SCHEME.length):n}class Ur{constructor(e){if(!V().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=_w(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Gl(e),o=Zn.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,bk(o));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw Fw(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const i=JSON.parse(o);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=wk(a),t}}Ur.URL_SCHEME="localstorage://";const Lw=n=>V().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ur.URL_SCHEME)?Lk(n.slice(Ur.URL_SCHEME.length)):null;Xe.registerSaveRouter(Lw);Xe.registerLoadRouter(Lw);function Lk(n){return new Ur(n)}class Pk{constructor(){I(V().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=So+Is,s=Is+Ow;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(t)&&o.endsWith(s)){const a=_k(o);e[a]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=Fk(e);const t=_w(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return Fw(t),s}}const Io="://";class Bt{constructor(){this.managers={}}static getInstance(){return Bt.instance==null&&(Bt.instance=new Bt),Bt.instance}static registerManager(e,t){I(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Io)&&(e=e.slice(0,e.indexOf(Io))),I(e.length>0,()=>"scheme must not be an empty string.");const s=Bt.getInstance();I(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=Bt.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Bt.getInstance().managers)}}function Hu(n){if(n.indexOf(Io)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Bt.getSchemes().join(",")}`);return{scheme:n.split(Io)[0],path:n.split(Io)[1]}}async function Pw(n,e,t=!1){I(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=Xe.getLoadHandlers(n);I(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),I(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],o=Xe.getSaveHandlers(e);I(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),I(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=o[0],i=Hu(n).scheme,l=Hu(n).path,u=i===Hu(n).scheme,c=await r.load();t&&u&&await Bt.getManager(i).removeModel(l);const h=await a.save(c);return t&&!u&&await Bt.getManager(i).removeModel(l),h.modelArtifactsInfo}async function zk(){const n=Bt.getSchemes(),e={};for(const t of n){const s=await Bt.getManager(t).listModels();for(const r in s){const o=t+Io+r;e[o]=s[r]}}return e}async function Mk(n){const e=Hu(n);return Bt.getManager(e.scheme).removeModel(e.path)}async function Bk(n,e){return Pw(n,e,!1)}async function Vk(n,e){return Pw(n,e,!0)}class Wk{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!V().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return cw(e)}}if(V().get("IS_BROWSER")){V().setPlatform("browser",new Wk);try{Bt.registerManager(Ur.URL_SCHEME,new Pk)}catch{}try{Bt.registerManager(Wr.URL_SCHEME,new Ek)}catch{}}const Uk={importFetch:()=>require("node-fetch")};let Cp;class Gk{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return V().global.fetch!=null?V().global.fetch(e,t):(Cp==null&&(Cp=Uk.importFetch()),Cp(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}V().get("IS_NODE")&&!V().get("IS_BROWSER")&&V().setPlatform("node",new Gk);function we(n,e="float32",t){return e=e||"float32",mn(n),new ct(n,e,t)}function Hk(n,e){const t=C(n,"x","cast");if(!ew(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return R.runKernel(Ko,s,r)}const ee=O({cast_:Hk});function jk(n){const t={x:C(n,"x","clone","string_or_numeric")};return R.runKernel(ia,t)}const is=O({clone_:jk});function tm(n,e=!1){console.log(n.toString(e))}$w();const qk={buffer:we,cast:ee,clone:is,print:tm};jC(qk);function Kk(n,e){let t=C(n,"a","add"),s=C(e,"b","add");[t,s]=Je(t,s);const r={a:t,b:s};return R.runKernel(io,r)}const Y=O({add_:Kk});function Xk(n,e){let t=C(n,"a","floorDiv"),s=C(e,"b","floorDiv");[t,s]=Je(t,s);const r={a:t,b:s};return R.runKernel(oa,r)}const id=O({floorDiv_:Xk});function Yk(n,e){let t=C(n,"a","div"),s=C(e,"b","div");if([t,s]=Je(t,s),t.dtype==="int32"&&s.dtype==="int32")return id(t,s);const r={a:t,b:s},o={};return R.runKernel(Qo,r,o)}const ue=O({div_:Yk});function Zk(n,e){let t=C(n,"a","mul"),s=C(e,"b","mul");[t,s]=Je(t,s);const r={a:t,b:s};return R.runKernel(ga,r)}const _=O({mul_:Zk});function Jk(n){const e=C(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return R.runKernel(Xi,t)}else{const t={x:e};return R.runKernel(Bi,t)}}const it=O({abs_:Jk});function Qk(n){const t={x:C(n,"x","acos")};return R.runKernel(Vo,t)}const nm=O({acos_:Qk});function eT(n){const t={x:C(n,"x","acosh")};return R.runKernel(Wo,t)}const sm=O({acosh_:eT});function tT(n){I(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),I(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,o)=>C(r,`tensors${o}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Ce(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return R.runKernel(Vi,s)}const zw=O({addN_:tT});function nT(n,e=null,t=!1){const r={x:C(n,"x","all","bool")},o={axis:e,keepDims:t};return R.runKernel(Qc,r,o)}const ld=O({all_:nT});function sT(n,e=null,t=!1){const r={x:C(n,"x","any","bool")},o={axis:e,keepDims:t};return R.runKernel(eh,r,o)}const Ti=O({any_:sT});function rT(n,e=0){const s={x:C(n,"x","argMax")},r={axis:e};return R.runKernel(Wi,s,r)}const Gr=O({argMax_:rT});function oT(n,e=0){const s={x:C(n,"x","argMin")},r={axis:e};return R.runKernel(Ui,s,r)}const rm=O({argMin_:oT});function aT(n){const t={x:C(n,"x","asin")};return R.runKernel(Uo,t)}const om=O({asin_:aT});function iT(n){const t={x:C(n,"x","asinh")};return R.runKernel(Go,t)}const am=O({asinh_:iT});function lT(n){const t={x:C(n,"x","atan")};return R.runKernel(Ho,t)}const im=O({atan_:lT});function uT(n,e){let t=C(n,"a","atan2"),s=C(e,"b","atan2");[t,s]=Je(t,s);const r={a:t,b:s};return R.runKernel(qo,r)}const lm=O({atan2_:uT});function cT(n){const t={x:C(n,"x","atanh")};return R.runKernel(jo,t)}const um=O({atanh_:cT});function Hl(n,e,t,s,r="NHWC",o){const a=n[3],i=[...e,a],l=Ls(r);return It(n,i,t,o,s,null,null,l)}function _n(n,e,t,s,r,o,a="channelsLast"){const[i,l]=Ei(e);let u;if(a==="channelsLast")u=[i,l,n[3],n[3]];else if(a==="channelsFirst")u=[i,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return It(n,u,t,s,r,o,!1,a)}function Fs(n,e,t,s,r,o,a="NDHWC"){const[i,l,u]=tf(e);let c,h;if(a==="NDHWC")h="channelsLast",c=[i,l,u,n[4],n[4]];else if(a==="NCDHW")h="channelsFirst",c=[i,l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return mr(n,c,t,s,r,!1,h,o)}function It(n,e,t,s,r,o,a=!1,i="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,h]=n;else if(i==="channelsFirst")[l,h,u,c]=n;else throw new Error(`Unknown dataFormat ${i}`);const[d,p,,f]=e,[m,g]=Ei(t),[y,x]=Ei(s),w=No(d,y),b=No(p,x),{padInfo:$,outHeight:N,outWidth:T}=pT(r,u,c,m,g,w,b,o,i),A=a?f*h:f;let k;return i==="channelsFirst"?k=[l,A,N,T]:i==="channelsLast"&&(k=[l,N,T,A]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:h,outHeight:N,outWidth:T,outChannels:A,padInfo:$,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:w,effectiveFilterWidth:b,dilationHeight:y,dilationWidth:x,inShape:n,outShape:k,filterShape:e}}function mr(n,e,t,s,r,o=!1,a="channelsLast",i){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h,d]=n;else if(a==="channelsFirst")[l,d,u,c,h]=n;else throw new Error(`Unknown dataFormat ${a}`);const[p,f,m,,g]=e,[y,x,w]=tf(t),[b,$,N]=tf(s),T=No(p,b),A=No(f,$),k=No(m,N),{padInfo:E,outDepth:S,outHeight:D,outWidth:F}=fT(r,u,c,h,y,x,w,T,A,k,i),z=o?g*d:g;let M;return a==="channelsFirst"?M=[l,z,S,D,F]:a==="channelsLast"&&(M=[l,S,D,F,z]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:S,outHeight:D,outWidth:F,outChannels:z,padInfo:E,strideDepth:y,strideHeight:x,strideWidth:w,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:T,effectiveFilterHeight:A,effectiveFilterWidth:k,dilationDepth:b,dilationHeight:$,dilationWidth:N,inShape:n,outShape:M,filterShape:e}}function hT(n,e,t,s,r){s==null&&(s=cm(n,e,t));const o=n[0],a=n[1],i=Ai((o-e+2*s)/t+1,r),l=Ai((a-e+2*s)/t+1,r);return[i,l]}function dT(n,e,t,s,r,o){r==null&&(r=cm(n,e[0],s[0]));const a=[0,0,0,t];for(let i=0;i<3;i++)n[i]+2*r>=e[i]&&(a[i]=Ai((n[i]-e[i]+2*r)/s[i]+1,o));return a}function cm(n,e,t,s=1){const r=No(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function Ei(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function tf(n){return typeof n=="number"?[n,n,n]:n}function No(n,e){return e<=1?n:n+(n-1)*(e-1)}function pT(n,e,t,s,r,o,a,i,l){let u,c,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=hT([e,t],o,s,n,i);c=p[0],h=p[1]}else if(n==="same"){c=Math.ceil(e/s),h=Math.ceil(t/r);const d=Math.max(0,(c-1)*s+o-e),p=Math.max(0,(h-1)*r+a-t),f=Math.floor(d/2),m=d-f,g=Math.floor(p/2),y=p-g;u={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/s),h=Math.ceil((t-a+1)/r);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];u={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=Ai((e-o+d+p)/s+1,i),h=Ai((t-a+f+m)/r+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:h}}function fT(n,e,t,s,r,o,a,i,l,u,c){let h,d,p,f;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=dT([e,t,s,1],[i,l,u],1,[r,o,a],n,c);d=g[0],p=g[1],f=g[2]}else if(n==="same"){d=Math.ceil(e/r),p=Math.ceil(t/o),f=Math.ceil(s/a);const m=(d-1)*r+i-e,g=(p-1)*o+l-t,y=(f-1)*a+u-s,x=Math.floor(m/2),w=m-x,b=Math.floor(g/2),$=g-b,N=Math.floor(y/2),T=y-N;h={top:b,bottom:$,left:N,right:T,front:x,back:w,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function Ai(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function or(n){const[e,t,s]=Ei(n);return e===1&&t===1&&s===1}function _t(n,e){return or(n)||or(e)}function Hr(n){return Ei(n).every(e=>e>0)}function Ls(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function jt(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")I(Br(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{I(Br(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function mT(n,e){const s={x:C(n,"x","reshape","string_or_numeric")},r={shape:e};return R.runKernel(El,s,r)}const L=O({reshape_:mT});function gT(n,e,t,s,r){const o=C(n,"x","avgPool","float32"),a=1;I(_t(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=o,l=!1;o.rank===3&&(l=!0,i=L(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),jt("avgPool",s,r);const u={x:i},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let h=R.runKernel(Gi,u,c);return h=ee(h,o.dtype),l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const jl=O({avgPool_:gT});function yT(n,e,t,s,r,o="NDHWC"){const a=C(n,"x","avgPool3d","float32");let i=a,l=!1;a.rank===4&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),I(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),I(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),I(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),jt("avgPool3d",s,r);const u={x:i},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o};let h=R.runKernel(Hi,u,c);return h=ee(h,i.dtype),l?L(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const hm=O({avgPool3d_:yT});function xT(n,e=0){I(n.length>=1,()=>"Pass at least one tensor to concat");const t=ki(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return is(t[0]);const s=t,r={axis:e};return R.runKernel(Yi,s,r)}const nt=O({concat_:xT});function bT(n,e,t=!1,s=!1){let r=C(n,"a","matMul"),o=C(e,"b","matMul");[r,o]=Je(r,o);const a={a:r,b:o},i={transposeA:t,transposeB:s};return R.runKernel(ji,a,i)}const Se=O({matMul_:bT});function wT(n){const t={x:C(n,"x","sigmoid","float32")};return R.runKernel(ka,t)}const Gn=O({sigmoid_:wT});function vT(n,e,t){const s=C(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:t};return R.runKernel(_l,r,o)}const Te=O({slice_:vT});function $T(n){const t={x:C(n,"x","tanh","float32")};return R.runKernel(Oa,t)}const ar=O({tanh_:$T});function ST(n,e,t,s,r,o){const a=C(n,"forgetBias","basicLSTMCell"),i=C(e,"lstmKernel","basicLSTMCell"),l=C(t,"lstmBias","basicLSTMCell"),u=C(s,"data","basicLSTMCell"),c=C(r,"c","basicLSTMCell"),h=C(o,"h","basicLSTMCell"),d=nt([u,h],1),p=Se(d,i),f=Y(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],x=Te(f,[0,0],y),w=Te(f,[0,g],y),b=Te(f,[0,g*2],y),$=Te(f,[0,g*3],y),N=Y(_(Gn(x),ar(w)),_(c,Gn(Y(a,b)))),T=_(ar(N),Gn($));return[N,T]}const Mw=O({basicLSTMCell_:ST});function IT(n,e,t){const s=C(n,"x","batchToSpaceND"),r=e.reduce((i,l)=>i*l);I(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),I(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),I(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},a={blockShape:e,crops:t};return R.runKernel(qi,o,a)}const ql=O({batchToSpaceND_:IT});function NT(n){let e;return n.rank===0||n.rank===1?e=L(n,[1,1,1,n.size]):n.rank===2?e=L(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=L(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function CT(n,e,t,s,r,o){o==null&&(o=.001);const a=C(n,"x","batchNorm"),i=C(e,"mean","batchNorm"),l=C(t,"variance","batchNorm");let u;r!=null&&(u=C(r,"scale","batchNorm"));let c;s!=null&&(c=C(s,"offset","batchNorm")),I(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:NT(a),scale:u,offset:c,mean:i,variance:l},p={varianceEpsilon:o},f=R.runKernel(ol,d,p);return L(f,a.shape)}const La=O({batchNorm_:CT});function kT(n,e,t,s,r,o){const a=C(n,"x","batchNorm"),i=C(e,"mean","batchNorm"),l=C(t,"variance","batchNorm");let u;r!=null&&(u=C(r,"scale","batchNorm"));let c;return s!=null&&(c=C(s,"offset","batchNorm")),I(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),I(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),I(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&I(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&I(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),La(a,i,l,c,u,o)}const dm=O({batchNorm2d_:kT});function TT(n,e,t,s,r,o){const a=C(n,"x","batchNorm"),i=C(e,"mean","batchNorm"),l=C(t,"variance","batchNorm");let u;r!=null&&(u=C(r,"scale","batchNorm"));let c;return s!=null&&(c=C(s,"offset","batchNorm")),I(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),I(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),I(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&I(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&I(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),La(a,i,l,c,u,o)}const pm=O({batchNorm3d_:TT});function ET(n,e,t,s,r,o){const a=C(n,"x","batchNorm"),i=C(e,"mean","batchNorm"),l=C(t,"variance","batchNorm");let u;r!=null&&(u=C(r,"scale","batchNorm"));let c;return s!=null&&(c=C(s,"offset","batchNorm")),I(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),I(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),I(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&I(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&I(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),La(a,i,l,c,u,o)}const fm=O({batchNorm4d_:ET});function AT(n,e,t){const s=C(n,"x","bincount"),r=C(e,"weights","bincount");I(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},a={size:t};return R.runKernel(sh,o,a)}const mm=O({bincount_:AT});function RT(n,e){const t=C(n,"x","bitwiseAnd"),s=C(e,"y","bitwiseAnd");if(!Ce(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return R.runKernel(Ki,r)}const Bw=O({bitwiseAnd_:RT});function DT(n,e){const t=C(n,"s0","broadcastArgs","int32"),s=C(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return R.runKernel(rh,r)}const Vw=O({broadcastArgs_:DT});function OT(n,e){let t=C(n,"broadcastTo","x");const s=t.shape;if(mn(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=L(t,u)}const r=t.shape,o=Array.from(e);for(let u=e.length-1;u>=0;u--)if(r[u]===e[u])o[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return is(t);const i={x:t},l={reps:o};return R.runKernel(_a,i,l)}const Pr=O({broadcastTo_:OT});function _T(n){const t={x:C(n,"x","ceil","float32")};return R.runKernel(Xo,t)}const gm=O({ceil_:_T});function lo(n,e,t){mn(n),t=t||oo(e);const s={shape:n,value:e,dtype:t};return R.runKernel(wh,{},s)}function FT(n,e,t){const s=C(n,"x","clipByValue");if(I(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return lo(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:t};return R.runKernel(Yo,r,o)}const en=O({clipByValue_:FT});function LT(n){return nt(n,0)}const ym=O({concat1d_:LT});function PT(n,e){return nt(n,e)}const xm=O({concat2d_:PT});function zT(n,e){return nt(n,e)}const bm=O({concat3d_:zT});function MT(n,e){return nt(n,e)}const wm=O({concat4d_:MT});function BT(n,e,t,s,r="NHWC",o=[1,1],a){const i=C(n,"x","conv2d","float32"),l=C(e,"filter","conv2d","float32");let u=i,c=!1;i.rank===3&&(c=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),I(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),jt("conv2d",s,a);const h=r==="NHWC"?u.shape[3]:u.shape[1];I(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),I(_t(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),I(Hr(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),I(Hr(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},f=R.runKernel(Zi,d,p);return c?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const As=O({conv2d_:BT});function VT(n,e,t,s,r="NWC",o=1,a){const i=C(n,"x","conv1d"),l=C(e,"filter","conv1d");let u=i,c=!1;i.rank===2&&(c=!0,u=L(i,[1,i.shape[0],i.shape[1]])),I(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),I(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),jt("conv1d",s,a),I(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),I(_t(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),I(Hr(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),I(Hr(t),()=>"Error in conv1D: Stride should be larger than 0."),I(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=L(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=L(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=As(d,h,[1,t],s,"NHWC",[1,o],a);return c?L(g,[g.shape[2],g.shape[3]]):L(g,[g.shape[0],g.shape[2],g.shape[3]])}const ud=O({conv1d_:VT});function WT(n,e,t,s,r,o="NHWC",a){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,l=e,u=!1;e.rank===3&&(u=!0,l=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,n[0],n[1],n[2]]),I(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),I(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),I(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=o==="NHWC"?i[3]:i[1],h=o==="NHWC"?l.shape[3]:l.shape[1];I(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),I(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),jt("conv2dDerInput",r,a);const d={dy:l,filter:t},p={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,inputShape:i},f=R.runKernel(Ji,d,p);return u?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vm=O({conv2DBackpropInput_:WT});function UT(n,e,t,s,r,o){const a=C(n,"x","conv2dTranspose"),i=C(e,"filter","conv2dTranspose");return vm(t,a,i,s,r,"NHWC",o)}const cd=O({conv2dTranspose_:UT});function GT(n,e,t,s,r="NDHWC",o=[1,1,1]){const a=C(n,"x","conv3d"),i=C(e,"filter","conv3d");let l=a,u=!1;a.rank===4&&(u=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),I(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),I(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),I(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),I(_t(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),I(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),I(Hr(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),I(Hr(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:i},h={strides:t,pad:s,dataFormat:r,dilations:o},d=R.runKernel(Qi,c,h);return u?L(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const $m=O({conv3d_:GT});function HT(n,e,t,s,r){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,a=e,i=!1;e.rank===4&&(i=!0,a=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const l=o[4],u=a.shape[4];I(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),I(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),I(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),I(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),I(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:a,filter:t},h={pad:r,strides:s,inputShape:o},d=R.runKernel(lh,c,h);return i?L(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Ww=O({conv3DBackpropInput_:HT});function jT(n,e,t,s,r){const o=C(n,"x","conv3dTranspose"),a=C(e,"filter","conv3dTranspose");return Ww(t,o,a,s,r)}const Sm=O({conv3dTranspose_:jT});function qT(n){const t={x:C(n,"x","cos","float32")};return R.runKernel(Zo,t)}const Kl=O({cos_:qT});function KT(n){const t={x:C(n,"x","cosh","float32")};return R.runKernel(Jo,t)}const hd=O({cosh_:KT});function XT(n,e=0,t=!1,s=!1){const o={x:C(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:s};return R.runKernel(uh,o,a)}const Ri=O({cumprod_:XT});function YT(n,e=0,t=!1,s=!1){const o={x:C(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:s};return R.runKernel(el,o,a)}const dd=O({cumsum_:YT});function ZT(n,e,t,s=!1){const r=C(n,"x","denseBincount"),o=C(e,"weights","denseBincount");I(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),I(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const a={x:r,weights:o},i={size:t,binaryOutput:s};return R.runKernel(hh,a,i)}const Tc=O({denseBincount_:ZT});function JT(n,e,t="NHWC"){const s=C(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],o=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];I(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),I(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),I(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),I(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const i={x:s},l={blockSize:e,dataFormat:t};return R.runKernel(dh,i,l)}const Im=O({depthToSpace_:JT});function QT(n,e,t,s,r="NHWC",o=[1,1],a){const i=C(n,"x","depthwiseConv2d","float32"),l=C(e,"filter","depthwiseConv2d","float32");let u=i,c=!1;i.rank===3&&(c=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),I(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?u.shape[3]:u.shape[1];I(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),jt("depthwiseConv2d",s,a);const d={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a},f=R.runKernel(tl,d,p);return c?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Pa=O({depthwiseConv2d_:QT});function e2(n){const t={x:C(n,"x","diag")};return R.runKernel(mh,t)}const Uw=O({diag_:e2});function t2(n,e,t,s,r=[1,1],o="NHWC"){const a=C(n,"x","dilation2d"),i=C(e,"filter","dilation2d");I(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),I(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),I(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=a,u=!1;a.rank===3&&(l=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0),I(l.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${i.shape[2]}`);const c={x:l,filter:i},h={strides:t,pad:s,dilations:r},d=R.runKernel(nl,c,h);return u?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Nm=O({dilation2d_:t2});function jr(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const o=t-1-r,a=n[o]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(o)}return s}function ht(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],o=e.length-s-1,a=e[o];(r==null||r===1&&a>1)&&t.unshift(o)}return t}function xe(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let o=n[n.length-r-1];o==null&&(o=1);let a=e[e.length-r-1];if(a==null&&(a=1),o===1)s[t-r-1]=a;else if(a===1)s[t-r-1]=o;else if(o!==a){const i=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(i)}else s[t-r-1]=o}return s}const n2=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:xe,getBroadcastDims:jr,getReductionAxes:ht},Symbol.toStringTag,{value:"Module"}));function s2(n,e){let t=C(n,"a","equal","string_or_numeric"),s=C(e,"b","equal","string_or_numeric");[t,s]=Je(t,s),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(sl,r)}const hn=O({equal_:s2});function r2(n,e,t){const s=C(e,"a","where"),r=C(t,"b","where"),o=C(n,"condition","where","bool"),a=xe(xe(o.shape,s.shape),r.shape),i=Pr(o,a),l=Pr(s,a),u=Pr(r,a),c={condition:i,t:l,e:u};return R.runKernel(Ol,c)}const wt=O({where_:r2});function o2(n){const t={x:C(n,"x","zerosLike")};return R.runKernel(Wl,t)}const Ee=O({zerosLike_:o2});function a2(n,e){let t=C(n,"a","div"),s=C(e,"b","div");[t,s]=Je(t,s);const r=ue(t,s),o=Ee(r),a=hn(s,o);return wt(a,o,r)}const Cm=O({divNoNan_:a2});function i2(n,e){const t=C(n,"t1","dot"),s=C(e,"t2","dot");I((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],o=s.rank===1?s.size:s.shape[0];if(I(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),t.rank===1&&s.rank===1){const a=L(t,[1,-1]),i=L(s,[-1,1]),l=Se(a,i);return L(l,[])}else if(t.rank===1&&s.rank===2){const a=L(t,[1,-1]),i=L(s,[s.shape[0],s.shape[1]]),l=Se(a,i);return L(l,[l.size])}else if(t.rank===2&&s.rank===1){const a=L(s,[-1,1]),i=Se(t,a);return L(i,[i.size])}else{const a=L(s,[s.shape[0],s.shape[1]]);return Se(t,a)}}const km=O({dot_:i2});function l2(n,...e){const t=e.map((r,o)=>C(r,`tensors${o}`,"einsum")),s={equation:n};return R.runKernel(yh,t,s)}const Er=O({einsum_:l2});function u2(n){const t={x:C(n,"x","elu","float32")};return R.runKernel(ea,t)}const za=O({elu_:u2});function c2(n,e){const t=C(n,"x","ensureShape","string_or_numeric");if(!J0(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const Gw=O({ensureShape_:c2});function h2(n){let e=C(n,"x","erf");I(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ee(e,"float32"));const t={x:e};return R.runKernel(ta,t)}const pd=O({erf_:h2});function Tm(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Hw(n,e,t){const s=n.length+e.length,r=[];let o=0,a=0;for(let i=0;i<s;i++)t.indexOf(i)===-1?r.push(n[o++]):r.push(e[a++]);return r}function Nt(n,e){const t=[],s=n.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&t.push(n[o]);const r=e.map(o=>n[o]);return[t,r]}function st(n,e){const t=e.map(s=>1);return Hw(n,t,e)}function Ft(n,e,t){I(Tm(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Qe(n,e){if(Tm(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function gr(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function rt(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function d2(n,e=null,t=!1){const r={x:C(n,"x","max")},o={reductionIndices:e,keepDims:t};return R.runKernel(ml,r,o)}const In=O({max_:d2});function p2(n,e=null,t=!1){const r={x:C(n,"x","min")},o={axis:e,keepDims:t};return R.runKernel(bl,r,o)}const Eo=O({min_:p2});function f2(n,e){let t=C(n,"base","pow"),s=C(e,"exp","pow");[t,s]=Je(t,s);const r={a:t,b:s};return R.runKernel(ya,r)}const ps=O({pow_:f2});function he(n,e){if((dt(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&dt(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return fr(n,[],[],e)}function m2(n){const t={x:C(n,"x","sqrt","float32")};return R.runKernel(Ea,t)}const $t=O({sqrt_:m2});function g2(n){const e=C(n,"x","square"),t={};return R.runKernel("Square",{x:e},t)}const Pe=O({square_:g2});function y2(n,e=null,t=!1){let s=C(n,"x","sum");s.dtype==="bool"&&(s=ee(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return R.runKernel(Fl,r,o)}const ie=O({sum_:y2});function x2(n,e="euclidean",t=null,s=!1){n=C(n,"x","norm");const r=jw(n,e,t);let o=r.shape;if(s){const a=Ie(t,n.shape);o=st(r.shape,a)}return L(r,o)}function jw(n,e,t=null){if(n.rank===0)return it(n);if(n.rank!==1&&t===null)return jw(L(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ie(it(n),t);if(e===1/0)return In(it(n),t);if(e===-1/0)return Eo(it(n),t);if(e==="euclidean"||e===2)return $t(ie(ps(it(n),he(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return In(ie(it(n),t[0]),t[1]-1);if(e===1/0)return In(ie(it(n),t[1]),t[0]);if(e===-1/0)return Eo(ie(it(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return $t(ie(Pe(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Ma=O({norm_:x2});function b2(n,e=null,t=!1){return Ma(n,"euclidean",e,t)}const Em=O({euclideanNorm_:b2});function w2(n){const t={x:C(n,"x","exp")};return R.runKernel(na,t)}const tn=O({exp_:w2});function v2(n,e=0){const t=C(n,"x","expandDims","string_or_numeric");I(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return R.runKernel(rl,s,r)}const Tt=O({expandDims_:v2});function $2(n){const t={x:C(n,"x","expm1")};return R.runKernel(sa,t)}const Am=O({expm1_:$2});function S2(n,e){const t=C(n,"x","tile","string_or_numeric");I(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return R.runKernel(_a,s,r)}const wn=O({tile_:S2});function I2(n,e,t,s="float32"){e==null&&(e=n);const r=we([n,e],s),o=n<=e?n:e;for(let i=0;i<o;++i)r.set(1,i,i);const a=L(r.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return wn(Tt(a,0),[t[0],1,1]);if(t.length===2)return wn(Tt(Tt(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return wn(Tt(Tt(Tt(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const fd=O({eye_:I2});function N2(n){const t={x:C(n,"x","floor","float32")};return R.runKernel(ra,t)}const Ba=O({floor_:N2});function C2(n,e,t=0,s=0){const r=C(n,"x","gather"),o=C(e,"indices","gather","int32"),a={x:r,indices:o},i={axis:t,batchDims:s};return R.runKernel(al,a,i)}const Va=O({gather_:C2});function k2(n,e){let t=C(n,"a","greater","string_or_numeric"),s=C(e,"b","greater","string_or_numeric");[t,s]=Je(t,s),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(il,r)}const qt=O({greater_:k2});function T2(n,e){let t=C(n,"a","greaterEqual","string_or_numeric"),s=C(e,"b","greaterEqual","string_or_numeric");[t,s]=Je(t,s),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(aa,r)}const Ps=O({greaterEqual_:T2});function E2(n){const t={input:C(n,"input","imag")};return R.runKernel(Ih,t)}const Xl=O({imag_:E2});function A2(n){const t={x:C(n,"x","isFinite")};return R.runKernel(la,t)}const Rm=O({isFinite_:A2});function R2(n){const t={x:C(n,"x","isInf")};return R.runKernel(ua,t)}const Dm=O({isInf_:R2});function D2(n){const t={x:C(n,"x","isNaN")};return R.runKernel(ca,t)}const Om=O({isNaN_:D2});function O2(n,e=.2){const s={x:C(n,"x","leakyRelu")},r={alpha:e};return R.runKernel(ll,s,r)}const Yl=O({leakyRelu_:O2});function _2(n,e){let t=C(n,"a","less","string_or_numeric"),s=C(e,"b","less","string_or_numeric");[t,s]=Je(t,s),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(ul,r)}const Ao=O({less_:_2});function F2(n,e){let t=C(n,"a","lessEqual","string_or_numeric"),s=C(e,"b","lessEqual","string_or_numeric");[t,s]=Je(t,s),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(cl,r)}const yr=O({lessEqual_:F2});function qw(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return R.runKernel(Nh,{},s)}function L2(n,e=5,t=1,s=1,r=.5){const o=C(n,"x","localResponseNormalization");I(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),I(Br(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=o,i=!1;o.rank===3&&(i=!0,a=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const l={x:a},u={depthRadius:e,bias:t,alpha:s,beta:r},c=R.runKernel(fl,l,u);return i?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const _m=O({localResponseNormalization_:L2});function P2(n){const t={x:C(n,"x","log","float32")};return R.runKernel(ha,t)}const dn=O({log_:P2});function z2(n){const t={x:C(n,"x","log1p")};return R.runKernel(da,t)}const Zl=O({log1p_:z2});function M2(n){return I(sr(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=C(e,"x","tf.grad","string_or_numeric"),r=t!=null?C(t,"dy","tf.grad"):null;return R.tidy(()=>{const{value:o,grads:a}=R.gradients(()=>n(s),[s],r);return r!=null&&Ot(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),md(a),a[0]})}}function B2(n){return I(sr(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{I(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=ki(e,"args","tf.grads","string_or_numeric"),r=t!=null?C(t,"dy","tf.grads"):null;return R.tidy(()=>{const{value:o,grads:a}=R.gradients(()=>n(...s),s,r);return r!=null&&Ot(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),md(a),a})}}function V2(n){return I(sr(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{I(e instanceof Ae,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),I(t==null||t instanceof Ae,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=R.gradients(()=>n(e),[e],t);return md(s),{grad:s[0],value:r}}}function W2(n){return I(sr(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{I(Array.isArray(e)&&e.every(r=>r instanceof Ae),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),I(t==null||t instanceof Ae,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=R.gradients(()=>n(...e),e,t);return t!=null&&Ot(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),md(s.grads),s}}function Kw(n,e){I(sr(n),()=>"The f passed in variableGrads(f) must be a function"),I(e==null||Array.isArray(e)&&e.every(u=>u instanceof Ci),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in R.registeredVariables)e.push(R.registeredVariables[u])}const s=t?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),I(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:a,grads:i}=R.gradients(n,e,null,o);I(i.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),I(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((u,c)=>{i[c]!=null&&(l[u.name]=i[c])}),s?.forEach(u=>l[u.name]=null),{value:a,grads:l}}function fs(n){return R.customGrad(n)}function md(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function U2(n){const t={x:C(n,"x","neg")};return R.runKernel(vl,t)}const Ue=O({neg_:U2});function G2(n){const t={x:C(n,"x","softplus")};return R.runKernel(Ta,t)}const uo=O({softplus_:G2});function H2(n){const e=C(n,"x","logSigmoid");return fs(s=>({value:Ue(uo(Ue(s))),gradFunc:a=>_(a,Gn(Ue(s)))}))(e)}const Fm=O({logSigmoid_:H2});function j2(n,e){let t=C(n,"a","sub"),s=C(e,"b","sub");[t,s]=Je(t,s);const r={a:t,b:s};return R.runKernel(Ra,r)}const oe=O({sub_:j2});function q2(n,e=-1){const t=C(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return fs((r,o)=>{const i=In(r,e,!0),l=oe(r,i),u=oe(ee(l,"float32"),dn(ie(tn(l),e,!0)));return o([u]),{value:u,gradFunc:(h,d)=>{const[p]=d,f=!0,m=tn(p);return oe(h,_(ie(h,e,f),m))}}})(t)}const gd=O({logSoftmax_:q2});function K2(n,e=null,t=!1){const s=C(n,"x","logSumExp"),r=Ie(e,s.shape),o=In(s,r,!0),a=oe(s,o),i=tn(a),l=ie(i,r),u=dn(l),c=Y(L(o,u.shape),u);if(t){const h=st(c.shape,r);return L(c,h)}return c}const Jl=O({logSumExp_:K2});function X2(n,e){const t=C(n,"a","logicalAnd","bool"),s=C(e,"b","logicalAnd","bool");xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(hl,r)}const On=O({logicalAnd_:X2});function Y2(n){const t={x:C(n,"x","logicalNot","bool")};return R.runKernel(dl,t)}const Ql=O({logicalNot_:Y2});function Z2(n,e){const t=C(n,"a","logicalOr","bool"),s=C(e,"b","logicalOr","bool");xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(pl,r)}const yd=O({logicalOr_:Z2});function J2(n,e){const t=C(n,"a","logicalXor","bool"),s=C(e,"b","logicalXor","bool");return xe(t.shape,s.shape),On(yd(n,e),Ql(On(n,e)))}const Lm=O({logicalXor_:J2});const Au=2147483648;function Q2(n,e,t="left"){const s=C(n,"sortedSequence","searchSorted"),r=C(e,"values","searchSorted"),o=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],i=L(s,[-1,o]),l=L(r,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(G(l.shape)>=Au)throw new Error(`values tensor size must less than ${Au}`);if(i.shape[1]>=Au)throw new Error(`trailing dim_size must less than ${Au} for int32 output type, was ${i.shape[1]}`);const u={sortedSequence:i,values:l},c={side:t};return R.runKernel(Uh,u,c)}const xd=O({searchSorted_:Q2});function Xw(n,e){return xd(n,e,"left")}function eE(n,e,t,s,r){const o=C(n,"x","maxPool"),a=1;let i=o,l=!1;o.rank===3&&(l=!0,i=L(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),I(_t(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),jt("maxPool",s,r);const u={x:i},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r},h=R.runKernel(gl,u,c);return l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const eu=O({maxPool_:eE});function tE(n,e=[1,1,1],t,s,r,o="NDHWC"){const a=C(n,"x","maxPool3d");let i=a,l=!1;a.rank===4&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),I(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),I(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),jt("maxPool3d",s,r);const u={x:i},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:o},h=R.runKernel(yl,u,c);return l?L(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Pm=O({maxPool3d_:tE});function nE(n,e,t,s,r=!1){const a={x:C(n,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=R.runKernel(Eh,a,i);return{result:l[0],indexes:l[1]}}const Yw=O({maxPoolWithArgmax_:nE});function sE(n,e){let t=C(n,"a","maximum"),s=C(e,"b","maximum");[t,s]=Je(t,s),t.dtype==="bool"&&(t=ee(t,"int32"),s=ee(s,"int32")),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(pa,r)}const gs=O({maximum_:sE});function rE(n,e=null,t=!1){const r={x:C(n,"x","mean")},o={axis:e,keepDims:t};return R.runKernel(xl,r,o)}const Ye=O({mean_:rE});function lt(n,e="float32"){if(mn(n),e==="complex64"){const s=lt(n,"float32"),r=lt(n,"float32");return Es(s,r)}const t=Dt(G(n),e);return R.makeTensor(t,n,e)}function Yt(n,e="float32"){if(mn(n),e==="complex64"){const s=Yt(n,"float32"),r=lt(n,"float32");return Es(s,r)}const t=Jc(G(n),e);return R.makeTensor(t,n,e)}function Zw(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=C(n,"x","meshgrid",n instanceof Ae?n.dtype:"float32");if(e===void 0)return[s];let r=C(e,"y","meshgrid",e instanceof Ae?e.dtype:"float32");const o=G(s.shape),a=G(r.shape);return t==="xy"?(s=L(s,[1,-1]),r=L(r,[-1,1]),[Se(Yt([a,1],s.dtype),s),Se(r,Yt([1,o],r.dtype))]):(s=L(s,[-1,1]),r=L(r,[1,-1]),[Se(s,Yt([1,a],s.dtype)),Se(Yt([o,1],r.dtype),r)])}function oE(n,e){let t=C(n,"a","minimum"),s=C(e,"b","minimum");[t,s]=Je(t,s),t.dtype==="bool"&&(t=ee(t,"int32"),s=ee(s,"int32")),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel(fa,r)}const ir=O({minimum_:oE});function aE(n,e,t){I(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=C(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let i=0;i<s.rank;i++)I(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),I(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:t},a={x:s};return R.runKernel(wl,a,o)}const zm=O({mirrorPad_:aE});function iE(n,e){let t=C(n,"a","mod"),s=C(e,"b","mod");[t,s]=Je(t,s);const r={a:t,b:s};return R.runKernel(ma,r)}const Mm=O({mod_:iE});function lE(n,e=null,t=!1){n=C(n,"x","moments");const s=Ie(e,n.shape),r=Ye(n,s,t);let o=r.shape;t||(o=st(r.shape,s));const a=Pe(oe(ee(n,"float32"),L(r,o))),i=Ye(a,s,t);return{mean:r,variance:i}}const tu=O({moments_:lE});function uE(n,e,t,s){const r=C(e,"data","multiRNNCell"),o=ki(t,"c","multiRNNCell"),a=ki(s,"h","multiRNNCell");let i=r;const l=[];for(let h=0;h<n.length;h++){const d=n[h](i,o[h],a[h]);l.push(d[0]),l.push(d[1]),i=d[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const Jw=O({multiRNNCell_:uE});function cE(n,e,t,s=!1){const r=C(n,"logits","multinomial"),o=r.size,a=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const l={logits:a===1?L(r,[1,-1]):r},u={numSamples:e,seed:t,normalized:s},c=R.runKernel(Ah,l,u);return a===1?L(c,[c.size]):c}const Qw=O({multinomial_:cE});function hE(n,e){let t=C(n,"a","notEqual","string_or_numeric"),s=C(e,"b","notEqual","string_or_numeric");[t,s]=Je(t,s),xe(t.shape,s.shape);const r={a:t,b:s};return R.runKernel($l,r)}const qr=O({notEqual_:hE});function dE(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:C(n,"indices","oneHot","int32")},i={dtype:r,depth:e,onValue:t,offValue:s};return R.runKernel(Il,a,i)}const Ro=O({oneHot_:dE});function pE(n){const t={x:C(n,"x","onesLike")};return R.runKernel(Sl,t)}const pn=O({onesLike_:pE});function fE(n,e){const t=C(n,"v1","outerProduct"),s=C(e,"v2","outerProduct");I(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=L(t,[-1,1]),o=L(s,[1,-1]);return Se(r,o)}const e1=O({outerProduct_:fE});function mE(n,e,t=0){const s=C(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},o={x:s};return R.runKernel(Cl,o,r)}const zs=O({pad_:mE});function gE(n,e,t=0){return I(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),zs(n,[e],t)}const t1=O({pad1d_:gE});function yE(n,e,t=0){return I(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zs(n,e,t)}const n1=O({pad2d_:yE});function xE(n,e,t=0){return I(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zs(n,e,t)}const s1=O({pad3d_:xE});function bE(n,e,t=0){return I(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zs(n,e,t)}const r1=O({pad4d_:bE});function wE(n,e,t){const s=C(n,"x","spaceToBatchND");I(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),I(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),I(s.shape.reduce((a,i,l)=>l>0&&l<=e.length?a&&(i+t[l-1][0]+t[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:t};return R.runKernel(Ll,r,o)}const nu=O({spaceToBatchND_:wE});function vE(n,e,t,s,r,o,a){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const i=C(n,"x","maxPool");let l=i,u=!1;i.rank===3&&(u=!0,l=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(_t(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const c=_n(l.shape,e,o,r,s),h=[c.dilationHeight,c.dilationWidth];let d;s==="same"?d=SE([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,m]=$E([c.inHeight,c.inWidth],h,d),g=p?s:"valid",y=p?l:nu(l,h,f),w=(t==="avg"?()=>jl(y,e,o,g,a):()=>eu(y,e,o,g,a))(),b=p?w:ql(w,h,m);return u?L(b,[b.shape[1],b.shape[2],b.shape[3]]):b}function $E(n,e,t){const s=t.map(c=>c[0]),r=t.map(c=>c[1]),o=n.concat(s,r),a=e.map((c,h)=>(c-o[h]%c)%c),i=r.map((c,h)=>c+a[h]),l=e.map((c,h)=>[s[h],i[h]]),u=e.map((c,h)=>[0,a[h]]);return[l,u]}function SE(n,e){const s=n.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),o=s.map((a,i)=>a-r[i]);return s.map((a,i)=>[r[i],o[i]])}const Bm=O({pool_:vE});function IE(n,e){const t=C(n,"x","prelu"),s=C(e,"alpha","prelu"),r={x:t,alpha:s};return R.runKernel(kl,r)}const su=O({prelu_:IE});function NE(n,e=null,t=!1){let s=C(n,"x","prod");s.dtype==="bool"&&(s=ee(s,"int32"));const r={x:s},o={axis:e,keepDims:t};return R.runKernel(Tl,r,o)}const Vm=O({prod_:NE});function CE(n,e,t,s){const r=n.map((c,h)=>C(c,`tensors${h}`,"raggedGather","int32")),o=C(e,"paramsDenseValues","raggedGather"),a=C(t,"indices","raggedGather","int32"),i={paramsNestedSplits:r,paramsDenseValues:o,indices:a},l={outputRaggedRank:s},u=R.runKernel(_h,i,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const o1=O({raggedGather_:CE});function kE(n,e,t){const s=C(n,"starts","raggedRange"),r=C(e,"limits","raggedRange",s.dtype),o=C(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:o},i=R.runKernel(Fh,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const a1=O({raggedRange_:kE});function TE(n,e,t,s,r){const o=C(n,"shape","raggedTensorToTensor","int32"),a=C(e,"values","raggedTensorToTensor"),i=C(t,"defaultValue","raggedTensorToTensor",a.dtype),l=s.map((h,d)=>C(h,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:o,values:a,defaultValue:i,rowPartitionTensors:l},c={rowPartitionTypes:r};return R.runKernel(Lh,u,c)}const i1=O({raggedTensorToTensor_:TE});function EE(n,e,t){mn(n);const s=G(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<s;o++)r[o]=e();return R.makeTensor(r,n,t)}const l1=O({rand_:EE});var ju={exports:{}},AE=ju.exports,nb;function RE(){return nb||(nb=1,(function(n){(function(e,t,s){function r(l){var u=this,c=i();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function o(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function a(l,u){var c=new r(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&o(h,c),d.state=function(){return o(c,{})}),d}function i(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=a:this.alea=a})(AE,n)})(ju)),ju.exports}var qu={exports:{}},DE=qu.exports,sb;function OE(){return sb||(sb=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xor128=a})(DE,n)})(qu)),qu.exports}var Ku={exports:{}},_E=Ku.exports,rb;function FE(){return rb||(rb=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l.v=i.v,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xorwow=a})(_E,n)})(Ku)),Ku.exports}var Xu={exports:{}},LE=Xu.exports,ob;function PE(){return ob||(ob=1,(function(n){(function(e,t,s){function r(i){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,i)}function o(i,l){return l.x=i.x.slice(),l.i=i.i,l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.x&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xorshift7=a})(LE,n)})(Xu)),Xu.exports}var Yu={exports:{}},zE=Yu.exports,ab;function ME(){return ab||(ab=1,(function(n){(function(e,t,s){function r(i){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,f;return l.w=c=c+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(c^c>>>16)|0};function u(c,h){var d,p,f,m,g,y=[],x=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,x=Math.max(x,h.length)),f=0,m=-32;m<x;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,d=y[m&127]^=p+g,f=d==0?f+1:0);for(f>=128&&(y[(h&&h.length||0)&127]=-1),f=127,m=512;m>0;--m)p=y[f+34&127],d=y[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,y[f]=p^d;c.w=g,c.X=y,c.i=f}u(l,i)}function o(i,l){return l.i=i.i,l.w=i.w,l.X=i.X.slice(),l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.X&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xor4096=a})(zE,n)})(Yu)),Yu.exports}var Zu={exports:{}},BE=Zu.exports,ib;function VE(){return ib||(ib=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,i===Math.floor(i)?(l.a=i/4294967296|0,l.b=i|0):u+=i;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.a=i.a,l.b=i.b,l.c=i.c,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.tychei=a})(BE,n)})(Zu)),Zu.exports}var Ju={exports:{}};const WE={},UE=Object.freeze(Object.defineProperty({__proto__:null,default:WE},Symbol.toStringTag,{value:"Module"})),Wm=aC(UE);var GE=Ju.exports,lb;function HE(){return lb||(lb=1,(function(n){(function(e,t,s){var r=256,o=6,a=52,i="random",l=s.pow(r,o),u=s.pow(2,a),c=u*2,h=r-1,d;function p(b,$,N){var T=[];$=$==!0?{entropy:!0}:$||{};var A=y(g($.entropy?[b,w(t)]:b??x(),3),T),k=new f(T),E=function(){for(var S=k.g(o),D=l,F=0;S<u;)S=(S+F)*r,D*=r,F=k.g(1);for(;S>=c;)S/=2,D/=2,F>>>=1;return(S+F)/D};return E.int32=function(){return k.g(4)|0},E.quick=function(){return k.g(4)/4294967296},E.double=E,y(w(k.S),t),($.pass||N||function(S,D,F,z){return z&&(z.S&&m(z,k),S.state=function(){return m(k,{})}),F?(s[i]=S,D):S})(E,A,"global"in $?$.global:this==s,$.state)}function f(b){var $,N=b.length,T=this,A=0,k=T.i=T.j=0,E=T.S=[];for(N||(b=[N++]);A<r;)E[A]=A++;for(A=0;A<r;A++)E[A]=E[k=h&k+b[A%N]+($=E[A])],E[k]=$;(T.g=function(S){for(var D,F=0,z=T.i,M=T.j,W=T.S;S--;)D=W[z=h&z+1],F=F*r+W[h&(W[z]=W[M=h&M+D])+(W[M]=D)];return T.i=z,T.j=M,F})(r)}function m(b,$){return $.i=b.i,$.j=b.j,$.S=b.S.slice(),$}function g(b,$){var N=[],T=typeof b,A;if($&&T=="object")for(A in b)try{N.push(g(b[A],$-1))}catch{}return N.length?N:T=="string"?b:b+"\0"}function y(b,$){for(var N=b+"",T,A=0;A<N.length;)$[h&A]=h&(T^=$[h&A]*19)+N.charCodeAt(A++);return w($)}function x(){try{var b;return d&&(b=d.randomBytes)?b=b(r):(b=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(b)),w(b)}catch{var $=e.navigator,N=$&&$.plugins;return[+new Date,e,N,e.screen,w(t)]}}function w(b){return String.fromCharCode.apply(0,b)}if(y(s.random(),t),n.exports){n.exports=p;try{d=Wm}catch{}}else s["seed"+i]=p})(typeof self<"u"?self:GE,[],Math)})(Ju)),Ju.exports}var kp,ub;function jE(){if(ub)return kp;ub=1;var n=RE(),e=OE(),t=FE(),s=PE(),r=ME(),o=VE(),a=HE();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=o,kp=a,kp}var Um=jE();const qE=.001,u1=.1;function KE(n,e,t){return t==null&&(t=Gm()),nf(n,e,(s,r)=>Hm(s,r,t))}function Gm(){return R.backend.floatPrecision()===32?qE:u1}function nf(n,e,t){let s=!0;if((dt(n)||dt(e))&&(s=!1),dt(n)&&dt(e)&&(s=!0),s){const a=n.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(n)&&Array.isArray(e)){const a=ds(n),i=ds(e);if(!Ce(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}const r=dt(n)?n:hs(n),o=dt(e)?e:hs(e);if(r.length!==o.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${o.length}.
Actual:   ${r}.
Expected: ${o}.`);for(let a=0;a<o.length;++a){const i=r[a],l=o[a];if(!t(i,l))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${l}.
Actual:   ${r}.
Expected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function XE(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function YE(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return rs(n)||rs(n[0])||rs(e)||rs(e[0])?nf(n,t,(s,r)=>s==r):nf(n,e,(s,r)=>Hm(s,r,0))}function ZE(n,e,t){if(t==null&&(t=Gm()),!Hm(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function Hm(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function JE(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function QE(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function c1(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?c1(t):n[e]=as(t)}return n}function eA(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function tA(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const nA=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:u1,createVideoElement:eA,encodeStrings:c1,expectArrayBuffersEqual:QE,expectArraysClose:KE,expectArraysEqual:YE,expectNumbersClose:ZE,expectPromiseToFail:XE,expectValuesInRange:JE,play:tA,testEpsilon:Gm},Symbol.toStringTag,{value:"Module"}));class jm{constructor(e,t,s,r,o){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=o||Math.random();this.random=Um.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,o,a;do r=2*this.random()-1,o=2*this.random()-1,a=r*r+o*o;while(a>=1||a===0);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*o*i,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class sA{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const o=r||Math.random();this.randu=Um.alea(o.toString()),this.randn=new jm(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,o,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),o=this.randu(),o<t||Math.log(o)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class rA{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Um.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function oA(n,e,t=1,s="float32",r){if(mn(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new sA(e,t,s,r),a=we(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const h1=O({randomGamma_:oA});function aA(n,e=0,t=1,s,r){if(mn(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new jm(e,t,s,!1,r),a=we(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const bd=O({randomNormal_:aA});function iA(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return bd(n,0,1,e,t)}const d1=O({randomStandardNormal_:iA});function lA(n,e=0,t=1,s="float32",r){mn(n);const o=we(n,s),a=new rA(e,t,null,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const xr=O({randomUniform_:lA});function uA(n,e,t,s){return xr(n,e,t,"int32",s)}const p1=O({randomUniformInt_:uA});function Kr(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return R.runKernel(Ph,{},r)}function cA(n){const t={input:C(n,"input","real")};return R.runKernel(zh,t)}const Do=O({real_:cA});function hA(n){const t={x:C(n,"x","reciprocal")};return R.runKernel(xa,t)}const qm=O({reciprocal_:hA});function dA(n){const t={x:C(n,"x","relu")};return R.runKernel(ba,t)}const Jn=O({relu_:dA});function pA(n){const t={x:C(n,"x","relu6")};return R.runKernel(wa,t)}const wd=O({relu6_:pA});function fA(n,e){const s={x:C(n,"x","reverse")},r={dims:e};return R.runKernel(Dl,s,r)}const Nn=O({reverse_:fA});function mA(n){const e=C(n,"x","reverse");return I(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Nn(e,0)}const f1=O({reverse1d_:mA});function gA(n,e){const t=C(n,"x","reverse");return I(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Nn(t,e)}const m1=O({reverse2d_:gA});function yA(n,e){const t=C(n,"x","reverse");return I(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Nn(t,e)}const g1=O({reverse3d_:yA});function xA(n,e){const t=C(n,"x","reverse");return I(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Nn(t,e)}const y1=O({reverse4d_:xA});function bA(n){const t={x:C(n,"x","round")};return R.runKernel(va,t)}const vd=O({round_:bA});function wA(n){const t={x:C(n,"x","rsqrt","float32")};return R.runKernel($a,t)}const $d=O({rsqrt_:wA});function vA(n){const t={x:C(n,"x","selu")};return R.runKernel(Sa,t)}const Sd=O({selu_:vA});function $A(n,e,t,s,r,o=[1,1],a="NHWC"){const i=C(n,"x","separableConv2d"),l=C(e,"depthwiseFilter","separableConv2d"),u=C(t,"pointwiseFilter","separableConv2d");let c=i,h=!1;if(i.rank===3&&(h=!0,c=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");I(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),I(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),I(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),I(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];I(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=Pa(c,l,s,r,a,o),g=As(f,u,1,"valid",a);return h?L(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Id=O({separableConv2d_:$A});async function SA(n,e){const t=C(n,"x","setdiff1d"),s=C(e,"y","setdiff1d");I(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),I(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),I(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),o=await s.data(),a=new Set(o);let i=0;for(let c=0;c<r.length;c++)a.has(r[c])||i++;const l=new ct([i],t.dtype),u=new ct([i],"int32");for(let c=0,h=0;c<r.length;c++)a.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const x1=SA;function IA(n){const t={x:C(n,"x","sign")};return R.runKernel(Ca,t)}const Km=O({sign_:IA});function NA(n){const t={x:C(n,"x","sin","float32")};return R.runKernel(Ia,t)}const Nd=O({sin_:NA});function CA(n){const t={x:C(n,"x","sinh")};return R.runKernel(Na,t)}const Cd=O({sinh_:CA});function kA(n,e,t){const s=C(n,"x","slice1d");return I(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Te(s,[e],[t])}const ru=O({slice1d_:kA});function TA(n,e,t){const s=C(n,"x","slice2d");return I(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Te(s,e,t)}const kd=O({slice2d_:TA});function EA(n,e,t){const s=C(n,"x","slice3d");return I(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Te(s,e,t)}const ou=O({slice3d_:EA});function AA(n,e,t){const s=C(n,"x","slice4d");return I(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Te(s,e,t)}const Oo=O({slice4d_:AA});function RA(n,e=-1){const t=C(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return R.runKernel(zl,s,r)}const au=O({softmax_:RA});function DA(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return R.runKernel(bh,e)}const iu=O({fft_:DA});function OA(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return R.runKernel(Sh,e)}const _o=O({ifft_:OA});function _A(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=L(n,[t,e]);s=_o(r)}else{const r=[t,2*(e-1)],o=L(Do(n),[t,e]),a=L(Xl(n),[t,e]),i=Nn(Te(o,[0,1],[t,e-2]),1),l=_(Nn(Te(a,[0,1],[t,e-2]),1),he(-1)),u=nt([o,i],1),c=nt([a,l],1),h=L(Es(u,c),[r[0],r[1]]);s=_o(h)}if(s=Do(s),n.rank===3&&n.shape[0]!==0){const r=s,o=n.shape[0];s=L(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const Td=O({irfft_:_A});function FA(n,e,t=0){const r={x:C(n,"x","split")},o={numOrSizeSplits:e,axis:t};return R.runKernel(Pl,r,o)}const Zt=O({split_:FA});function LA(n,e){I(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,r=Te(n,f,m),t=e}else if(e!=null&&e>t){const f=n.shape.map(m=>m);f[n.shape.length-1]=e-t,r=nt([n,lt(f)],n.shape.length-1),t=e}else r=n;const o=Ee(r),a=L(Es(r,o),[s,t]),i=iu(a),l=Math.floor(t/2)+1,u=Do(i),c=Xl(i),h=Zt(u,[l,t-l],u.shape.length-1),d=Zt(c,[l,t-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,L(Es(h[0],d[0]),p)}const lu=O({rfft_:LA});function PA(n,e){let t=C(n,"a","squaredDifference"),s=C(e,"b","squaredDifference");[t,s]=Je(t,s),xe(t.shape,s.shape);const r={a:t,b:s},o={};return R.runKernel(Aa,r,o)}const Ed=O({squaredDifference_:PA});function zA(n,e){const t=C(n,"x","squeeze","string_or_numeric");return L(t,Os(t.shape,e).newShape)}const br=O({squeeze_:zA});function MA(n,e=0){const t=ki(n,"tensors","stack","string_or_numeric");I(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&I(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return R.runKernel(Nl,s,r)}const Gt=O({stack_:MA});function BA(n,e=0){const s={x:C(n,"x","step")},r={alpha:e};return R.runKernel(Fa,s,r)}const co=O({step_:BA});function VA(n,e,t,s,r=0,o=0,a=0,i=0,l=0){const c={x:C(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:s,beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};return R.runKernel(Yh,c,h)}const Xm=O({stridedSlice_:VA});function WA(n){const t={x:C(n,"x","tan","float32")};return R.runKernel(Da,t)}const Ym=O({tan_:WA});function Rt(n,e){ro(n);const t=ds(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return fr(n,null,t,e)}function Qs(n,e,t){if(ro(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=ds(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return fr(n,e,s,t)}function Zm(n,e,t){if(ro(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ds(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return fr(n,e,s,t)}function b1(n,e,t){if(ro(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=ds(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return fr(n,e,s,t)}function w1(n,e,t){if(ro(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=ds(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return fr(n,e,s,t)}function v1(n,e,t){if(ro(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=ds(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,fr(n,e,s,t)}function Jm(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(o+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(o+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(o+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(t.shape[a]!==e.shape[a])throw new Error(o+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-r;++a)if(t.shape[a+r]!==n[a+s])throw new Error(o+` updates.shape[${a+r}] (${t.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function Ad(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Jm(t,e,n)}function wr(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=t.length;let a=1;for(let h=r;h<o;++h)a*=t[h];const i=r<1?1:r,l=G(e.shape)/i,u=[...de(t.slice(0,r)),1],c=G(t);return{sliceRank:r,numUpdates:l,sliceSize:a,strides:u,outputSize:c}}const UA=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:wr,validateInput:Ad,validateUpdateShape:Jm},Symbol.toStringTag,{value:"Module"}));function GA(n,e,t){const s=C(n,"tensor","tensorScatterupdate"),r=C(e,"indices","tensorScatterupdate","int32"),o=C(t,"updates","tensorScatterupdate");if(Ad(o,r,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const a={tensor:s,indices:r,updates:o},i={};return R.runKernel(Wh,a,i)}const $1=O({tensorScatterUpdate_:GA});function HA(n,e=1,t=!0){const s=C(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},a={k:e,sorted:t},[i,l]=R.runKernel(ed,o,a);return{values:i,indices:l}}const Qm=O({topk_:HA});function jA(n,e=0,t=1,s,r){if(mn(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new jm(e,t,s,!0,r),a=we(n,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const Rd=O({truncatedNormal_:jA});function qA(n,e=0){const t=C(n,"x","unique","string_or_numeric");I(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[o,a]=R.runKernel(nd,s,r);return{values:o,indices:a}}const eg=O({unique_:qA});function KA(n,e,t){const s=C(n,"x","unsortedSegmentSum"),r=C(e,"segmentIds","unsortedSegmentSum","int32");I(Br(t),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},a={numSegments:t};return R.runKernel(Vl,o,a)}const Dd=O({unsortedSegmentSum_:KA});function XA(n,e=0){const t=C(n,"x","unstack","string_or_numeric");I(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return R.runKernel(Bl,s,r)}const Cn=O({unstack_:XA});function S1(n,e){return xd(n,e,"right")}function tg(n,e=!0,t,s){return R.makeVariable(n,e,t,s)}function Od(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const s=we(n,"int32"),r=we([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const a=s.indexToLoc(t[o]),i=o*n.length;r.values.set(a,i)}return r.toTensor()}async function YA(n){const e=C(n,"condition","whereAsync","bool"),t=await e.data(),s=Od(e.shape,t);return n!==e&&e.dispose(),s}const ng=YA;async function ZA(n,e,t){const s=C(n,"tensor","boolMask"),r=C(e,"mask","boolMask","bool"),o=t??0,a=r.rank,i=s.shape;I(a>0,()=>"mask cannot be scalar"),Ot(i.slice(o,o+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+a;m++)l*=i[m];const u=i.slice(0,o).concat([l],i.slice(o+a)),c=L(s,u),h=L(r,[-1]),d=await ng(h),p=br(d,[1]),f=Va(c,p,o);return n!==s&&s.dispose(),e!==r&&r.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f}const I1=ZA;function JA(n,e,t){const s=C(n,"x","transpose");if(e==null&&(e=s.shape.map((a,i)=>i).reverse()),I(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{I(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?B(()=>{let a=Do(s),i=Xl(s);return a=R.runKernel(Lr,{x:a},o),i=R.runKernel(Lr,{x:i},o),t&&(i=Ue(i)),Es(a,i)}):R.runKernel(Lr,r,o)}const ke=O({transpose_:JA});function QA(n,e,t,s,r=!0){const o=C(n,"v","movingAverage"),a=C(e,"x","movingAverage"),i=C(t,"decay","movingAverage");ww(o,a),I(Ce(o.shape,a.shape),()=>"Shape mismatch in v and x");const l=he(1),u=oe(l,i);let c=_(oe(a,o),u);if(r){I(s!=null,()=>"When using zeroDebias: true, step is required.");const h=C(s,"step","movingAverage");c=ue(c,oe(l,ps(i,h)))}return Y(o,c)}const N1=O({movingAverage_:QA});function eR(n,e,t){mn(t);const s=C(n,"indices","scatterND","int32"),r=C(e,"updates","scatterND");Ad(r,s,t);const o={indices:s,updates:r},a={shape:t};return R.runKernel(Vh,o,a)}const C1=O({scatterND_:eR});function tR(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function nR(n,e,t,s=0){mn(t);const r=C(n,"sparseIndices","sparseToDense","int32"),o=C(e,"sparseValues","sparseToDense","string_or_numeric"),a=C(s,"defaultValue","sparseToDense",o.dtype);tR(r,o,t,a);const i={sparseIndices:r,sparseValues:o,defaultValue:a},l={outputShape:t};return R.runKernel(Kh,i,l)}const k1=O({sparseToDense_:nR});function sR(n,e){const t=C(e,"indices","gatherND","int32"),r={params:C(n,"x","gatherND","string_or_numeric"),indices:t};return R.runKernel($h,r)}const T1=O({gatherND_:sR});function rR(n,e){if(e==null)return n.shape.slice();if(Ce(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function oR(n,e,t,s){const r=C(n,"x","dropout");if(I(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),I(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Ae?r.clone():r;const o=rR(r,t),a=1-e,i=ue(Ba(Y(xr(o,0,1,"float32",s),a)),a);return _(r,i)}const sg=O({dropout_:oR});function rg(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function _d(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let o=0;o<n;++o){const a=2*Math.PI*o/(n+s-1);r[o]=e-t*Math.cos(a)}return Rt(r,"float32")}async function aR(n,e,t=1){const s=C(n,"predictions","inTopK"),r=C(e,"targets","inTopK");I(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),I(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Ot(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];I(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const a=await s.data(),i=await r.data(),[l,u]=[a.length/o,o],c=vt("bool",l);for(let h=0;h<l;h++){const d=h*u,p=a.subarray(d,d+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[h]=0;for(let m=0;m<t;m++)if(f[m].index===i[h]){c[h]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),cn(c,r.shape,"bool")}const E1=aR;function iR(n,e,t,s,r,o="NHWC",a){let i=n;n.rank===3&&(i=L(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=L(e,[1,e.shape[0],e.shape[1],e.shape[2]])),I(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),I(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),I(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=o==="NHWC"?i.shape[3]:i.shape[1],c=o==="NHWC"?l.shape[3]:l.shape[1];I(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),I(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),jt("conv2dDerFilter",r,a);const h={x:i,dy:l},d={strides:s,pad:r,dataFormat:o,dimRoundingMode:a,filterShape:t};return R.runKernel(ah,h,d)}const og=O({conv2DBackpropFilter_:iR});function Fd(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return _(n,co(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Ld(n,e){let t=e;const s=ht(n.shape,e.shape);return s.length>0&&(t=ie(t,s)),L(t,n.shape)}function Pd(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Jn(n);if(e==="elu")return za(n);if(e==="relu6")return wd(n);if(e==="prelu")return su(n,t);if(e==="leakyrelu")return Yl(n,s);if(e==="sigmoid")return Gn(n);throw new Error(`Unknown fused activation ${e}.`)}const zd=(n,e)=>!(n>0)||e==="linear";function lR({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",zd(R.state.gradientDepth,l)===!1){I(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=As(n,e,t,s,r,o,a);return i!=null&&(N=Y(N,i)),Pd(N,l,u,c)}const h=C(n,"x","conv2d","float32"),d=C(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=L(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),I(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),jt("fused conv2d",s,a);const m=r==="NHWC"?p.shape[3]:p.shape[1];I(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),I(_t(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const g=It(p.shape,d.shape,t,o,s,a);let y;i!=null&&(y=C(i,"bias","fused conv2d"),[y]=Je(y,h),r==="NHWC"?xe(g.outShape,y.shape):(I(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),I(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let x;if(u!=null){const N=u.shape;if(I(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)I(N[0]===1||N[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${g.outChannels}).`);else if(N.length===3)try{xe(N,g.outShape)}catch{const A=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(A)}x=C(u,"prelu weights","fused conv2d")}const w=(N,T)=>{I(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[A,k,E,S]=T,D=Fd(N,E,l);I(or(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const F=vm(k.shape,D,A,t,s),z=og(k,D,A.shape,t,s),M=[F,z];if(S!=null){const W=Ld(S,D);M.push(W)}return M},b={x:p,filter:d,bias:y,preluActivationWeights:x},$={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?fs((T,A,k)=>{let E=R.runKernel($i,b,$);return k([A,T,E]),f&&(E=L(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:w}})(p,d):fs((T,A,k,E)=>{let S=R.runKernel($i,b,$);return E([A,T,S,k]),f&&(S=L(S,[S.shape[1],S.shape[2],S.shape[3]])),{value:S,gradFunc:w}})(p,d,y)}const A1=O({fusedConv2d_:lR});function uR(n,e,t,s,r,o=[1,1],a){let i=n;n.rank===3&&(i=L(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:i,dy:l},c={strides:s,pad:r,dimRoundingMode:a,dilations:o,filterShape:t};return R.runKernel(ph,u,c)}const R1=O({depthwiseConv2dNativeBackpropFilter_:uR});function cR(n,e,t,s,r,o=[1,1],a){let i=e,l=!1;e.rank===3&&(l=!0,i=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:i,filter:t},c={strides:s,pad:r,dimRoundingMode:a,dilations:o,inputShape:n},h=R.runKernel(fh,u,c);return l?L(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const D1=O({depthwiseConv2dNativeBackpropInput_:cR});function hR({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(zd(R.state.gradientDepth,l)===!1){let $=Pa(n,e,t,s,r,o,a);return i!=null&&($=Y($,i)),Pd($,l,u,c)}const h=C(n,"x","depthwiseConv2d","float32"),d=C(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=L(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),I(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),I(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),I(_t(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),jt("fused depthwiseConv2d",s,a);const m=It(p.shape,d.shape,t,o,s,a,!0);let g;i!=null&&(g=C(i,"bias","fused conv2d"),[g]=Je(g,h),xe(m.outShape,g.shape));let y;u!=null&&(y=C(u,"prelu weights","fused depthwiseConv2d"));const x=($,N)=>{I(or(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[T,A,k,E]=N,S=Fd($,k,l),D=D1(A.shape,S,T,t,s,o,a),F=R1(A,S,T.shape,t,s,o,a);if(E!=null){const z=Ld(g,S);return[D,F,z]}return[D,F]},w={x:p,filter:d,bias:g,preluActivationWeights:y},b={strides:t,pad:s,dataFormat:r,dilations:o,dimRoundingMode:a,activation:l,leakyreluAlpha:c};return i==null?fs((N,T,A)=>{let k=R.runKernel(Si,w,b);return A([T,N,k]),f&&(k=L(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:x}})(p,d):fs((N,T,A,k)=>{let E=R.runKernel(Si,w,b);return k([T,N,E,A]),f&&(E=L(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(p,d,g)}const dR=O({fusedDepthwiseConv2d_:hR});function pR({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(zd(R.state.gradientDepth,o)===!1){let S=Se(n,e,t,s);return r!=null&&(S=Y(S,r)),Pd(S,o,a,i)}let l=C(n,"a","fused matMul"),u=C(e,"b","fused matMul");[l,u]=Je(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=G(f),y=G(m);I(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${s} must match.`);const w=xe(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),b=t?L(l,[g,c,d]):L(l,[g,d,c]),$=s?L(u,[y,p,h]):L(u,[y,h,p]);let N;r!=null&&(N=C(r,"bias","fused matMul"),[N]=Je(N,l),xe(w,N.shape));let T;a!=null&&(T=C(a,"prelu weights","fused matMul"));const A=(S,D)=>{const[F,z,M,W]=D,j=Fd(L(S,M.shape),M,o);let U,q;if(!t&&!s?(U=Se(j,z,!1,!0),q=Se(F,j,!0,!1)):!t&&s?(U=Se(j,z,!1,!1),q=Se(j,F,!0,!1)):t&&!s?(U=Se(z,j,!1,!0),q=Se(F,j,!1,!1)):(U=Se(z,j,!0,!0),q=Se(j,F,!0,!0)),r!=null){const K=Ld(W,j);return[U,q,K]}else return[U,q]},k={a:b,b:$,bias:N,preluActivationWeights:T},E={transposeA:t,transposeB:s,activation:o,leakyreluAlpha:i};return r==null?fs((D,F,z)=>{const M=R.runKernel(vi,k,E);return z([D,F,M]),{value:L(M,w),gradFunc:A}})(b,$):fs((D,F,z,M)=>{const W=R.runKernel(vi,k,E);return M([D,F,W,z]),{value:L(W,w),gradFunc:A}})(b,$,N)}const sf=O({fusedMatMul_:pR});const O1=Object.freeze(Object.defineProperty({__proto__:null,conv2d:A1,depthwiseConv2d:dR,matMul:sf},Symbol.toStringTag,{value:"Module"}));function fR(n){return _d(n,.54,.46)}const mR=O({hammingWindow_:fR});function gR(n){return _d(n,.5,.5)}const _1=O({hannWindow_:gR});function yR(n,e,t,s=!1,r=0){let o=0;const a=[];for(;o+e<=n.size;)a.push(Te(n,o,e)),o+=t;if(s)for(;o<n.size;){const i=o+e-n.size,l=nt([Te(n,o,e-i),lo([i],r)]);a.push(l),o+=t}return a.length===0?Qs([],[0,e]):L(nt(a),[a.length,e])}const F1=O({frame_:yR});function xR(n,e,t,s,r=_1){s==null&&(s=rg(e));const o=F1(n,e,t),a=_(o,r(e));return lu(a,s)}const bR=O({stft_:xR});function wR(n,e,t,s,r="bilinear",o=0){const a=C(n,"image","cropAndResize"),i=C(e,"boxes","cropAndResize","float32"),l=C(t,"boxInd","cropAndResize","int32"),u=i.shape[0];I(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),I(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),I(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),I(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),I(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),I(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:a,boxes:i,boxInd:l},h={method:r,extrapolationValue:o,cropSize:s};return R.runKernel(ch,c,h)}const vR=O({cropAndResize_:wR});function $R(n){const e=C(n,"image","flipLeftRight","float32");I(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return R.runKernel(vh,t,{})}const SR=O({flipLeftRight_:$R});function IR(n){const e=C(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];I(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),I(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,wn(e,r)}const NR=O({grayscaleToRGB_:IR});function CR(n){const e=C(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];I(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),I(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,o=ee(e,"float32"),a=Rt([.2989,.587,.114]);let i;switch(e.rank){case 2:i=Er("ij,j->i",o,a);break;case 3:i=Er("ijk,k->ij",o,a);break;case 4:i=Er("ijkl,l->ijk",o,a);break;case 5:i=Er("ijklm,m->ijkl",o,a);break;case 6:i=Er("ijklmn,n->ijklm",o,a);break;default:throw new Error("Not a valid tensor rank.")}return i=Tt(i,-1),ee(i,r)}const kR=O({rgbToGrayscale_:CR});function TR(n,e,t=0,s=.5){const r=C(n,"image","rotateWithOffset","float32");I(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},a={radians:e,fillValue:t,center:s};return R.runKernel(sd,o,a)}const ER=O({rotateWithOffset_:TR});function Wa(n,e,t,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const a=n.shape[0];return t=Math.min(t,a),I(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),I(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),I(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),I(e.rank===1,()=>"scores must be a 1D tensor"),I(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),I(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}function AR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=C(n,"boxes","nonMaxSuppression","float32"),a=C(e,"scores","nonMaxSuppression","float32"),i=Wa(o,a,t,s,r);t=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return R.runKernel(Rh,{boxes:o,scores:a},l)}const RR=O({nonMaxSuppression_:AR});function DR(n,e,t){const s=OR(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function OR(n,e,t){return FR(n,e,t||_R)}function _R(n,e){return n>e?1:n<e?-1:0}function FR(n,e,t){let s=0,r=n.length,o=0,a=!1;for(;s<r;){o=s+(r-s>>>1);const i=t(e,n[o]);i>0?s=o+1:(r=o,a=!i)}return a?s:-s-1}function Md(n,e,t,s,r){return ag(n,e,t,s,r,0)}function Bd(n,e,t,s,r,o){return ag(n,e,t,s,r,0,!1,o,!0)}function Vd(n,e,t,s,r,o){return ag(n,e,t,s,r,o,!0)}function ag(n,e,t,s,r,o,a=!1,i=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>r&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(cb);const c=o>0?-.5/o:0,h=[],d=[];for(;h.length<t&&u.length>0;){const g=u.pop(),{score:y,boxIndex:x,suppressBeginIndex:w}=g;if(y<r)break;let b=!1;for(let $=h.length-1;$>=w;--$){const N=LR(n,x,h[$]);if(N>=s){b=!0;break}if(g.score=g.score*PR(s,c,N),g.score<=r)break}g.suppressBeginIndex=h.length,b||(g.score===y?(h.push(x),d.push(g.score)):g.score>r&&DR(u,g,cb))}const p=h.length,f=t-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function LR(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),o=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(i-o)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(o,u),g=Math.max(a,c),y=Math.min(i,h),x=Math.min(l,d),w=Math.max(y-m,0)*Math.max(x-g,0);return w/(p+f-w)}function PR(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function cb(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function zR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const o=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),i=Wa(o,a,t,s,r);t=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const l=await Promise.all([o.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:h}=Md(u,c,t,s,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),Rt(h,"int32")}const MR=zR;function BR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=C(n,"boxes","nonMaxSuppression"),i=C(e,"scores","nonMaxSuppression"),l=Wa(a,i,t,s,r,o);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u={boxes:a,scores:i},c={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},h=R.runKernel(Oh,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const VR=O({nonMaxSuppressionWithScore_:BR});async function WR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const a=C(n,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),l=Wa(a,i,t,s,r,o);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,o=l.softNmsSigma;const u=await Promise.all([a.data(),i.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=Vd(c,h,t,s,r,o);return a!==n&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Rt(d,"int32"),selectedScores:Rt(p)}}const UR=WR;function GR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=C(n,"boxes","nonMaxSuppression"),i=C(e,"scores","nonMaxSuppression"),l=Wa(a,i,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:a,scores:i},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:o},f=R.runKernel(Dh,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const HR=O({nonMaxSuppressionPadded_:GR});async function jR(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const a=C(n,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),l=Wa(a,i,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:m}=Bd(d,p,u,c,h,o);return a!==n&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Rt(f,"int32"),validOutputs:he(m,"int32")}}const qR=jR;function KR(n,e,t=!1,s=!1){const r=C(n,"images","resizeBilinear");I(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),I(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),I(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},l={alignCorners:t,halfPixelCenters:s,size:e},u=R.runKernel(Rl,i,l);return a?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const L1=O({resizeBilinear_:KR});function XR(n,e,t=!1,s=!1){const r=C(n,"images","resizeNearestNeighbor");I(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),I(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),I(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),I(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,a=!1;r.rank===3&&(a=!0,o=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:o},l={alignCorners:t,halfPixelCenters:s,size:e},u=R.runKernel(Al,i,l);return a?L(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const P1=O({resizeNearestNeighbor_:XR});function YR(n,e="binary",t=!1,s=.5){const r=C(n,"image","threshold"),o=.2989,a=.587,i=.114,l=r.shape[0]*r.shape[1];let u=_(Rt([s]),255),c,h,d,p;if(I(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),I(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),I(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),I(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,h,d]=Zt(r,[1,1,1],-1);const g=_(c,o),y=_(h,a),x=_(d,i);p=Y(Y(g,y),x)}else p=n;if(e==="otsu"){const g=mm(ee(vd(p),"int32"),cn([]),256);u=ZR(g,l)}const f=t?yr(p,u):qt(p,u);return ee(_(f,255),"int32")}function ZR(n,e){let t=Rt([-1]),s=Rt([0]),r=Rt([0]),o,a,i,l,u,c;for(let h=0;h<n.size-1;h++){o=Te(n,0,h+1),a=Te(n,h+1),u=ue(ie(o),e),c=ue(ie(a),e);const d=ie(_(o,Kr(0,o.size)));i=ue(d,ie(o));const p=lo(a.shape,o.size),f=Y(Kr(0,a.size),p),m=_(a,f);l=ue(ie(m),ie(a));const g=oe(i,l),y=oe(i,l),x=_(u,c);r=_(_(x,g),y);const w=qt(r,s);s=wt(w,r,s),t=wt(w,Rt([h]),t)}return t}const JR=O({threshold_:YR});function QR(n,e,t="nearest",s="constant",r=0,o){const a=C(n,"image","transform","float32"),i=C(e,"transforms","transform","float32");I(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),I(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:a,transforms:i},u={interpolation:t,fillMode:s,fillValue:r,outputShape:o};return R.runKernel(td,l,u)}const eD=O({transform_:QR});function tD(n,e,t){const s=C(n,"a","bandPart");I(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,a]=s.shape.slice(-2);let i,l;typeof e=="number"?(I(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),I(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),i=C(e<0?o:e,"numLower","bandPart")):(I(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=wt(Ao(e,0),o,ir(e,o))),typeof t=="number"?(I(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),I(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),l=C(t<0?a:t,"numUpper","bandPart")):(I(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=wt(Ao(t,0),a,ir(t,a)));const u=L(Kr(0,o,1,"int32"),[-1,1]),c=Kr(0,a,1,"int32"),h=oe(u,c),d=On(yr(h,i),Ps(h,Ue(l))),p=lt([o,a],s.dtype);return L(Gt(Cn(L(s,[-1,o,a])).map(f=>wt(d,f,p))),r)}const nD=O({bandPart_:tD});function sD(n){let e;if(Array.isArray(n)){e=!1,I(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let o=1;o<n.length;++o)I(n[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${r})`)}else e=!0,n=Zt(n,n.shape[0],0).map(r=>br(r,[0]));I(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(R.tidy(()=>{let o=s[r];if(r>0)for(let a=0;a<r;++a){const i=_(ie(_(t[a],o)),t[a]);o=oe(o,i)}return ue(o,Ma(o,"euclidean"))}));return e?Gt(t,0):t}const rD=O({gramSchmidt_:sD});function oD(n,e=!1){if(I(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return hb(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),s=Cn(L(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],o=[];s.forEach(l=>{const[u,c]=hb(l,e);r.push(u),o.push(c)});const a=L(Gt(r,0),n.shape),i=L(Gt(o,0),n.shape);return[a,i]}}function hb(n,e=!1){return R.tidy(()=>{I(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=fd(t),o=is(n);const a=Qs([[1]],[1,1]);let i=is(a);const l=t>=s?s:t;for(let u=0;u<l;++u){const c=o,h=i,d=r;[i,o,r]=R.tidy(()=>{const p=Te(o,[u,u],[t-u,1]),f=Ma(p),m=Te(o,[u,u],[1,1]),g=wt(qt(m,0),Qs([[-1]]),Qs([[1]])),y=oe(m,_(g,f)),x=ue(p,y);x.shape[0]===1?i=is(a):i=nt([a,Te(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const w=Ue(ue(Se(g,y),f)),b=Te(o,[u,0],[t-u,s]),$=_(w,i),N=ke(i);if(u===0)o=oe(b,Se($,Se(N,b)));else{const k=oe(b,Se($,Se(N,b)));o=nt([Te(o,[0,0],[u,s]),k],0)}const T=ke($),A=Te(r,[0,u],[t,r.shape[1]-u]);if(u===0)r=oe(A,Se(Se(A,i),T));else{const k=oe(A,Se(Se(A,i),T));r=nt([Te(r,[0,0],[t,u]),k],1)}return[i,o,r]}),ye([c,h,d])}return!e&&t>s&&(r=Te(r,[0,0],[t,s]),o=Te(o,[0,0],[s,s])),[r,o]})}const aD=O({qr_:oD});var Wt;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Wt||(Wt={}));function iD(n,e,t=Wt.SUM_BY_NONZERO_WEIGHTS){const s=C(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=C(e,"weights","computeWeightedLoss"));const o=r==null?s:_(s,r);if(t===Wt.NONE)return o;if(t===Wt.SUM)return ie(o);if(t===Wt.MEAN){if(r==null)return Ye(o);{const a=s.size/r.size,i=ue(ie(o),ie(r));return a>1?ue(i,he(a)):i}}if(t===Wt.SUM_BY_NONZERO_WEIGHTS){if(r==null)return ue(ie(o),he(s.size));{const a=_(r,Yt(s.shape)),i=ee(ie(qr(a,he(0))),"float32");return ue(ie(o),i)}}throw Error(`Unknown reduction: ${t}`)}const Ms=O({computeWeightedLoss_:iD});function lD(n,e,t,s=Wt.SUM_BY_NONZERO_WEIGHTS){const r=C(n,"labels","absoluteDifference"),o=C(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=C(t,"weights","absoluteDifference")),Ot(r.shape,o.shape,"Error in absoluteDifference: ");const i=it(oe(r,o));return Ms(i,a,s)}const uD=O({absoluteDifference_:lD});function cD(n,e,t,s,r=Wt.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","cosineDistance"),a=C(e,"predictions","cosineDistance");let i=null;s!=null&&(i=C(s,"weights","cosineDistance")),Ot(o.shape,a.shape,"Error in cosineDistance: ");const l=he(1),u=oe(l,ie(_(o,a),t,!0));return Ms(u,i,r)}const hD=O({cosineDistance_:cD});function dD(n,e,t,s=Wt.SUM_BY_NONZERO_WEIGHTS){let r=C(n,"labels","hingeLoss");const o=C(e,"predictions","hingeLoss");let a=null;t!=null&&(a=C(t,"weights","hingeLoss")),Ot(r.shape,o.shape,"Error in hingeLoss: ");const i=he(1);r=oe(_(he(2),r),i);const l=Jn(oe(i,_(r,o)));return Ms(l,a,s)}const pD=O({hingeLoss_:dD});function fD(n,e,t,s=1,r=Wt.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","huberLoss"),a=C(e,"predictions","huberLoss");let i=null;t!=null&&(i=C(t,"weights","huberLoss")),Ot(o.shape,a.shape,"Error in huberLoss: ");const l=he(s),u=it(oe(a,o)),c=ir(u,l),h=oe(u,c),d=Y(_(he(.5),Pe(c)),_(l,h));return Ms(d,i,r)}const mD=O({huberLoss_:fD});function gD(n,e,t,s=1e-7,r=Wt.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","logLoss"),a=C(e,"predictions","logLoss");let i=null;t!=null&&(i=C(t,"weights","logLoss")),Ot(o.shape,a.shape,"Error in logLoss: ");const l=he(1),u=he(s),c=Ue(_(o,dn(Y(a,u)))),h=_(oe(l,o),dn(Y(oe(l,a),u))),d=oe(c,h);return Ms(d,i,r)}const yD=O({logLoss_:gD});function xD(n,e,t,s=Wt.SUM_BY_NONZERO_WEIGHTS){const r=C(n,"labels","meanSquaredError"),o=C(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=C(t,"weights","meanSquaredError")),Ot(r.shape,o.shape,"Error in meanSquaredError: ");const i=Ed(r,o);return Ms(i,a,s)}const bD=O({meanSquaredError_:xD});function wD(n,e){const t=C(n,"labels","sigmoidCrossEntropyWithLogits"),s=C(e,"logits","sigmoidCrossEntropyWithLogits");Ot(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Jn(s),o=_(s,t),a=Zl(tn(Ue(it(s))));return Y(oe(r,o),a)}function vD(n,e,t,s=0,r=Wt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"multiClassLabels","sigmoidCrossEntropy");const a=C(e,"logits","sigmoidCrossEntropy");let i=null;if(t!=null&&(i=C(t,"weights","sigmoidCrossEntropy")),Ot(o.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const u=he(s),c=he(1),h=he(.5);o=Y(_(o,oe(c,u)),_(h,u))}const l=wD(o,a);return Ms(l,i,r)}const $D=O({sigmoidCrossEntropy_:vD});function SD(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return fs((r,o,a)=>{const l=Jl(o,[t],!0),u=oe(ee(o,"float32"),l);a([r,u]);const c=Ue(_(u,r));return{value:ie(c,[t]),gradFunc:(p,f)=>{const[m,g]=f,y=st(p.shape,[t]);return[_(L(p,y),oe(ee(m,"float32"),tn(g))),_(L(p,y),oe(tn(g),ee(m,"float32")))]}}})(n,e)}function ID(n,e,t,s=0,r=Wt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"onehotLabels","softmaxCrossEntropy");const a=C(e,"logits","softmaxCrossEntropy");let i=null;if(t!=null&&(i=C(t,"weights","softmaxCrossEntropy")),Ot(o.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const u=he(s),c=he(1),h=he(o.shape[1]);o=Y(_(o,oe(c,u)),ue(u,h))}const l=SD(o,a);return Ms(l,i,r)}const ND=O({softmaxCrossEntropy_:ID});function CD(n,e,t,s){const r=C(n,"indices","sparseFillEmptyRows","int32"),o=C(e,"values","sparseFillEmptyRows"),a=C(t,"denseShape","sparseFillEmptyRows","int32"),i=C(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const l={indices:r,values:o,denseShape:a,defaultValue:i},u=R.runKernel(Gh,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const kD=O({sparseFillEmptyRows_:CD});function TD(n,e,t){const s=C(n,"inputIndices","sparseReshape","int32"),r=C(e,"inputShape","sparseReshape","int32"),o=C(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:s,inputShape:r,newShape:o},i=R.runKernel(Hh,a);return{outputIndices:i[0],outputShape:i[1]}}const ED=O({sparseReshape_:TD});function AD(n,e,t){const s=C(n,"data","sparseSegmentMean"),r=C(e,"indices","sparseSegmentMean","int32"),o=C(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return R.runKernel(jh,a)}const RD=O({sparseSegmentMean_:AD});function DD(n,e,t){const s=C(n,"data","sparseSegmentSum"),r=C(e,"indices","sparseSegmentSum","int32"),o=C(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const a={data:s,indices:r,segmentIds:o};return R.runKernel(qh,a)}const OD=O({sparseSegmentSum_:DD});function _D(n,e,t,s,r,o,a,i){const l=C(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=C(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:s,leftPad:r,rightPad:o,padWidth:a,preserveShortSequences:i},h={data:l,dataSplits:u},d=R.runKernel(Zh,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}const FD=O({stringNGrams_:_D});function LD(n,e,t=!0){const s=C(n,"input","stringSplit","string"),r=C(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},a={input:s,delimiter:r},i=R.runKernel(Jh,a,o);return{indices:i[0],values:i[1],shape:i[2]}}const PD=O({stringSplit_:LD});function zD(n,e){const t=C(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return R.runKernel(Qh,r,s)}const MD=O({stringToHashBucketFast_:zD});function BD(n,e,t,s=!0){const r=C(n,"input","staticRegexReplace","string"),o={pattern:e,rewrite:t,replaceGlobal:s};return R.runKernel(Ml,{x:r},o)}const VD=O({staticRegexReplace_:BD});const z1={fft:iu,ifft:_o,rfft:lu,irfft:Td},M1={hammingWindow:mR,hannWindow:_1,frame:F1,stft:bR},Rn={flipLeftRight:SR,grayscaleToRGB:NR,resizeNearestNeighbor:P1,resizeBilinear:L1,rgbToGrayscale:kR,rotateWithOffset:ER,cropAndResize:vR,nonMaxSuppression:RR,nonMaxSuppressionAsync:MR,nonMaxSuppressionWithScore:VR,nonMaxSuppressionWithScoreAsync:UR,nonMaxSuppressionPadded:HR,nonMaxSuppressionPaddedAsync:qR,threshold:JR,transform:eD},ig={bandPart:nD,gramSchmidt:rD,qr:aD},B1={absoluteDifference:uD,computeWeightedLoss:Ms,cosineDistance:hD,hingeLoss:pD,huberLoss:mD,logLoss:yD,meanSquaredError:bD,sigmoidCrossEntropy:$D,softmaxCrossEntropy:ND},V1={sparseFillEmptyRows:kD,sparseReshape:ED,sparseSegmentMean:RD,sparseSegmentSum:OD},W1={stringNGrams:FD,stringSplit:PD,stringToHashBucketFast:MD,staticRegexReplace:VD};const WD=new Map,rf=new Map;class ho{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class bn{constructor(){this.classNameMap={}}static getMap(){return bn.instance==null&&(bn.instance=new bn),bn.instance}static register(e){bn.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Z(n,e,t){I(n.className!=null,()=>"Class being registered does not have the static className property defined."),I(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),I(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return bn.register(n),WD.set(r,n),rf.set(n,r),n}function UD(n){return rf.has(n)?rf.get(n):n.className}const GD=Object.freeze(Object.defineProperty({__proto__:null,Serializable:ho,SerializationMap:bn,getRegisteredName:UD,registerClass:Z},Symbol.toStringTag,{value:"Module"}));class Bs extends ho{minimize(e,t=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const a=s.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return ye(o),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Kw(e,t)}dispose(){this.iterations_!=null&&ye(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:he(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Bs,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class lg extends Bs{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=R.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=R.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:B(()=>Ee(o).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:B(()=>Ee(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;B(()=>{const c=Y(_(l,this.rho),_(Pe(i),1-this.rho)),h=_(ue($t(Y(u,this.epsilon)),$t(Y(l,this.epsilon))),i),d=Y(_(u,this.rho),_(Pe(h),1-this.rho));l.assign(c),u.assign(d);const p=Y(_(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ye(this.accumulatedGrads.map(e=>e.variable)),ye(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class ug extends Bs{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=R.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:B(()=>lo(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const i=this.accumulatedGrads[r].variable;B(()=>{const l=Y(i,Pe(a));i.assign(l);const u=Y(_(ue(a,$t(Y(l,R.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ye(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class cg extends Bs{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=he(t).variable(),this.accBeta2=he(s).variable()}),r==null&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);B(()=>{const s=oe(1,this.accBeta1),r=oe(1,this.accBeta2);t.forEach((o,a)=>{const i=R.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:B(()=>Ee(i).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:B(()=>Ee(i).variable(l))});const u=Array.isArray(e)?e[a].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,d=Y(_(c,this.beta1),_(u,1-this.beta1)),p=Y(_(h,this.beta2),_(Pe(u),1-this.beta2)),f=ue(d,s),m=ue(p,r);c.assign(d),h.assign(p);const g=Y(_(ue(f,Y($t(m),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(_(this.accBeta1,this.beta1)),this.accBeta2.assign(_(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ye(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&ye(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),B(()=>{this.accBeta1.assign(ps(this.beta1,this.iterations_+1)),this.accBeta2.assign(ps(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class hg extends Bs{static get className(){return"Adamax"}constructor(e,t,s,r=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=he(0).variable(),this.accBeta1=he(t).variable()}),r==null&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);B(()=>{const s=oe(1,this.accBeta1),r=ue(-this.learningRate,Y(_(this.iteration,this.decay),1));t.forEach((o,a)=>{const i=R.registeredVariables[o],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Ee(i).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Ee(i).variable(l)});const u=Array.isArray(e)?e[a].tensor:e[o];if(u==null)return;const c=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,d=Y(_(c,this.beta1),_(u,1-this.beta1)),p=_(h,this.beta2),f=it(u),m=gs(p,f);c.assign(d),h.assign(m);const g=Y(_(ue(r,s),ue(d,Y(m,this.epsilon))),i);i.assign(g)}),this.iteration.assign(Y(this.iteration,1)),this.accBeta1.assign(_(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ye(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&ye(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Wd extends Bs{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=R.registeredVariables[s];B(()=>{const i=Y(_(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=pt(he(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class dg extends Wd{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=he(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=R.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:B(()=>Ee(o).variable(!1))});const a=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[s];i!=null&&B(()=>{let l;const u=Y(_(this.m,a),i);this.useNesterov?l=Y(_(this.c,Y(i,_(u,this.m))),o):l=Y(_(this.c,u),o),a.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ye(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class pg extends Bs{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=R.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=R.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:B(()=>Ee(o).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:B(()=>Ee(o).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:B(()=>Ee(o).variable(a))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;B(()=>{const c=Y(_(l,this.decay),_(Pe(i),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,d=Y(_(h,this.decay),_(i,1-this.decay)),p=ue(_(i,this.learningRate),$t(oe(c,Y(Pe(d),this.epsilon)))),f=Y(_(u,this.momentum),p);l.assign(c),h.assign(d),u.assign(f);const m=oe(o,f);o.assign(m)}else{const h=Y(_(l,this.decay),_(Pe(i),1-this.decay)),d=Y(_(u,this.momentum),ue(_(i,this.learningRate),$t(Y(h,this.epsilon))));l.assign(h),u.assign(d);const p=oe(o,d);o.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ye(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ye(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&ye(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const HD=[lg,ug,cg,hg,dg,pg,Wd];function jD(){for(const n of HD)Z(n)}const qD="model",KD=".json",XD=".weights.bin";function db(n){return new Promise(e=>setTimeout(e)).then(n)}class Xr{constructor(e){if(!V().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Xr.URL_SCHEME)&&(e=e.slice(Xr.URL_SCHEME.length)),(e==null||e.length===0)&&(e=qD),this.modelJsonFileName=e+KD,this.weightDataFileName=e+XD}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Zn.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=Tw(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=a,await db(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await db(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Gl(e)}}}}Xr.URL_SCHEME="downloads://";class YD{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),a=o.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const l=em(o,u=>this.loadWeights(u));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(o).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((s,r)=>{const o=new FileReader;o.onload=a=>{const i=a.target.result;s(i)},o.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(o=>tb(o.name)),r={};for(const o of e)o.paths.forEach(a=>{const i=tb(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),s.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const ZD=n=>V().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xr.URL_SCHEME)?JD(n.slice(Xr.URL_SCHEME.length)):null;Xe.registerSaveRouter(ZD);function JD(n="model"){return new Xr(n)}function QD(n){return new YD(n)}function pb(n,e,t,s){a(n),t=t??0,s=s??1,i(t,s);let r=0;const o=l=>(l.then(u=>{const c=t+ ++r/n.length*(s-t);return e(c),u}),l);function a(l){I(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function i(l,u){I(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),I(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),I(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(n.map(o))}async function U1(n,e){e==null&&(e={});const t=e.fetchFunc==null?V().platform.fetch:e.fetchFunc,s=n.map(h=>t(h,e.requestInit,{isBinary:!0})),i=(e.onProgress==null?await Promise.all(s):await pb(s,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(i):await pb(i,e.onProgress,.5,1)}function eO(n,e){var t;const s=e.fetchFunc==null?V().platform.fetch:e.fetchFunc;let r=0,o;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var i;r<n.length;){o||(o=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await o.read();if(l){r++,o=void 0,(i=e.onProgress)===null||i===void 0||i.call(e,r/n.length);continue}a.enqueue(u);return}a.close()}})}async function G1(n,e="",t,s){return H1(a=>U1(a,{requestInit:s}))(n,e,t)}function H1(n){return async(e,t="",s)=>{const r=e.map(()=>!1),o={},a=s!=null?s.map(()=>!1):[],i=[];if(e.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,x=Vr[y]*G(g.shape),w=()=>{r[f]=!0,o[f]==null&&(o[f]=[]),o[f].push({manifestEntry:g,groupOffset:m,sizeBytes:x})};s!=null?s.forEach((b,$)=>{b===g.name&&(w(),a[$]=!0)}):w(),i.push(g.name),m+=x})}),!a.every(p=>p)){const p=s.filter((f,m)=>!a[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const l=r.reduce((p,f,m)=>(f&&p.push(m),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(f=>{const m=t+(t.endsWith("/")?"":"/")+f;u.push(m)})});const c=await n(u),h={};let d=0;return l.forEach(p=>{const f=e[p].paths.length,m=new Zn(c.slice(d,d+f));o[p].forEach(y=>{const x=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),w=Zf(x,[y.manifestEntry]);for(const b in w)h[b]=w[b]}),d+=f}),h}}const tO="application/octet-stream",nO="application/json";class fg{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(I(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=V().platform.fetch,I(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&I(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Tw(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:nO}),"model.json"),e.weightData!=null){const a=Zn.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:tO}),"model.weights.bin")}const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:Gl(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return em(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=kc(e.weightsManifest),r=()=>eO(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=sO(t),o=this.weightPathPrefix||s,a=[],i=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(u)):a.push(o+u+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e),s=kc(e),r=await U1(t,this.loadOptions);return[s,r]}}fg.URL_SCHEME_REGEX=/^https?:\/\//;function sO(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function of(n){return n.match(fg.URL_SCHEME_REGEX)!=null}const j1=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>of(s)):t=of(n),t)return mg(n,e)}return null};Xe.registerSaveRouter(j1);Xe.registerLoadRouter(j1);function mg(n,e){return new fg(n,e)}function q1(n,e){return mg(n,e)}class Tp{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class K1{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class rO{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function oO(n,e,t,s){const r=arguments;return new rO(Ec(...r))}function Ec(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Tp(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Tp({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Tp({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function aO(n){return new K1(n)}function iO(n){return new K1(n)}const gg=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Zn,browserFiles:QD,browserHTTPRequest:q1,concatenateArrayBuffers:kw,copyModel:Bk,decodeWeights:Zf,decodeWeightsStream:Cw,encodeWeights:Zp,fromMemory:oO,fromMemorySync:Ec,getLoadHandlers:Aw,getModelArtifactsForJSON:em,getModelArtifactsForJSONSync:Qf,getModelArtifactsInfoForJSON:Gl,getSaveHandlers:Ew,getWeightSpecs:kc,http:mg,isHTTPScheme:of,listModels:zk,loadWeights:G1,moveModel:Vk,registerLoadRouter:Ck,registerSaveRouter:Nk,removeModel:Mk,weightsLoaderFactory:H1,withSaveHandler:aO,withSaveHandlerSync:iO},Symbol.toStringTag,{value:"Module"}));function lO(n,e,t){const s=C(n,"labels","confusionMatrix"),r=C(e,"predictions","confusionMatrix");I(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),I(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),I(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),I(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),I(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const o=Ro(ee(s,"int32"),t),a=Ro(ee(r,"int32"),t),i=ke(o),l=Se(i,a);return ee(l,"int32")}const uO=O({confusionMatrix_:lO});const cO=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:uO},Symbol.toStringTag,{value:"Module"}));let Ir,fb=!1;function X1(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,o=!1,a=!1,i=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Ni(Nc,R.backendName)!=null){const f={pixels:n},m={numChannels:e};return R.runKernel(Nc,f,m)}const[u,c]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(a)h=n.getContext("2d").getImageData(0,0,u,c).data;else if(s||t)h=n.data;else if(o||r||i){if(Ir==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Ir=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ir=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ir.canvas.width=u,Ir.canvas.height=c,Ir.drawImage(n,0,0,u,c),h=Ir.getImageData(0,0,u,c).data}let d;if(e===4)d=new Int32Array(h);else{const f=u*c;d=new Int32Array(f*e);for(let m=0;m<f;m++)for(let g=0;g<e;++g)d[m*e+g]=h[m*4+g]}return Zm(d,[c,u,e],"int32")}function hO(n){return n!=null&&n.data instanceof Uint8Array}function dO(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function pO(n){return n!=null&&n.width!==0&&n.height!==0}function fO(n){return dO()&&!(n instanceof ImageBitmap)&&pO(n)&&!hO(n)}async function mO(n,e=3){let t=null;if(V().getBool("WRAP_TO_IMAGEBITMAP")&&fO(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return X1(t,e)}function Y1(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function gO(n){const e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function yO(n,e){let t=C(n,"img","toPixels");if(!(n instanceof Ae)){const u=t;t=ee(u,"int32"),u.dispose()}Y1(t);const[s,r]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2],a=await t.data(),i=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let u=0;u<s*r;++u){const c=[0,0,0,255];for(let d=0;d<o;d++){const p=a[u*o+d];if(t.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(t.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);o===1?(c[0]=p*i,c[1]=p*i,c[2]=p*i):c[d]=p*i}const h=u*4;l[h+0]=Math.round(c[0]),l[h+1]=Math.round(c[1]),l[h+2]=Math.round(c[2]),l[h+3]=Math.round(c[3])}if(e!=null){fb||Ni(gh,R.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),fb=!0),e.width=r,e.height=s;const u=e.getContext("2d"),c=new ImageData(l,r,s);u.putImageData(c,0,0)}return t!==n&&t.dispose(),l}function xO(n,e,t){let s=C(n,"img","draw");if(!(n instanceof Ae)){const a=s;s=ee(a,"int32"),a.dispose()}Y1(s),gO(t?.imageOptions);const r={image:s},o={canvas:e,options:t};R.runKernel(gh,r,o)}const Z1=O({fromPixels_:X1}),bO=Object.freeze(Object.defineProperty({__proto__:null,draw:xO,fromPixels:Z1,fromPixelsAsync:mO,toPixels:yO},Symbol.toStringTag,{value:"Module"}));function Ud(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(G(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,o=r[r.length-1];let a=1;for(let h=0;h<r.length-1;++h)a*=r[h];const i=n.shape,l=r.slice();l.pop();let u=1;for(let h=o;h<t;++h)u*=i[h],l.push(i[h]);const c=[...de(n.shape).map(h=>h/u),1].slice(0,o);return[l,a,u,c]}const wO=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:Ud},Symbol.toStringTag,{value:"Module"}));const af=-2,vO=-1;function yg(n,e,t){const s=n.shape.length;I(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),I(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)I(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function $O(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function xg(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function J1(n,e,t,s){const r=[...n];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<t;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Q1(n,e,t){return t<=n?t:t-(e-1)}function ev(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function SO(n,e,t,s,r,o,a,i,l){const u=n.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&t>0){const p=e[0],f=t+1;c=tv(a,p,f,s,n),h=nv(i,p,f,r,n),d=J1(o,p,f,n)}else for(let p=0;p<u;p++)c[p]=rv(a,s,o,n,p,l),h[p]=ov(i,r,o,n,p,l),d[p]=sv(o,p,l);return{begin:c,end:h,strides:d}}function tv(n,e,t,s,r){const o=[...r],a=ev(t,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{const l=Q1(e,t,i);let u=s[l];n&1<<l&&(u=0),o[i]=u}return o}function nv(n,e,t,s,r){const o=[...r],a=ev(t,e);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const l=Q1(e,t,i);let u=s[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[i]=u}for(let i=0;i<o.length;i++){const l=r[i];o[i]<0&&(o[i]+=l),o[i]=nr(0,o[i],r[i])}return o}function sv(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function rv(n,e,t,s,r,o){let a=e[r];const i=t[r]||1;(n&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=nr(0,a,l-1),a}function ov(n,e,t,s,r,o){let a=e[r];const i=t[r]||1;(n&1<<r||o&1<<r||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),i>0?a=nr(0,a,l):a=nr(-1,a,l-1),a}function bg(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function wg(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function Gd(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{I(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(r).fill(-1):typeof t=="number"?o=[t,...new Array(r-1).fill(-1)]:t.length<r?o=t.concat(new Array(r-t.length).fill(-1)):o=t,o=o.map((a,i)=>a>=0?a:(I(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),n.shape[i]-s[i])),[s,o]}function vg(n,e,t,s,r,o,a,i,l){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:r,endMask:o,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:l};for(let w=0;w<h.dims;w++)c&&(1<<w&i)!==0&&h.numAddAxisAfterEllipsis++,1<<w&a&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};IO(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let w=0;w<n.length;++w){if(d.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);const b=!!(d.shrinkAxisMask&1<<w),$=n[w];if($===-1){g.push(b?1:-1);continue}const N=[d.beginMask&1<<w,d.endMask&1<<w],T=[d.strides[w]>0?0:-1,d.strides[w]>0?$:$-1];if(b&&d.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[w]===1;const A=!!(d.beginMask&1<<w&&d.endMask&1<<w);if(d.beginValid&&d.endValid){if(b){const D=d.begin[w]<0?$+d.begin[w]:d.begin[w];if(d.begin[w]=D,d.end[w]=d.begin[w]+1,D<0||D>=$)throw Error(`slice index ${d.begin[w]} of dimension ${w} out of bounds.`)}else d.begin[w]=mb(d.begin[w],0,d.strides[w],$,N,T),d.end[w]=mb(d.end[w],1,d.strides[w],$,N,T);const S=d.strides[w]===1&&d.begin[w]===0&&d.end[w]===$;p=p&&S,f=f&&(w===0&&d.strides[w]===1||S)}else p=p&&d.strides[w]===1&&A,f=f&&(w===0&&d.strides[w]===1||A);let k,E=!1;if(d.beginValid&&d.endValid?(k=d.end[w]-d.begin[w],E=!0):b?(k=1,E=!0):A&&$>=0&&(d.strides[w]<0?k=-$:k=$,E=!0),E){let S;k===0||k<0!=d.strides[w]<0?S=0:S=Math.trunc(k/d.strides[w])+(k%d.strides[w]!==0?1:0),g.push(S)}else g.push(-1)}for(let w=0;w<d.finalShapeGatherIndices.length;++w){const b=d.finalShapeGatherIndices[w];b>=0?y.push(g[b]):b===af&&y.push(1)}return{finalShapeSparse:y.filter((w,b)=>d.finalShapeGatherIndices[b]!==af),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function IO(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(af),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(vO),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function mb(n,e,t,s,r,o){if(r[e])return t>0?o[e]:o[e+1&1];{const a=n<0?s+n:n;return a<o[0]?o[0]:a>o[1]?o[1]:a}}const av=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:yg,computeFlatOffset:wg,computeOutShape:xg,getNormalizedAxes:SO,isSliceContinous:bg,maskToAxes:$O,parseSliceParams:Gd,sliceInfo:vg,startForAxis:rv,startIndicesWithElidedDims:tv,stopForAxis:ov,stopIndicesWithElidedDims:nv,stridesForAxis:sv,stridesWithElidedDims:J1},Symbol.toStringTag,{value:"Module"}));const iv="4.22.0";class lv{static sgd(e){return new Wd(e)}static momentum(e,t,s=!1){return new dg(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,o=!1){return new pg(e,t,s,r,o)}static adam(e=.001,t=.9,s=.999,r=null){return new cg(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new lg(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,o=0){return new hg(e,t,s,r,o)}static adagrad(e,t=.1){return new ug(e,t)}}const kr=lv;const NO=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function $g(){return new Promise(n=>NO(()=>n()))}function Sg(n,e){const t=n[0].length;n.forEach((r,o)=>{I(r.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),I(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,o)=>{for(let a=0;a<t;a++)I(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function ls(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var Wn;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Wn||(Wn={}));function uv(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const o=t[r],a=s[s.length-t.length+r],i=s[a];if(o>=0)if(i>=0){if(i!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${o} but shape[${r+n}] = ${i}`)}else s[a]=o}return s}function cv(n){const e={FIRST_DIM_SIZE:Wn.FIRST_DIM_SIZE,VALUE_ROWIDS:Wn.VALUE_ROWIDS,ROW_LENGTHS:Wn.ROW_LENGTHS,ROW_SPLITS:Wn.ROW_SPLITS,ROW_LIMITS:Wn.ROW_LIMITS,ROW_STARTS:Wn.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function hv(n){return n.length===0?0:n[0]===Wn.FIRST_DIM_SIZE?n.length-1:n.length}function dv(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const o=n[r],a=e[r+1];if(o>=0&&a>=0&&o!==1&&o!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${o} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}const Ig=30;function Hd(n){return n<=Ig?n:$c(n,Math.floor(Math.sqrt(n)))}function Ng(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}function uu(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const o=e.length;for(let a=0;a<o;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(o+1))}return r}function cu(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?o.push(a):r.push(a);s.push(...r),s.push(0),s.push(...o)}return s}function hu(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?s?r.push(e[o-1]*n[o]):r.push(n[o]/e[o-1]):r.push(n[o]);return r}function Cg(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function kg(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}const jd=1.7580993408473768,qd=1.0507009873554805;const Tg=.3275911,Eg=.254829592,Ag=-.284496736,Rg=1.421413741,Dg=-1.453152027,Og=1.061405429;function Rs(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function pv(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function fv(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function mv(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function _g(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function gv(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function yv(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const o=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:t,imag:s}}function xv(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}const Ep="->",CO=/->/g,gb=",",yb="...";function Fg(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(CO,"").length)/Ep.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Ep}").`);const[s,r]=n.split(Ep);I(s.indexOf(yb)===-1,()=>`The ellipsis notation ("${yb}") is not supported yet.`);const o=s.split(gb),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<r.length;++d){const p=r[d];if(!o.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);i.indexOf(p)===-1&&i.push(p)}for(let d=0;d<s.length;++d){const p=s[d];i.indexOf(p)===-1&&p!==gb&&i.push(p)}const l=new Array(o.length);for(let d=0;d<a;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<o[d].length;++p)l[d].push(i.indexOf(o[d][p]))}const u=i.length,c=r.length,h=[];for(let d=c;d<u;++d)h.push(d);return{allDims:i,summedDims:h,idDims:l}}function Lg(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Pg(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const o=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=o[a]:I(s[e[r][a]]===o[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(o)}, but got dimension ${o[a]}`)}}function zg(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const o=[];for(let a=0;a<t.length;++a){const i=t[a],l=kO(e,i);for(const u of l)o.indexOf(u)===-1&&(s[a].push(u),o.push(u))}return{path:t,steps:s}}function Mg(n){return n.every((e,t)=>e===t)}function kO(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Bg(n,e,t=0){let s=[];if(typeof e=="number")I(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);I(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const a=e.reduce((i,l)=>l>0?i+l:i);e[o]=n.shape[t]-a}I(n.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function bv(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function wv(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function vv(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function $v(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Sv(n,e){return`size ${n} must be non-negative, not ${e}`}function Iv(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Nv(n,e){const t=G(n),s=G(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function Cv(n,e){const t=G(n),s=G(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function lf(){return"segment ids must be >= 0"}function kv(){return"segment ids are not increasing"}function Tv(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Ev(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function Av(n,e){let t=!1,s;for(n<=Ig?(s=n,t=!0):s=$c(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=$c(n,s+1);return s}function Rv(n,e,t){const s=[],r=n.length;for(let o=0;o<r;o++)o!==e?s.push(n[o]):s.push(t);return s}function Vg(n,e,t,s){const r=e.shape.length,o=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const a=n.shape[t],i=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)i.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)i.push(n.shape[h]),u*=n.shape[h];for(let h=s;h<r;h++)i.push(e.shape[h]);for(let h=t+1;h<o;h++)i.push(n.shape[h]),c*=n.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}const TO=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Vg,computeOutShape:Rv,segOpComputeOptimalWindowSize:Av},Symbol.toStringTag,{value:"Module"}));function Ds(n){try{return n.map(e=>ks(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Dv(n){return n.map(e=>as(e))}const Ov=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Eg,ERF_A2:Ag,ERF_A3:Rg,ERF_A4:Dg,ERF_A5:Og,ERF_P:Tg,PARALLELIZE_THRESHOLD:Ig,get RowPartitionType(){return Wn},SELU_SCALE:qd,SELU_SCALEALPHA:jd,applyActivation:Pd,assertAndGetBroadcastShape:xe,assertAxesAreInnerMostDims:Ft,assertParamsConsistent:Sg,assignToTypedArray:gv,axesAreInnerMostDims:Tm,calculateShapes:wr,checkEinsumDimSizes:Pg,checkPadOnDimRoundingMode:jt,combineLocations:Hw,combineRaggedTensorToTensorShapes:uv,complexWithEvenIndex:fv,complexWithOddIndex:mv,computeConv2DInfo:It,computeConv3DInfo:mr,computeDefaultPad:cm,computeDilation2DInfo:Hl,computeOptimalWindowSize:Hd,computeOutAndReduceShapes:Nt,computeOutShape:ls,computePool2DInfo:_n,computePool3DInfo:Fs,convertConv2DDataFormat:Ls,decodeEinsumEquation:Fg,eitherStridesOrDilationsAreOne:_t,expandShapeToKeepDim:st,exponent:xv,exponents:yv,fromStringArrayToUint8:Dv,fromUint8ToStringArray:Ds,getAxesPermutation:Qe,getBroadcastDims:jr,getComplexWithIndex:_g,getEinsumComputePath:zg,getEinsumPermutation:Lg,getFusedBiasGradient:Ld,getFusedDyActivation:Fd,getImageCenter:Ng,getInnerMostAxes:rt,getPermuted:cu,getRaggedRank:hv,getReductionAxes:ht,getReshaped:uu,getReshapedPermuted:hu,getRowPartitionTypesHelper:cv,getSliceBeginCoords:Cg,getSliceSize:kg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:bv,getSparseFillEmptyRowsNegativeIndexErrorMessage:wv,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:vv,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Iv,getSparseReshapeInputOutputMismatchErrorMessage:Cv,getSparseReshapeInputOutputMultipleErrorMessage:Nv,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:$v,getSparseReshapeNegativeOutputDimErrorMessage:Sv,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Ev,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:lf,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:kv,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Tv,getUndoAxesPermutation:gr,isIdentityPermutation:Mg,log:CC,mergeRealAndImagArrays:Rs,prepareAndValidate:Ud,prepareSplitSize:Bg,segment_util:TO,shouldFuse:zd,slice_util:av,splitRealAndImagArrays:pv,stridesOrDilationsArePositive:Hr,tupleValuesAreOne:or,upcastType:Jt,validateDefaultValueShape:dv,validateInput:Ad,validateUpdateShape:Jm,warn:xn},Symbol.toStringTag,{value:"Module"}));const EO=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Md,nonMaxSuppressionV4Impl:Bd,nonMaxSuppressionV5Impl:Vd,whereImpl:Od},Symbol.toStringTag,{value:"Module"}));jD();const _v={kernelName:Bi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(n,co(ee(t,"float32"),-1))}}};const AO={kernelName:Vo,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Pe(ee(t,"float32")),r=$t(oe(he(1),s));return Ue(ue(n,r))}}}};const RO={kernelName:Wo,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=$t(oe(Pe(ee(t,"float32")),1));return ue(n,s)}}}};const DO={kernelName:io,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(t.shape,s.shape);return{a:()=>{let i=n;const l=ht(t.shape,r);return l.length>0&&(i=ie(i,l)),L(i,t.shape)},b:()=>{let i=n;const l=ht(s.shape,r);return l.length>0&&(i=ie(i,l)),L(i,s.shape)}}}};const OO={kernelName:Vi,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};const _O={kernelName:Wi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ee(t)}}};const FO={kernelName:Ui,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ee(t)}}};const LO={kernelName:Uo,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,$t(oe(he(1),Pe(ee(t,"float32")))))}}};const PO={kernelName:Go,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=$t(Y(he(1),Pe(ee(t,"float32"))));return ue(n,s)}}}};const zO={kernelName:qo,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(t.shape,s.shape);return{a:()=>{const i=Y(Pe(t),Pe(s));let l=_(n,ue(s,i));const u=ht(t.shape,r);return u.length>0&&(l=ie(l,u)),L(l,t.shape)},b:()=>{const i=Y(Pe(t),Pe(s));let l=Ue(_(n,ue(t,i)));const u=ht(s.shape,r);return u.length>0&&(l=ie(l,u)),L(l,s.shape)}}}};const MO={kernelName:Ho,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,Y(Pe(ee(t,"float32")),1))}}};const BO={kernelName:jo,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,oe(he(1),Pe(ee(t,"float32"))))}}};function VO(n,e,t,s,r,o){const a=C(n,"dy","avgPool3dGrad"),i=C(e,"input","avgPool3dGrad");let l=a,u=i,c=!1;i.rank===4&&(c=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),I(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),jt("avgPool3dGrad",r,o);const h={dy:l,input:u},d={filterSize:t,strides:s,pad:r,dimRoundingMode:o},p=R.runKernel(nh,h,d);return c?L(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const WO=O({avgPool3dGrad_:VO});const UO={kernelName:Hi,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:i}=t;return{x:()=>WO(n,s,r,o,a,i)}}};function GO(n,e,t,s,r){const o=C(n,"dy","avgPoolGrad"),a=C(e,"input","avgPoolGrad");I(a.rank===o.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${o.rank})`);let i=a,l=o,u=!1;a.rank===3&&(u=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=L(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),I(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);const c={dy:l,input:i},h={filterSize:t,strides:s,pad:r},d=R.runKernel(th,c,h);return u?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const HO=O({avgPoolGrad_:GO});const jO={kernelName:Gi,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:o,pad:a}=t;return{x:()=>HO(n,s,r,o,a)}}};const qO={kernelName:ji,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:o,transposeB:a}=t;return!o&&!a?{a:()=>Se(n,r,!1,!0),b:()=>Se(s,n,!0,!1)}:!o&&a?{a:()=>Se(n,r,!1,!1),b:()=>Se(n,s,!0,!1)}:o&&!a?{a:()=>Se(r,n,!1,!0),b:()=>Se(s,n,!1,!1)}:{a:()=>Se(r,n,!0,!0),b:()=>Se(n,s,!0,!0)}}};const KO={kernelName:qi,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>nu(n,s,r)}}};const XO={kernelName:iw,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,o=s.shape,a=Array.from(o);for(let l=r.length-1;l>=0;l--)if(r[l]===o[l])a[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${o}].`);const i=[];for(let l=0;l<a.length;l++)a[l]>1&&i.push(l);return{x:()=>ie(n,i,!0)}}};const YO={kernelName:Ko,gradFunc:n=>({x:()=>n.clone()})};const ZO={kernelName:Xo,gradFunc:n=>({x:()=>Ee(n)})};const JO={kernelName:Yo,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:o}=t;return{x:()=>wt(On(Ps(s,r),yr(s,o)),n,Ee(n))}}};const QO={kernelName:Xi,inputsToSave:["x"],gradFunc:_v.gradFunc};const e_={kernelName:Yi,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,o=Ie(r,e[0].shape)[0],a=s.map(l=>l[o]);return Zt(n,a,o).map(l=>()=>l)}};const t_={kernelName:Zi,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:o,strides:a,pad:i,dataFormat:l}=t;return I(or(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>vm(s.shape,n,r,a,i,l),filter:()=>og(s,n,r.shape,a,i,l)}}};const n_={kernelName:Ji,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:o,pad:a,dataFormat:i,dimRoundingMode:l}=t;return{dy:()=>As(n,r,o,a,i,1,l),filter:()=>og(n,s,r.shape,o,a,i,l)}}};function s_(n,e,t,s,r){let o=n;n.rank===4&&(o=L(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),I(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),I(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),I(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),I(o.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${t[3]}.`),I(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const i={x:o,dy:a},l={strides:s,pad:r,filterShape:t};return R.runKernel(ih,i,l)}const r_=O({conv3DBackpropFilter_:s_});const o_={kernelName:Qi,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:o}=t;I(or(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,i]=e;return{x:()=>Ww(a.shape,n,i,r,o),filter:()=>r_(a,n,i.shape,r,o)}}};const a_={kernelName:Zo,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(Ue(Nd(ee(t,"float32"))),n)}}};const i_={kernelName:Jo,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(Cd(ee(t,"float32")),n)}}};const l_={kernelName:el,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:o,reverse:a}=t;return{x:()=>{const i=Qe([r],s.rank);let l=dd(n,r,o,!a);return i!=null&&(l=ke(l,i)),l}}}};const u_={kernelName:tl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:o,dimRoundingMode:a}=t,i=s??[1,1];I(or(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[l,u]=e;return I(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),I(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),I(_t(r,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${i}'.`),jt("depthwiseConv2d",o,a),{x:()=>D1(l.shape,n,u,r,o,i,a),filter:()=>R1(l,n,u.shape,r,o,i,a)}}};const c_={kernelName:nl,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,o={x:s,filter:r,dy:n},a={x:s,filter:r,dy:n};return{x:()=>R.runKernel(Sc,o,t),filter:()=>R.runKernel(Ic,a,t)}}};const h_={kernelName:ea,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>R.runKernel(xh,s)}}};const d_={kernelName:ta,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=_(tn(Ue(Pe(t))),2/Math.sqrt(Math.PI));return{x:()=>_(n,s)}}};const p_={kernelName:na,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(n,t)}}};const f_={kernelName:rl,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>L(n,t.shape)}}};const m_={kernelName:sa,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(n,tn(t))}}};const g_={kernelName:ra,gradFunc:n=>({x:()=>Ee(n)})};const y_={kernelName:oa,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(t.shape,s.shape);return{a:()=>{const i=ue(n,ee(s,"float32")),l=ht(t.shape,r);return l.length>0?L(ie(i,l),t.shape):i},b:()=>{let i=_(n,ee(t,"float32"));const l=ht(s.shape,r);l.length>0&&(i=L(ie(i,l),s.shape));const u=Pe(s);return Ue(ue(i,ee(u,"float32")))}}}};const x_={kernelName:ol,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,o,a,i]=e,l=i??he(1),u=ht(o.shape,r.shape),c=[];if(o.rank===1){for(let b=0;b<r.shape.length-1;++b)c.push(r.shape[b]);c.push(1)}const h=oe(r,o),d=_(n,l),p=$d(Y(a,he(s))),f=_(_(_(p,p),p),he(-.5));return{x:()=>o.rank===1?L(_(_(n,wn(L(p,[1,1,1,o.shape[0]]),c)),l),r.shape):L(_(_(n,p),l),r.shape),mean:()=>{let b=_(_(p,he(-1)),d);return o.rank===1&&(b=ie(b,u)),L(b,o.shape)},variance:()=>{let b=_(_(f,h),d);return o.rank===1&&(b=ie(b,u)),L(b,o.shape)},scale:()=>{const b=_(h,p);let $=_(n,b);return o.rank===1&&($=ie($,u)),L($,o.shape)},offset:()=>{let b=n;return o.rank===1&&(b=ie(b,u)),L(b,o.shape)}}}};const b_={kernelName:al,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:o,batchDims:a}=t,i=Ie(o,s.shape)[0],l=(u,c,h)=>()=>{const d=u.shape,p=c.size,f=d.slice(0,i),m=f.length,g=d.slice(o,d.length).slice(1),y=g.length,x=xb(0,m),w=xb(m+1,m+1+y),b=bb([f,[p],g]),$=L(h,b),N=L(c,[p]),T=bb([[m],x,w]),A=ke($,T);let k=Dd(A,N,u.shape[i]);const E=gr(T);return k=ke(k,E),k};if(a===1){const u=s.shape[0],c=s.split(u,0);return{x:()=>Gt(c.map((p,f)=>l(p,r.slice(f,1),n.slice(f,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function xb(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function bb(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const w_={kernelName:aa,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Ee(t),b:()=>Ee(s)}}};const v_={kernelName:ia,gradFunc:n=>({x:()=>ee(n,"float32")})};const $_={kernelName:la,gradFunc:n=>({x:()=>Ee(n)})};const S_={kernelName:ua,gradFunc:n=>({x:()=>Ee(n)})};const I_={kernelName:ca,gradFunc:n=>({x:()=>Ee(n)})};const N_={kernelName:ll,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,o=qt(s,0);return{x:()=>wt(o,n,_(n,r))}}};const C_={kernelName:da,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,Y(t,1))}}};const k_={kernelName:ha,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,ee(t,"float32"))}}};const T_={kernelName:lw,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const a=tn(s);return oe(n,_(ie(n,r,!0),a))}}}};function E_(n,e,t,s=5,r=1,o=1,a=.5){const i={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:o,beta:a};return R.runKernel(Ch,i,l)}const A_=O({localResponseNormalizationBackprop_:E_});const R_={kernelName:fl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:o,bias:a,alpha:i,beta:l}=t;return{x:()=>A_(s,r,n,o,a,i,l)}}};function Fv(n,e,t,s){return e.rank<t.rank&&(e=L(e,st(e.shape,s))),n.rank<t.rank&&(n=L(n,st(n.shape,s))),{x:()=>_(n,ee(hn(t,e),n.dtype))}}const wb={kernelName:ml,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,o=e[0],a=e[1],i=Ie(r,o.shape),l=Fv(n,a,o,i);return{x:()=>l.x()}}};const D_={kernelName:pa,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>_(n,ee(Ps(t,s),"float32")),b:()=>_(n,ee(Ao(t,s),"float32"))}}};function O_(n,e,t,s,r,o,a){const i=C(n,"dy","maxPool3dGrad"),l=C(e,"input","maxPool3dGrad"),u=C(t,"output","maxPool3dGrad");let c=i,h=l,d=u,p=!1;l.rank===4&&(p=!0,c=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=L(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=L(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),I(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),I(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),I(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),jt("maxPool3dGrad",o,a);const f={dy:c,input:h,output:d},m={filterSize:s,strides:r,pad:o,dimRoundingMode:a},g=R.runKernel(Th,f,m);return p?L(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const __=O({maxPool3dGrad_:O_});const F_={kernelName:yl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=t;return{x:()=>__(n,s,r,o,a,i,l)}}};function L_(n,e,t,s,r,o,a){const i=C(n,"dy","maxPoolGrad"),l=C(e,"input","maxPoolGrad"),u=C(t,"output","maxPoolGrad");I(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`),I(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),I(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),jt("maxPoolGrad",o,a);const c={dy:i,input:l,output:u},h={filterSize:s,strides:r,pad:o,dimRoundingMode:a};return R.runKernel(kh,c,h)}const P_=O({maxPoolGrad_:L_});const z_={kernelName:gl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:o,strides:a,pad:i}=t;return{x:()=>P_(n,s,r,o,a,i)}}};const M_={kernelName:xl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,o=Ie(r,s.shape),i=Nt(s.shape,o)[1],l=G(i);return{x:()=>{const c=s.shape.slice();o.forEach(p=>{c[p]=1});const h=L(n,c);return ue(_(h,Yt(s.shape,"float32")),l)}}}};const B_={kernelName:bl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[o,a]=e,i=Ie(r,o.shape),l=Fv(n,a,o,i);return{x:()=>l.x()}}};const V_={kernelName:fa,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>_(n,ee(yr(t,s),"float32")),b:()=>_(n,ee(qt(t,s),"float32"))}}};const W_={kernelName:wl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,o=r.map(a=>a[0]);return{x:()=>Te(n,o,s.shape)}}};const U_={kernelName:ma,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(t.shape,s.shape);return{a:()=>{const i=ht(t.shape,r);return i.length>0?L(ie(n,i),t.shape):n},b:()=>{const i=_(n,Ue(Ba(ue(t,s)))),l=ht(s.shape,r);return l.length>0?L(ie(i,l),s.shape):i}}}};const G_={kernelName:ga,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(t.shape,s.shape);return{a:()=>{const i=_(n,ee(s,"float32")),l=ht(t.shape,r);return l.length>0?L(ie(i,l),t.shape):i},b:()=>{const i=_(n,ee(t,"float32")),l=ht(s.shape,r);return l.length>0?L(ie(i,l),s.shape):i}}}};const H_={kernelName:vl,gradFunc:n=>({x:()=>Ue(n)})};const j_={kernelName:Il,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>lt(t.shape,"float32")}}};const q_={kernelName:Sl,gradFunc:n=>({x:()=>Ee(n)})};const K_={kernelName:Nl,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Cn(n,s).map(o=>()=>o)}};const vb={kernelName:Cl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,o=r.map(a=>a[0]);return{x:()=>Te(n,o,s.shape)}}};const X_={kernelName:ya,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,o=t,a=s,i=xe(o.shape,a.shape);return{a:()=>{const c=ee(a,"float32");let h=_(n,_(c,ps(o,oe(c,he(1)))));const d=ht(o.shape,i);return d.length>0&&(h=ie(h,d)),L(h,o.shape)},b:()=>{const c=qt(o,0),h=wt(c,dn(o),Ee(o));let d=_(n,_(r,h));const p=ht(a.shape,i);return p.length>0&&(d=ie(d,p)),L(d,a.shape)}}}};const Y_={kernelName:kl,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=qt(t,0);return{x:()=>wt(r,n,_(n,s)),alpha:()=>{let o=wt(r,Ee(n),_(n,t));const a=ht(s.shape,n.shape);return a.length>0&&(o=ie(o,a)),L(o,s.shape)}}}};function Z_(n,e,t){const s=n.shape.slice();s[t]=1;const r=L(e,s),o=Ri(n,t,!0,!1),a=Ri(n,t,!0,!0),i=_(o,a);return _(r,i)}function J_(n,e,t){const s=n.shape.length,r=s-t.length,o=Qe(t,s);let a=n;o!=null&&(a=ke(n,o));const i=a.shape.slice(),u=i.splice(s-t.length,t.length).reduce((d,p)=>d*p,1);i.push(u);const c=a.reshape(i);let h=Z_(c,e,r);if(h=h.reshape(a.shape),o!=null){const d=gr(o);h=ke(h,d)}return h}const Q_={kernelName:Tl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let o=[];return r==null?o=s.shape.map((a,i)=>i):typeof r=="number"?o=[r]:o=r,{x:()=>J_(s,n,o)}}};const eF={kernelName:Qo,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(t.shape,s.shape);return{a:()=>{const i=ue(n,ee(s,"float32")),l=ht(t.shape,r);return l.length>0?L(ie(i,l),t.shape):i},b:()=>{let i=_(n,ee(t,"float32"));const l=ht(s.shape,r);l.length>0&&(i=L(ie(i,l),s.shape));const u=Pe(s);return Ue(ue(i,ee(u,"float32")))}}}};const tF={kernelName:xa,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,Ue(Pe(t)))}}};const nF={kernelName:wa,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=_(yr(t,6),co(t));return{x:()=>_(n,ee(s,"float32"))}}};const sF={kernelName:ba,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(n,ee(co(t),"float32"))}}};const rF={kernelName:El,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>L(n,t.shape)}}};const oF={kernelName:Rl,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>R.runKernel(Bh,r,t)}}};const aF={kernelName:Al,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>R.runKernel(Mh,r,t)}}};const iF={kernelName:Dl,gradFunc:(n,e,t)=>{const{dims:s}=t,r=Ie(s,n.shape);return{x:()=>Nn(n,r)}}};const lF={kernelName:va,gradFunc:n=>({x:()=>Ee(n)})};const uF={kernelName:$a,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(ue(n,_(ps(t,1.5),2)))}}};const cF={kernelName:Ol,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>ee(Ee(t),"float32"),t:()=>_(n,ee(t,n.dtype)),e:()=>_(n,ee(Ql(t),n.dtype))}}};const hF={kernelName:Sa,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=qt(t,he(0)),r=he(jd),o=he(qd),a=_(n,o),i=_(_(n,r),tn(ee(t,"float32")));return wt(s,a,i)}}}};const dF={kernelName:ka,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(n,_(t,oe(he(1),t)))}}};const pF={kernelName:Ca,gradFunc:n=>({x:()=>Ee(n)})};const fF={kernelName:Ia,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(Kl(ee(t,"float32")),n)}}};const mF={kernelName:Na,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(hd(ee(t,"float32")),n)}}};const gF={kernelName:_l,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:o}=t,a=s.shape,[i,l]=Gd(s,r,o),u=[];for(let c=0;c<n.rank;c++)u.push([i[c],a[c]-i[c]-l[c]]);return{x:()=>zs(n,u)}}};const yF={kernelName:zl,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,o=!0,a=_(n,s);return{logits:()=>oe(a,_(ie(a,[r],o),s))}}};const xF={kernelName:Ta,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(n,Gn(t))}}};const $b={kernelName:Ll,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>ql(n,s,r)}}};const Sb={kernelName:Pl,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>nt(n,s)}}};const bF={kernelName:Ea,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,_($t(ee(t,"float32")),2))}}};const wF={kernelName:Xh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(n,_(ee(t,"float32"),2))}}};const vF={kernelName:Aa,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=he(2);return{a:()=>_(n,_(r,oe(t,s))),b:()=>_(n,_(r,oe(s,t)))}}};const $F={kernelName:Fa,gradFunc:n=>({x:()=>Ee(n)})};const SF={kernelName:Ra,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=xe(t.shape,s.shape);return{a:()=>{let i=n;const l=ht(t.shape,r);return l.length>0&&(i=ie(i,l)),L(i,t.shape)},b:()=>{let i=n;const l=ht(s.shape,r);return l.length>0&&(i=ie(i,l)),L(Ue(i),s.shape)}}}};const IF={kernelName:Fl,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:o}=t;Ie(o,s.shape).forEach(u=>{r[u]=1});const i=L(n,r),l=_(i,Yt(s.shape,"float32"));return{x:()=>l}}};const NF={kernelName:Da,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ue(n,Pe(Kl(t)))}}};const CF={kernelName:Oa,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_(oe(he(1),Pe(t)),n)}}};const kF={kernelName:_a,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let a=Ee(s);if(s.rank===1)for(let i=0;i<r[0];++i)a=Y(a,Te(n,[i*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)a=Y(a,Te(n,[i*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)a=Y(a,Te(n,[i*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)a=Y(a,Te(n,[i*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};const TF={kernelName:Lr,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,o=gr(r);return{x:()=>ke(n,o)}}};const EF={kernelName:Bl,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>Gt(n,r)}}};const AF={kernelName:Vl,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>RF(n,t)}}};function RF(n,e){const t=gs(e,Ee(e)),s=Va(n,t);let r=Ps(e,he(0,"int32"));const o=s.rank-r.rank;for(let i=0;i<o;++i)r=Tt(r,i+1);r=On(r,Yt(s.shape,"bool"));const a=Ee(s);return wt(r,s,a)}const DF={kernelName:Wl,gradFunc:n=>({x:()=>Ee(n)})};const OF=[_v,AO,RO,DO,OO,_O,FO,LO,PO,zO,MO,BO,UO,jO,qO,KO,XO,YO,ZO,JO,QO,e_,n_,t_,o_,a_,i_,l_,u_,c_,eF,h_,d_,p_,f_,m_,y_,g_,x_,b_,w_,v_,$_,S_,I_,N_,C_,k_,T_,R_,wb,wb,D_,F_,z_,M_,B_,V_,W_,U_,G_,H_,j_,q_,K_,vb,vb,X_,Y_,Q_,tF,nF,sF,rF,oF,aF,iF,lF,uF,cF,hF,dF,pF,fF,mF,gF,yF,xF,$b,$b,Sb,Sb,bF,vF,wF,$F,SF,IF,NF,CF,kF,TF,EF,AF,DF];for(const n of OF)uw(n);H().prototype.abs=function(){return this.throwIfDisposed(),it(this)};H().prototype.acos=function(){return this.throwIfDisposed(),nm(this)};H().prototype.acosh=function(){return this.throwIfDisposed(),sm(this)};H().prototype.add=function(n){return this.throwIfDisposed(),Y(this,n)};H().prototype.all=function(n,e){return this.throwIfDisposed(),ld(this,n,e)};H().prototype.any=function(n,e){return this.throwIfDisposed(),Ti(this,n,e)};H().prototype.argMax=function(n){return this.throwIfDisposed(),Gr(this,n)};H().prototype.argMin=function(n){return this.throwIfDisposed(),rm(this,n)};H().prototype.asScalar=function(){return this.throwIfDisposed(),I(this.size===1,()=>"The array must have only 1 element."),L(this,[])};H().prototype.asType=function(n){return this.throwIfDisposed(),ee(this,n)};H().prototype.as1D=function(){return this.throwIfDisposed(),L(this,[this.size])};H().prototype.as2D=function(n,e){return this.throwIfDisposed(),L(this,[n,e])};H().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),L(this,[n,e,t])};H().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),L(this,[n,e,t,s])};H().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),L(this,[n,e,t,s,r])};H().prototype.asin=function(){return this.throwIfDisposed(),om(this)};H().prototype.asinh=function(){return this.throwIfDisposed(),am(this)};H().prototype.atan=function(){return this.throwIfDisposed(),im(this)};H().prototype.atan2=function(n){return this.throwIfDisposed(),lm(this,n)};H().prototype.atanh=function(){return this.throwIfDisposed(),um(this)};H().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),jl(this,n,e,t,s)};H().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),ql(this,n,e)};H().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),La(this,n,e,t,s,r)};H().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Pr(this,n)};H().prototype.cast=function(n){return this.throwIfDisposed(),ee(this,n)};H().prototype.ceil=function(){return this.throwIfDisposed(),gm(this)};H().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),en(this,n,e)};H().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Ae&&(n=[n]),nt([this,...n],e)};H().prototype.conv1d=function(n,e,t,s,r,o){return this.throwIfDisposed(),ud(this,n,e,t,s,r,o)};H().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),cd(this,n,e,t,s,r)};H().prototype.conv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),As(this,n,e,t,s,r,o)};H().prototype.cos=function(){return this.throwIfDisposed(),Kl(this)};H().prototype.cosh=function(){return this.throwIfDisposed(),hd(this)};H().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),Ri(this,n,e,t)};H().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),dd(this,n,e,t)};H().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),Im(this,n,e)};H().prototype.depthwiseConv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),Pa(this,n,e,t,s,r,o)};H().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),Nm(this,n,e,t,s,r)};H().prototype.divNoNan=function(n){return this.throwIfDisposed(),Cm(this,n)};H().prototype.div=function(n){return this.throwIfDisposed(),ue(this,n)};H().prototype.dot=function(n){return this.throwIfDisposed(),km(this,n)};H().prototype.elu=function(){return this.throwIfDisposed(),za(this)};H().prototype.equal=function(n){return this.throwIfDisposed(),hn(this,n)};H().prototype.erf=function(){return this.throwIfDisposed(),pd(this)};H().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),Em(this,n,e)};H().prototype.exp=function(){return this.throwIfDisposed(),tn(this)};H().prototype.expandDims=function(n){return this.throwIfDisposed(),Tt(this,n)};H().prototype.expm1=function(){return this.throwIfDisposed(),Am(this)};H().prototype.fft=function(){return this.throwIfDisposed(),iu(this)};H().prototype.flatten=function(){return this.throwIfDisposed(),L(this,[this.size])};H().prototype.floor=function(){return this.throwIfDisposed(),Ba(this)};H().prototype.floorDiv=function(n){return this.throwIfDisposed(),id(this,n)};H().prototype.gather=function(n,e,t){return this.throwIfDisposed(),Va(this,n,e,t)};H().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Ps(this,n)};H().prototype.greater=function(n){return this.throwIfDisposed(),qt(this,n)};H().prototype.ifft=function(){return this.throwIfDisposed(),_o(this)};H().prototype.irfft=function(){return this.throwIfDisposed(),Td(this)};H().prototype.isFinite=function(){return this.throwIfDisposed(),Rm(this)};H().prototype.isInf=function(){return this.throwIfDisposed(),Dm(this)};H().prototype.isNaN=function(){return this.throwIfDisposed(),Om(this)};H().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Yl(this,n)};H().prototype.lessEqual=function(n){return this.throwIfDisposed(),yr(this,n)};H().prototype.less=function(n){return this.throwIfDisposed(),Ao(this,n)};H().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),_m(this,n,e,t,s)};H().prototype.logSigmoid=function(){return this.throwIfDisposed(),Fm(this)};H().prototype.logSoftmax=function(n){return this.throwIfDisposed(),gd(this,n)};H().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),Jl(this,n,e)};H().prototype.log=function(){return this.throwIfDisposed(),dn(this)};H().prototype.log1p=function(){return this.throwIfDisposed(),Zl(this)};H().prototype.logicalAnd=function(n){return this.throwIfDisposed(),On(this,n)};H().prototype.logicalNot=function(){return this.throwIfDisposed(),Ql(this)};H().prototype.logicalOr=function(n){return this.throwIfDisposed(),yd(this,n)};H().prototype.logicalXor=function(n){return this.throwIfDisposed(),Lm(this,n)};H().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),Se(this,n,e,t)};H().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),eu(this,n,e,t,s)};H().prototype.max=function(n,e){return this.throwIfDisposed(),In(this,n,e)};H().prototype.maximum=function(n){return this.throwIfDisposed(),gs(this,n)};H().prototype.mean=function(n,e){return this.throwIfDisposed(),Ye(this,n,e)};H().prototype.min=function(n,e){return this.throwIfDisposed(),Eo(this,n,e)};H().prototype.minimum=function(n){return this.throwIfDisposed(),ir(this,n)};H().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),zm(this,n,e)};H().prototype.mod=function(n){return this.throwIfDisposed(),Mm(this,n)};H().prototype.mul=function(n){return this.throwIfDisposed(),_(this,n)};H().prototype.neg=function(){return this.throwIfDisposed(),Ue(this)};H().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Ma(this,n,e,t)};H().prototype.notEqual=function(n){return this.throwIfDisposed(),qr(this,n)};H().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Ro(this,n,e,t)};H().prototype.onesLike=function(){return this.throwIfDisposed(),pn(this)};H().prototype.pad=function(n,e){return this.throwIfDisposed(),zs(this,n,e)};H().prototype.pool=function(n,e,t,s,r,o){return this.throwIfDisposed(),Bm(this,n,e,t,s,r,o)};H().prototype.pow=function(n){return this.throwIfDisposed(),ps(this,n)};H().prototype.prelu=function(n){return this.throwIfDisposed(),su(this,n)};H().prototype.prod=function(n,e){return this.throwIfDisposed(),Vm(this,n,e)};H().prototype.reciprocal=function(){return this.throwIfDisposed(),qm(this)};H().prototype.relu=function(){return this.throwIfDisposed(),Jn(this)};H().prototype.relu6=function(){return this.throwIfDisposed(),wd(this)};H().prototype.reshapeAs=function(n){return this.throwIfDisposed(),L(this,n.shape)};H().prototype.reshape=function(n){return this.throwIfDisposed(),L(this,n)};H().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),L1(this,n,e,t)};H().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),P1(this,n,e,t)};H().prototype.reverse=function(n){return this.throwIfDisposed(),Nn(this,n)};H().prototype.rfft=function(){return this.throwIfDisposed(),lu(this)};H().prototype.round=function(){return this.throwIfDisposed(),vd(this)};H().prototype.rsqrt=function(){return this.throwIfDisposed(),$d(this)};H().prototype.selu=function(){return this.throwIfDisposed(),Sd(this)};H().prototype.separableConv2d=function(n,e,t,s,r,o){return this.throwIfDisposed(),Id(this,n,e,t,s,r,o)};H().prototype.sigmoid=function(){return this.throwIfDisposed(),Gn(this)};H().prototype.sign=function(){return this.throwIfDisposed(),Km(this)};H().prototype.sin=function(){return this.throwIfDisposed(),Nd(this)};H().prototype.sinh=function(){return this.throwIfDisposed(),Cd(this)};H().prototype.slice=function(n,e){return this.throwIfDisposed(),Te(this,n,e)};H().prototype.softmax=function(n){return this.throwIfDisposed(),au(this,n)};H().prototype.softplus=function(){return this.throwIfDisposed(),uo(this)};H().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),nu(this,n,e)};H().prototype.split=function(n,e){return this.throwIfDisposed(),Zt(this,n,e)};H().prototype.sqrt=function(){return this.throwIfDisposed(),$t(this)};H().prototype.square=function(){return this.throwIfDisposed(),Pe(this)};H().prototype.squaredDifference=function(n){return this.throwIfDisposed(),Ed(this,n)};H().prototype.squeeze=function(n){return this.throwIfDisposed(),br(this,n)};H().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Ae?[this,n]:[this,...n];return Gt(t,e)};H().prototype.step=function(n){return this.throwIfDisposed(),co(this,n)};H().prototype.stridedSlice=function(n,e,t,s,r,o,a,i){return this.throwIfDisposed(),Xm(this,n,e,t,s,r,o,a,i)};H().prototype.sub=function(n){return this.throwIfDisposed(),oe(this,n)};H().prototype.sum=function(n,e){return this.throwIfDisposed(),ie(this,n,e)};H().prototype.tan=function(){return this.throwIfDisposed(),Ym(this)};H().prototype.tanh=function(){return this.throwIfDisposed(),ar(this)};H().prototype.tile=function(n){return this.throwIfDisposed(),wn(this,n)};H().prototype.toBool=function(){return this.throwIfDisposed(),ee(this,"bool")};H().prototype.toFloat=function(){return this.throwIfDisposed(),ee(this,"float32")};H().prototype.toInt=function(){return this.throwIfDisposed(),ee(this,"int32")};H().prototype.topk=function(n,e){return this.throwIfDisposed(),Qm(this,n,e)};H().prototype.transpose=function(n){return this.throwIfDisposed(),ke(this,n)};H().prototype.unique=function(n){return this.throwIfDisposed(),eg(this,n)};H().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Dd(this,n,e)};H().prototype.unstack=function(n){return this.throwIfDisposed(),Cn(this,n)};H().prototype.where=function(n,e){return this.throwIfDisposed(),wt(n,this,e)};H().prototype.zerosLike=function(){return this.throwIfDisposed(),Ee(this)};class ts extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ts.prototype)}}class Dn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Dn.prototype)}}class P extends Error{constructor(e){super(e),Object.setPrototypeOf(this,P.prototype)}}class be extends Error{constructor(e){super(e),Object.setPrototypeOf(this,be.prototype)}}class Wg extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Wg.prototype)}}class Lv{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function Yr(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ns(n,e){if(!n)throw new Wg(e)}function Ib(n,e){let t=0;for(const s of n)s===e&&t++;return t}function Xt(n){return n.length===1?n[0]:n}function _e(n){return Array.isArray(n)?n:[n]}function ws(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Ar(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Tn={};function Ug(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function uf(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>uf(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:uf(s))}}}function du(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const o=n;let a;if(o in t)a=t[o];else if(o in Tn)a=Tn[o];else if(a=e[o],a==null)throw new P(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const o=n;if(o.className==null||o.config==null)throw new P(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const a=o.className;let i,l;if(a in t?[i,l]=t[a]:a in Tn?[i,l]=Tn.className:a in e&&([i,l]=e[a]),i==null)throw new P(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(Tn))u[p]=Tn[p];for(const p of Object.keys(t))u[p]=t[p];const c=o.config;c.customObjects=u;const h=Object.assign({},Tn);for(const p of Object.keys(t))Tn[p]=t[p];uf(o.config);const d=l(i,o.config,t,r);return Tn=Object.assign({},h),d}else{const u=Object.assign({},Tn);for(const h of Object.keys(t))Tn[h]=t[h];const c=new i(o.config);return Tn=Object.assign({},u),c}}}function _F(n,e){return n<e?-1:n>e?1:0}function Ru(n,e){return-1*_F(n,e)}function er(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function FF(n){if(n==null)throw new P(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function po(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new P(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function Gg(n,e,t=0,s=1/0){return ns(t>=0),ns(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function bt(n,e){Array.isArray(n)?(I(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>bt(t,`element ${s+1} of ${e}`))):I(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Pv(n)}.`)}function Pv(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Pv(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function LF(n,e,t){let s=t!=null?t():kt(),r;return(...a)=>{const i=t!=null?t():kt();return i-s<e||(s=i,r=n(...a)),r}}function zv(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let PF=0;function Mv(){return PF++}const Du={};function Kd(n=""){return n in Du||(Du[n]=0),Du[n]+=1,n+Du[n].toString()}const zF=["channelsFirst","channelsLast"],MF=["nearest","bilinear"],BF=["valid","same","causal"],VF=["max","avg"],WF=["sum","mul","concat","ave"];const wo=new Map;function ot(n){po(zF,"DataFormat",n)}function UF(n){po(MF,"InterpolationFormat",n)}function kn(n){po(BF,"PaddingMode",n)}function Bv(n){po(VF,"PoolMode",n)}const bi=[],Nb="/";function zr(n,e){bi.push(n);try{const t=e();return bi.pop(),t}catch(t){throw bi.pop(),t}}function GF(){return bi.length===0?"":bi.join(Nb)+Nb}function Vv(n){if(!Uv(n))throw new Error("Not a valid tensor name: '"+n+"'");return GF()+n}function Wv(n){if(!Uv(n))throw new Error("Not a valid tensor name: '"+n+"'");wo.has(n)||wo.set(n,0);const e=wo.get(n);if(wo.set(n,wo.get(n)+1),e>0){const t=`${n}_${e}`;return wo.set(t,1),t}else return n}const HF=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Uv(n){return!!n.match(HF)}function jF(n){return n===parseInt(n.toString(),10)}function tr(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Fo(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function lr(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function qn(n,e){if(e<n)throw new P(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let Ap;function ft(){return Ap==null&&(Ap=Yf().epsilon()),Ap}function Kn(){return"channelsLast"}function us(n,e){return ee(n,e)}function pu(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),L(n,t)}function qF(n,e){return B(()=>{if(n.shape.length!==2)throw new P(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=pu(n,1);return cf(t,[1,e,1])})}function KF(n){const e=[tr(n.shape)];return L(n,e)}function XF(n){if(n.rank<=1)throw new P(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],tr(n.shape,1)];return L(n,e)}function Mr(n,e,t){return B(()=>{switch(n.rank){case 1:return ru(n,e,t);case 2:return kd(n,[e,0],[t,n.shape[1]]);case 3:return ou(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Oo(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Te(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Te(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new P(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Rp(n,e,t){return B(()=>{switch(n.rank){case 1:return ru(n,e,t);case 2:return kd(n,[0,e],[n.shape[0],t]);case 3:return ou(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Oo(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ou(n,e,t,s){return B(()=>{switch(n.rank){case 1:return ru(n,e,t);case 2:switch(s){case 1:return Mr(n,e,t);case 2:return Rp(n,e,t);default:throw new P(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Mr(n,e,t);case 2:return ou(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Rp(n,e,t);default:throw new P(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Mr(n,e,t);case 2:return Oo(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Oo(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Rp(n,e,t);default:throw new P(`The axis is not within the rank of the tensor ${s}`)}default:throw new P(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Hg(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),nt(n,e)}function Cb(n,e){switch(n.rank){case 1:return ym([n,e]);case 2:return xm([n,e],0);case 3:return bm([n,e],0);case 4:return wm([n,e],0);default:throw new P(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function cf(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new P(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return wn(n,e)}function Xd(n,e=0,t=1,s,r){return bd(n,e,t,s,r)}function cs(n,e,t,s){if(n.rank<2||e.rank<2)throw new be(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],o=e.shape.slice(-2)[0];if(r!==o)throw new be(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return sf({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?hf(n.rank,s,Kn()):null,activation:t});{const r=n.shape.slice(),o=r.pop();n=L(n,[-1,o]);const a=e.shape.slice(),i=a.pop(),l=a.pop(),u=[...a,i],c=Array.from({length:e.rank},(f,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=L(ke(e,c),[l,-1]);const h=[...r,...u];return L(sf({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?hf(n.rank,s,Kn()):null,activation:t}),h)}}function Gv(n,e,t){return B(()=>(Array.isArray(e)?e=Rt(e,"int32"):e=ee(e,"int32"),Va(n,e,t)))}function fu(n){return _(n,n)}function hf(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new P(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?L(e,[1,s[0],1,1,1]):L(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?L(e,[1,1,1,1,s[0]]):L(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?L(e,[1,s[0],1,1]):L(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?L(e,[1,1,1,s[0]]):L(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?L(e,[1,s[0],1]):L(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?L(e,[1,1,s[0]]):L(e,[1].concat(s))}else if(n<3)return e;throw new P(`Unsupported input rank by biasAdd: ${e.rank}`)}function Qn(n,e,t){return B(()=>(t==null&&(t=Kn()),ot(t),Y(n,hf(n.rank,e,t))))}function YF(n,e=1){if(e!==1)throw new be(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return za(n)}function ZF(n){return B(()=>ue(n,Y(it(n),1)))}function Hv(n,e,t,s){return B(()=>sg(n,e,t,s))}function JF(n){return B(()=>{const e=Y(.5,_(.2,n));return en(e,0,1)})}function mu(n,e,t=!1){return t?n():e()}const QF=["fanIn","fanOut","fanAvg"],eL=["normal","uniform","truncatedNormal"];function tL(n){po(QF,"FanMode",n)}function nL(n){po(eL,"Distribution",n)}class Fn extends ho{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class jg extends Fn{apply(e,t){return lt(e,t)}}jg.className="Zeros";Z(jg);class Yd extends Fn{apply(e,t){return Yt(e,t)}}Yd.className="Ones";Z(Yd);class qg extends Fn{constructor(e){if(super(),typeof e!="object")throw new P(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new P(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return B(()=>_(he(this.value),Yt(e,t)))}getConfig(){return{value:this.value}}}qg.className="Constant";Z(qg);class Kg extends Fn{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return xr(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Kg.className="RandomUniform";Z(Kg);class Xg extends Fn{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new be(`randomNormal does not support dType ${t}.`);return Xd(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Xg.className="RandomNormal";Z(Xg);class Yg extends Fn{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new be(`truncatedNormal does not support dType ${t}.`);return Rd(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Yg.className="TruncatedNormal";Z(Yg);class Zg extends Fn{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return B(()=>{if(e.length!==2||e[0]!==e[1])throw new P("Identity matrix initializer can only be used for 2D square matrices.");return _(this.gain,fd(e[0]))})}getConfig(){return{gain:this.gain}}}Zg.className="Identity";Z(Zg);function sL(n,e="channelsLast"){let t,s;if(ot(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=tr(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=tr(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=tr(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class nn extends Fn{constructor(e){if(super(),e.scale<0)throw new P(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,tL(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,nL(this.distribution),this.seed=e.seed}apply(e,t){const s=sL(e),r=s[0],o=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,o):a/=Math.max(1,(r+o)/2),this.distribution==="normal"){const i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new be(`${this.getClassName()} does not support dType ${t}.`);return Rd(e,0,i,t,this.seed)}else{const i=Math.sqrt(3*a);return xr(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}nn.className="VarianceScaling";Z(nn);class Zd extends nn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return nn.className}}Zd.className="GlorotUniform";Z(Zd);class Jd extends nn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return nn.className}}Jd.className="GlorotNormal";Z(Jd);class Qd extends nn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return nn.className}}Qd.className="HeNormal";Z(Qd);class ep extends nn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return nn.className}}ep.className="HeUniform";Z(ep);class tp extends nn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return nn.className}}tp.className="LeCunNormal";Z(tp);class np extends nn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return nn.className}}np.className="LeCunUniform";Z(np);class Jg extends Fn{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return B(()=>{if(e.length<2)throw new be("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=G(e.slice(0,-1)),r=e[e.length-1],o=s*r;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const a=[Math.max(r,s),Math.min(r,s)],i=Xd(a,0,1,t,this.seed),l=ig.qr(i,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return u=_(u,h.sign()),s<r&&(u=u.transpose()),_(he(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Jg.className="Orthogonal";Z(Jg);const kb={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Tb(n,e={}){return du(n,bn.getMap().classNameMap,e,"initializer")}function Ze(n){return Ug(n)}function je(n){if(typeof n=="string"){const e=n in kb?kb[n]:n;if(e==="GlorotNormal")return new Jd;if(e==="GlorotUniform")return new Zd;if(e==="HeNormal")return new Qd;if(e==="HeUniform")return new ep;if(e==="LeCunNormal")return new tp;if(e==="LeCunUniform")return new np;{const t={};return t.className=e,t.config={},Tb(t)}}else return n instanceof Fn?n:Tb(n)}function df(n){return Array.isArray(n)&&Array.isArray(n[0])}function Ac(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function ge(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new P(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function De(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new P(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function Rc(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}const Eb="Variable";class jv{constructor(e,t="float32",s=Eb,r=!0,o=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Mv(),s=s??Eb,this.originalName=Vv(s),this.name=Wv(this.originalName),this.trainable_=r,this.constraint=o,this.val=tg(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),rL(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function rL(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function pf(n){return n.map(e=>e.read())}function Qg(n){n.forEach(e=>{e[0].write(e[1])})}class ut{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Xn{constructor(e,t,s,r,o,a,i){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=o,this.outputTensorIndex=i,this.id=Mv(),a!=null&&(this.originalName=Vv(a),this.name=Wv(this.originalName)),this.rank=t.length}}let oL=0;class sp{constructor(e,t){this.callArgs=t,this.id=oL++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let aL=0;class Ne extends ho{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=aL++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=ws(s)+"_"+Kd(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let o=null;e.batchSize!=null&&(o=e.batchSize),s=[o].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Dn(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new P(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Xt(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Xt(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ts(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ts(`Layer ${this.name} is not connected, no input to return.`);return Xt(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ts(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ts(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Xt(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=_e(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=_e(this.inputSpec);if(t.length!==s.length)throw new P(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const o=t[r],a=s[r];if(a==null)continue;const i=o.rank;if(a.ndim!=null&&i!==a.ndim)throw new P(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(a.maxNDim!=null&&i>a.maxNDim)throw new P(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(a.minNDim!=null&&i<a.minNDim)throw new P(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(a.dtype!=null&&o.dtype!==a.dtype)throw new P(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${o.dtype}.`);if(a.axes){const l=o.shape;for(const u in a.axes){const c=Number(u),h=a.axes[u],d=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new P(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(a.shape!=null)for(let l=0;l<a.shape.length;++l){const u=a.shape[l],c=o.shape[l];if(u!=null&&c!=null&&u!==c)throw new P(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=_e(e),r=uL(e),o=cL(e);if(r===o)throw new P("Arguments to apply() must be all SymbolicTensors or all Tensors");return zr(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const i of _e(e))a.push(i.shape);this.build(Xt(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(e),o){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const i=_e(a),l=[];for(let u of i)s.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(a=Xt(l),this.activityRegularizer!=null)throw new be("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=iL(e),i=this.computeOutputShape(a);let l;const u=lL(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?l=i.map((c,h)=>new Xn(u,c,this,_e(e),t,this.name,h)):l=new Xn(u,i,this,_e(e),t,this.name),this.addInboundNode(e,l,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new be("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ts(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new ts(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Dn(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Rc(this.weights)}build(e){this.built=!0}getWeights(e=!1){return pf(e?this.trainableWeights:this.weights)}setWeights(e){B(()=>{const t=this.weights;if(t.length!==e.length)throw new P(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=pf(t);for(let o=0;o<r.length;++o){const a=r[o],i=t[o],l=e[o];if(!Ce(a.shape,l.shape))throw new P(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);s.push([i,l])}Qg(s)})}addWeight(e,t,s,r,o,a,i,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new P(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():je("zeros"));const u=r.apply(t,s),c=new jv(u,s,e,a,i);return u.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),a==null&&(a=!0),a?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=_e(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),o=_e(t),a=_e(r);if(o.length!==a.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let i=0;i<o.length;i++)o[i].kerasMask=a[i]}addInboundNode(e,t,s,r,o,a,i=null){const l=_e(e);t=_e(t),s=_e(s),r=_e(r),o=Ac(o),a=Ac(a);const u=[],c=[],h=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new sp({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:o,outputShapes:a},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function iL(n){n=_e(n);const e=[];for(const t of n)e.push(t.shape);return Xt(e)}function lL(n){return"float32"}function qv(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let o=0;o<s.inboundLayers.length;o++){const a=s.inputTensors[o],i=s.inboundLayers[o],l=s.nodeIndices[o],u=qv(a,i,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}function uL(n){let e=!0;for(const t of _e(n))if(!(t instanceof Xn)){e=!1;break}return e}function cL(n){let e=!0;for(const t of _e(n))if(t instanceof Xn){e=!1;break}return e}class Ua extends Ne{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Kd("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new P("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new P("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new P("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new Xn(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new sp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new P(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Ua.className="InputLayer";Z(Ua);function Kv(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new P("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Ua({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function hL(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return ee(e,n.dtype)}catch{throw new P(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Xs{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Xs)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=hL(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new P(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Xn){if(this.id2Value[e.id]==null)throw new P(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new P(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Xn){if(this.id2Value[e.id]==null)throw new P(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new P(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&ye(this.id2Mask)}}const Dc=new Lv,Oc=new Lv;function dL(n){Dc?.setMaxEntries(n),Oc?.setMaxEntries(n)}function di(n,e,t,s){const r=t==null?!1:t.training,o=Array.isArray(n),a=o?n:[n],i=a.map(f=>f.name),l=[],u=e.names();for(const f of i)u.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);const c=i.join(",")+"|"+e.names().sort().join(",");let h=Dc.get(c),d;if(h==null){const f=pL(a,e);h=f.sorted,d=f.recipientCounts,Dc.put(c,h),Oc.put(c,d)}d={},r||Object.assign(d,Oc.get(c));const p=new Xs(e);for(let f=0;f<h.length;++f){const m=h[f],g=m.sourceLayer;if(g instanceof Ua)continue;const y=[],x=[],w=[];let b=!1;for(const k of m.inputs){const E=p.getValue(k),S=p.getMask(k);y.push(E),x.push(S),S!=null&&(b=!0),r||(d[k.name]--,d[k.name]===0&&!e.hasKey(k)&&i.indexOf(k.name)===-1&&!E.isDisposed&&k.sourceLayer.stateful!==!0&&w.push(E))}b&&(t=t||{},t.mask=x[0]);const $=_e(g.apply(y,t));let N=null;g.supportsMasking&&(N=g.computeMask(y,x));const T=mL(m),A=Array.isArray(T)?T:[T];for(let k=0;k<A.length;++k){p.hasKey(A[k])||p.add(A[k],$[k],Array.isArray(N)?N[0]:N);const E=i.indexOf(A[k].name);E!==-1&&(l[E]=$[k])}r||ye(w)}return p.disposeMasks(),o?l:l[0]}function pL(n,e){I(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=Ab(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const o of n){const{sorted:a,recipientMap:i}=Ab(o,e);for(const l of a)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in i)s[l]==null&&(s[l]=new Set),i[l].forEach(u=>s[l].add(u))}}return{sorted:t,recipientCounts:fL(s)}}function fL(n){const e={};for(const t in n)e[t]=n[t].size;return e}function Ab(n,e){const t=new Set,s=[],r={};for(const i of e.names())t.add(i);const o=[],a=[];for(o.push(n);o.length>0;){const i=o[o.length-1];if(t.has(i.name)){o.pop();continue}const l=a[a.length-1]===o.length-1;if(i.inputs.length===0||l)o.pop(),s.push(i),t.add(i.name),l&&a.pop();else{a.push(o.length-1);for(const u of i.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(i.name),!t.has(u.name)&&o.push(u)}}return{sorted:s,recipientMap:r}}function mL(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const gL=V();gL.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,dL);function ey(n,e){return B(()=>$t(ie(_(n,n),e,!0)))}class gu extends ho{getConfig(){return{}}}class ty extends gu{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{const t=ey(e,this.axis),s=en(t,0,this.maxValue);return _(e,ue(s,Y(ft(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ty.className="MaxNorm";Z(ty);class ny extends gu{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>ue(e,Y(ft(),ey(e,this.axis))))}getConfig(){return{axis:this.axis}}}ny.className="UnitNorm";Z(ny);class sy extends gu{apply(e){return Jn(e)}}sy.className="NonNeg";Z(sy);class ry extends gu{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{const t=ey(e,this.axis),s=Y(_(this.rate,en(t,this.minValue,this.maxValue)),_(1-this.rate,t));return _(e,ue(s,Y(ft(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}ry.className="MinMaxNorm";Z(ry);const Rb={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function mt(n){return Ug(n)}function Db(n,e={}){return du(n,bn.getMap().classNameMap,e,"constraint")}function gt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in Rb?Rb[n]:n,config:{}};return Db(t)}else return n instanceof gu?n:Db(n)}function yL(n){return new ty(n)}function xL(n){return new ny(n)}function bL(){return new sy}function wL(n){return new ry(n)}const vL=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:yL,minMaxNorm:wL,nonNeg:bL,unitNorm:xL},Symbol.toStringTag,{value:"Module"}));function $L(){return new jg}function SL(){return new Yd}function IL(n){return new qg(n)}function NL(n){return new Kg(n)}function CL(n){return new Xg(n)}function kL(n){return new Yg(n)}function TL(n){return new Zg(n)}function EL(n){return new nn(n)}function AL(n){return new Zd(n)}function RL(n){return new Jd(n)}function DL(n){return new Qd(n)}function OL(n){return new ep(n)}function _L(n){return new tp(n)}function FL(n){return new np(n)}function LL(n){return new Jg(n)}const PL=Object.freeze(Object.defineProperty({__proto__:null,constant:IL,glorotNormal:RL,glorotUniform:AL,heNormal:DL,heUniform:OL,identity:TL,leCunNormal:_L,leCunUniform:FL,ones:SL,orthogonal:LL,randomNormal:CL,randomUniform:NL,truncatedNormal:kL,varianceScaling:EL,zeros:$L},Symbol.toStringTag,{value:"Module"}));async function js(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const o=n[r];if(typeof o!="number"){const a=o;e.push(a.data()),t.push(r),s.push(a)}}if(e.length>0){const r=await Promise.all(e);for(let o=0;o<r.length;++o)n[t[o]]=r[o][0];ye(s)}}function Xv(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var Ob;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(Ob||(Ob={}));const zL=125;class Lo{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Yv{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class ML extends Lo{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const o=t[r];if(typeof o=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+o*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;const i=B(()=>Y(this.totals[r],_(o,s)));this.totals[r]=i,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:B(()=>{const r=_(ue(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),pt(t[s])}))}}class Zv extends Lo{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const o in this.history){const a=this.history[o];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){const l=a[i];e.push(l.data()),t.push(o),s.push(i)}}const r=await Promise.all(e);for(let o=0;o<r.length;++o)this.history[t[o]][s[o]].dispose(),this.history[t[o]][s[o]]=r[o][0]}}class Jv extends Lo{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||$g,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=zL),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");vc(this.yieldEvery)&&(this.maybeWait=LF(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await js(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await js(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await js(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await js(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await js(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):vc(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await js(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await js(e),await this.trainEnd(e))}}function Qv(n,e){return n==null&&(n={}),n instanceof Lo?[n]:Array.isArray(n)&&n[0]instanceof Lo?n:_e(n).map(s=>new Jv(s,e))}class yn{constructor(){}static registerCallbackConstructor(e,t){I(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),yn.checkForDuplicate(t),yn.constructors[e]==null&&(yn.constructors[e]=[]),yn.constructors[e].push(t)}static checkForDuplicate(e){for(const t in yn.constructors)yn.constructors[+t].forEach(r=>{if(r===e)throw new P("Duplicate callback constructor.")})}static clear(){yn.constructors={}}static createCallbacks(e){const t=[];for(const s in yn.constructors){const r=+s;e>=r&&t.push(...yn.constructors[r])}return t.map(s=>new s)}}yn.constructors={};function e$(n,e,t,s,r,o,a,i,l){const u=new Zv,c=[new ML,...yn.createCallbacks(e)];n!=null&&c.push(...n),c.push(u);const h=new Yv(c);return h.setParams({epochs:t,initialEpoch:s,samples:r,steps:o,batchSize:a,verbose:e,doValidation:i,metrics:l}),{callbackList:h,history:u}}function Hn(n,e={},t=!1){return du(n,bn.getMap().classNameMap,e,"layer",t)}function _c(n,e){return B(()=>{n.dtype!=="float32"&&(n=ee(n,"float32"));const t=ie(fu(n),e,!0),s=lo(t.shape,ft()),r=$t(gs(t,s));return ue(n,r)})}function fo(n,e){return B(()=>Ye(fu(oe(e,n)),-1))}function rp(n,e){return B(()=>Ye(it(oe(e,n)),-1))}function Ga(n,e){return B(()=>{const t=oe(n,e),s=en(it(n),ft(),Number.MAX_VALUE),r=it(ue(t,s));return _(100,Ye(r,-1))})}function BL(n,e){return B(()=>{const t=en(e,ft(),Number.MAX_VALUE),s=dn(Y(1,t)),r=en(n,ft(),Number.MAX_VALUE),o=dn(Y(1,r));return Ye(fu(oe(s,o)),-1)})}function VL(n,e){return B(()=>{const t=gs(0,oe(1,_(n,e)));return Ye(fu(t),-1)})}function WL(n,e){return B(()=>{const t=gs(0,oe(1,_(n,e)));return Ye(t,-1)})}function UL(n,e){return B(()=>{const t=ie(_(n,e),-1),s=In(_(oe(1,n),e),-1);return gs(0,Y(1,oe(s,t)))})}function GL(n,e){return B(()=>{const t=Math.log(2),s=oe(e,n),r=oe(Y(s,uo(_(-2,s))),t);return Ye(r,-1)})}function Di(n,e,t=!1){return B(()=>{if(t)e=au(e);else{const s=ie(e,e.shape.length-1,!0);e=ue(e,s)}return e=en(e,ft(),1-ft()),Ue(ie(_(ee(n,"float32"),dn(e)),e.shape.length-1))})}function Fc(n,e,t=!1){return B(()=>{const s=ee(Ba(KF(n)),"int32");e=en(e,ft(),1-ft());const r=e.shape,o=L(Ro(s,r[r.length-1]),r);return Di(o,e,t)})}function HL(n,e){if(!Ce(n.shape,e.shape))throw new P(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return B(()=>{const t=Jn(e),s=Ue(it(e));return Y(oe(t,_(e,n)),Zl(tn(s)))})}function op(n,e){return B(()=>{let t;return t=en(e,ft(),1-ft()),t=dn(ue(t,oe(1,t))),Ye(HL(n,t),-1)})}function jL(n,e){return B(()=>{const t=en(n,ft(),1),s=en(e,ft(),1);return ie(_(n,dn(ue(t,s))),-1)})}function qL(n,e){return B(()=>{const t=dn(Y(ft(),e));return Ye(oe(e,_(n,t)),-1)})}function oy(n,e){return B(()=>{const t=_c(n,-1),s=_c(e,-1),r=_(t,s);return Ue(ie(r,-1))})}const Lc={meanSquaredError:fo,meanAbsoluteError:rp,meanAbsolutePercentageError:Ga,meanSquaredLogarithmicError:BL,squaredHinge:VL,hinge:WL,categoricalHinge:UL,logcosh:GL,categoricalCrossentropy:Di,sparseCategoricalCrossentropy:Fc,binaryCrossentropy:op,kullbackLeiblerDivergence:jL,poisson:qL,cosineProximity:oy};function Dp(n){if(typeof n=="string"){if(n in Lc)return Lc[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new P(e)}else return n}function ay(n,e){return B(()=>{const t=_(.5,pn(e)),s=us(qt(e,t),n.dtype);return Ye(hn(n,s),-1)})}function iy(n,e){return B(()=>us(hn(Gr(n,-1),Gr(e,-1)),"float32"))}function t$(n,e){return B(()=>ee(ie(On(hn(n,1),hn(e,1))),"float32"))}function KL(n,e){return B(()=>ee(ie(On(hn(n,1),hn(e,0))),"float32"))}function XL(n,e){return B(()=>ee(ie(On(hn(n,0),hn(e,1))),"float32"))}function n$(n,e){return B(()=>{const t=t$(n,e),s=XL(n,e),r=Y(t,s);return ee(wt(qt(r,0),ue(t,r),0),"float32")})}function YL(n,e){return B(()=>{const t=t$(n,e),s=KL(n,e),r=Y(t,s);return ee(wt(qt(r,0),ue(t,r),0),"float32")})}function s$(n,e){return op(n,e)}function r$(n,e){return n.rank===e.rank&&(n=br(n,[n.rank-1])),e=Gr(e,-1),e.dtype!==n.dtype&&(e=ee(e,n.dtype)),ee(hn(n,e),"float32")}function ZL(n,e){return B(()=>{const t=n.sub(e).square().sum(),s=n.sub(n.mean()).square().sum();return he(1).sub(t.div(s))})}const JL=fo,QL=fo,eP=rp,tP=rp,nP=Ga,sP=Ga,ly=Di,rP=oy,o$=Fc,Pc={binaryAccuracy:ay,categoricalAccuracy:iy,precision:n$,categoricalCrossentropy:ly,sparseCategoricalCrossentropy:o$,mse:JL,MSE:QL,mae:eP,MAE:tP,mape:nP,MAPE:sP,cosine:rP};function oP(n){if(typeof n=="string"&&n in Pc)return Pc[n];if(typeof n!="string"&&n!=null)return n;throw new P(`Unknown metric ${n}`)}function _u(n){if(ns(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Lc))if(Lc[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Pc))if(Pc[t]===n){e=t;break}return e!==void 0?e:n.name}}function aP(n){const e={Adagrad:()=>kr.adagrad(.01),Adadelta:()=>kr.adadelta(1,.95,ft()),Adam:()=>kr.adam(.001,.9,.999,ft()),Adamax:()=>kr.adamax(.002,.9,.999,ft(),0),RMSProp:()=>kr.rmsprop(.001,.9,0,ft()),SGD:()=>kr.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new P(`Unknown Optimizer ${n}`)}const _b=1*1024*1024;function Fb(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!ff(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>_b&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${_b}.`)}}function ff(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!ff(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!ff(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function iP(n,e,t,s=console.log){const r=uP(n),o=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let a;if(!r){o.push("Receives inputs"),a=[];for(const c in n.nodesByDepth)a.push(...n.nodesByDepth[c])}s("_".repeat(e)),zc(o,t,s),s("=".repeat(e));const i=n.layers;for(let c=0;c<i.length;++c)r?cP(i[c],t,s):hP(i[c],t,a,s),s((c===i.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=lP(n),u=Rc(n.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}function lP(n){let e;return n.collectedTrainableWeights!=null?e=Rc(n.collectedTrainableWeights):e=Rc(n.trainableWeights),e}function uP(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let o=!1;for(const a of r.inboundNodes)if(s.indexOf(a)!==-1)if(o){e=!1;break}else o=!0;if(!e)break}return e}function zc(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function cP(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=n.name,a=n.getClassName(),i=[`${o} (${a})`,r,s,n.countParams().toString()];zc(i,e,t)}function hP(n,e,t,s){let r,o;try{o=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const a=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],m=h.tensorIndices[d];a.push(`${p}[${f}][${m}]`)}const i=n.name,l=n.getClassName(),u=a.length===0?"":a[0],c=[`${i} (${l})`,o,r,n.countParams().toString(),u];zc(c,e,s);for(let h=1;h<a.length;++h)zc(["","","","",a[h]],e,s)}function a$(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Oi(n,e){if(n===null)return null;if(typeof n=="string")return Ar(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const o=n[r];a$(e,r,o)?t.push(o):t.push(Oi(o,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const o=Ar(s);t[o]=Oi(r,o)}}return t}}function mf(n,e){if(n==null)return null;if(typeof n=="string")return ws(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const o=n[r];a$(e,r,o)?t.push(o):t.push(mf(o,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],o=ws(s);(s==="name"||s==="className")&&typeof r=="string"?t[o]=r:t[o]=mf(r,s)}return t}}const ap="4.22.0";const dP=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Mn extends Ne{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const x=this.getClassName().toLowerCase();this.name=Kd(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],er(this.inputs).length!==this.inputs.length)throw new P(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);er(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const x of this.outputs){const w=x.sourceLayer,b=x.nodeIndex,$=x.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(b),this.outputLayersTensorIndices.push($)}for(const x of this.inputs){const w=x.sourceLayer,b=x.nodeIndex,$=x.tensorIndex;ns(b===0,"input layer has >1 nodes"),ns($===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(b),this.inputLayersTensorIndices.push($)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){const w=this.inputLayers[x];if(!(w instanceof Ua))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(const x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);const t={},s={},r={},o={},a={},i=[],l=(x,w,b,$,N,T)=>{($==null||N==null||T==null)&&($=x.sourceLayer,N=x.nodeIndex,T=x.tensorIndex);const A=$.inboundNodes[N];if(b.indexOf(A)!==-1)throw new Dn(`The tensor ${x.name} at layer "${$.name}" is part of a cycle.`);if(w.indexOf(A)!==-1)return;this.containerNodes.add(Mn.nodeKey($,N)),$.id in a||(a[$.id]=Object.keys(a).length),b.indexOf(A)===-1&&b.push(A);const k=A.inboundLayers.length;for(let E=0;E<k;E++){const S=A.inputTensors[E],D=A.inboundLayers[E],F=A.nodeIndices[E],z=A.tensorIndices[E];l(S,w,b,D,F,z)}for(w.push(A);b.indexOf(A)>=0;)b.splice(b.indexOf(A),1);i.push(A)},u=[],c=[];for(const x of this.outputs)l(x,u,c);const h=i.slice().reverse();for(const x of h){s[x.id]=x,x.id in t||(t[x.id]=0);let w=t[x.id];const b=r[x.outboundLayer.id]==null?0:r[x.outboundLayer.id];w=Math.max(w,b),r[x.outboundLayer.id]=w,o[x.outboundLayer.id]=x.outboundLayer,t[x.id]=w;for(let $=0;$<x.inboundLayers.length;$++){const N=x.inboundLayers[$],T=x.nodeIndices[$],A=N.inboundNodes[T],k=t[A.id]==null?0:t[A.id];t[A.id]=Math.max(w+1,k),s[A.id]=A}}const d={};for(const x in t){const w=t[x];w in d||(d[w]=[]),d[w].push(s[x])}const p={};for(const x in r){const w=r[x];w in p||(p[w]=[]),p[w].push(o[x])}let f=Object.keys(p).map(x=>parseInt(x,10)).sort(Ru);this.layers=[];for(const x of f){const w=p[x];w.sort((b,$)=>{const N=a[b.id],T=a[$.id];return N<T?-1:N>T?1:0});for(const b of w)b instanceof Mn&&this.internalContainerRefs.push(b),this.layers.push(b)}this.layersByDepth=p,f=Object.keys(d).map(x=>parseInt(x,10)).sort(Ru);const m=this.inputs.slice(),g=[];for(const x of f)for(const w of d[x]){const b=w.outboundLayer;if(b!=null){for(const $ of w.inputTensors)if(m.indexOf($)===-1)throw new Dn(`Graph disconnected: cannot obtain value for tensor ${$} at layer "${b.name}". The following previous layers were accessed without issue: ${g}`);for(const $ of w.outputTensors)m.push($);g.push(b.name)}}this.nodesByDepth=d;const y=this.layers.map(x=>x.name);for(const x of y){const w=y.filter(b=>b===x).length;if(w!==1)throw new Dn(`The name "${x}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new sp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new P("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const o=dP(e);o&&this.parseWeights(e);for(const i of this.layers)for(const[l,u]of i.weights.entries()){const c=o?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(s[c]!=null)throw new P(`Duplicate weight name: ${c}`);s[c]=u,r++}const a=[];for(const i in e){let l=i;if(s[i]==null){const u=i.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(s[l]!=null)a.push([s[l],e[i]]);else if(t)throw new P(`Provided weight data has no target variable: ${i}`);delete s[l]}if(t){const i=[];for(const l in s)i.push(l);if(i.length>0)throw new P(`${i.length} of ${r} weights are not set: ${i}`)}Qg(a)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],o=s.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!r.includes(a)).join("/");o!==t&&(e[o]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${ap}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=mf(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return B(()=>{e=_e(e);const s=new Xs;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return di(this.outputs,s,t)})}computeMask(e,t){return B(()=>{e=_e(e);let s;return t==null?s=Yr(null,e.length):s=_e(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=Ac(e);if(t.length!==this.inputLayers.length)throw new P(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let i=0;i<t.length;i++){const l=this.inputLayers[i],u=t[i],c=l.name+"_0_0";s[c]=u}const r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(Ru);if(r.length>1)for(const i of r){const l=this.nodesByDepth[i];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;const h=[];for(let m=0;m<u.inboundLayers.length;m++){const g=u.inboundLayers[m],y=u.nodeIndices[m],x=u.tensorIndices[m],w=`${g.name}_${y}_${x}`,b=s[w];h.push(b)}const d=c.computeOutputShape(Xt(h)),p=Ac(d),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++){const g=`${c.name}_${f}_${m}`;s[g]=p[m]}}}const o=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const l=this.outputLayers[i],u=this.outputLayersNodeIndices[i],c=this.outputLayersTensorIndices[i],h=`${l.name}_${u}_${c}`;a.push(h)}for(let i=0;i<a.length;i++){const l=a[i];ns(l in s),o.push(s[l])}return Xt(o)}runInternalGraph(e,t){t==null&&(t=Yr(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=t[l];s[u.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Ru);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,d=c.inputTensors,p=c.outputTensors,f=new Array;for(const m of d)m.id in s&&f.push(s[m.id]);if(f.length===d.length){let m={},g,y,x,w;if(c.callArgs!=null&&(m=c.callArgs),f.length===1){const[b,$]=f[0];m.mask==null&&(m.mask=$),x=_e(h.call(b,m)),w=_e(h.computeMask(b,$)),g=[b],y=[$]}else g=f.map(b=>b[0]),y=f.map(b=>b[1]),m.mask==null&&(m.mask=y),x=_e(h.call(g,m)),w=_e(h.computeMask(g,y));if(h.activityRegularizer)throw new be("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let b=0;b<p.length;++b){const $=p[b],N=x[b],T=w[b];s[$.id]=[N,T]}}}}const o=[],a=[],i=[];for(const l of this.outputs){ns(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];i.push(u.shape),o.push(u),a.push(c)}return[o,a,i]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof Mn?1:0;for(let o=0;o<r.inboundNodes.length;o++){const a=Mn.nodeKey(r,o);this.containerNodes.has(a)&&(t[a]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new P("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new P(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new P(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return B(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=Mn.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const i=a.getClassName(),l=a.getConfig(),u=[];for(let h=0;h<a.inboundNodes.length;h++){const d=a.inboundNodes[h],p=Mn.nodeKey(a,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const m=[];for(let g=0;g<d.inboundLayers.length;g++){const y=d.inboundLayers[g],x=d.nodeIndices[g],w=d.tensorIndices[g],b=Mn.nodeKey(y,x);let $=t[b];$==null&&($=0),m.push([y.name,$,w,f])}u.push(m)}}}const c={};c.name=a.name,c.className=i,c.config=l,c.inboundNodes=u,s.push(c)}e.layers=s;const r=[];for(let a=0;a<this.inputLayers.length;a++){const i=this.inputLayers[a],l=this.inputLayersNodeIndices[a],u=Mn.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[a];r.push([i.name,c,h])}e.inputLayers=r;const o=[];for(let a=0;a<this.outputLayers.length;a++){const i=this.outputLayers[a],l=this.outputLayersNodeIndices[a],u=Mn.nodeKey(i,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[a];o.push([i.name,c,h])}return e.outputLayers=o,e}static fromConfig(e,t,s={},r=!1){const o={},a={};function i(g,y){g.name in a?a[g.name].push(y):a[g.name]=[y]}function l(g,y){const x=[];let w;for(const b of y){const $=b[0],N=b[1],T=b[2];if(w=b[3]==null?{}:b[3],!($ in o)){i(g,y);return}const A=o[$];if(A.inboundNodes.length<=N){i(g,y);return}const k=A.inboundNodes[N];x.push(k.outputTensors[T])}x.length>0&&g.apply(Xt(x),w)}function u(g){const y=g.name,x=Hn(g,t.customObjects!=null?t.customObjects:{});x.setFastWeightInitDuringBuild(r),o[y]=x,g.inboundNodes.forEach(b=>{if(!(b instanceof Array))throw new P(`Corrupted configuration, expected array for nodeData: ${b}`);i(x,b)})}const c=t.name,h=t.layers;for(const g of h)u(g);for(;!FF(a);)for(const g of h){const y=o[g.name];if(y.name in a){const x=a[y.name];delete a[y.name];for(const w of x)l(y,w)}}const d=[],p=[],f=t.inputLayers;for(const g of f){const y=g[0],x=g[1],w=g[2];ns(y in o);const $=o[y].inboundNodes[x].outputTensors;d.push($[w])}const m=t.outputLayers;for(const g of m){const y=g[0],x=g[1],w=g[2];ns(y in o);const $=o[y].inboundNodes[x].outputTensors;p.push($[w])}return new e({inputs:d,outputs:p,name:c})}get stateful(){if(this._stateful)throw new P("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function pP(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(o=>{o in n?r.push(n[o]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function i$(n,e){return pP(n,e,"classWeight")}async function l$(n,e,t,s){if(t!=null){const r=B(()=>{if(n.shape.length===1)return is(n);if(n.shape.length===2){if(n.shape[1]>1)return Gr(n,1);if(n.shape[1]===1)return L(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await r.data());ye(r);const a=[];return o.forEach(i=>{if(t[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(t[i])}),Rt(a,"float32")}else return null}function fP(n,e){return _(n,e)}const mP=32;function u$(n,e){let t,s;const r=e;t=r.xs,s=r.ys,I(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const o=Lb("input",n.inputNames,t),a=Lb("output",n.outputNames,s),i=o[0].shape[0];I(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),I(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<o.length;l++)I(o[l].shape[0]===i,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${o[l].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);for(let l=0;l<a.length;l++)I(a[l].shape[0]===i,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${a[l].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);return{xs:o,ys:a}}function Lb(n,e,t){if(t instanceof Ae)return[t];if(Array.isArray(t))return I(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new P(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function gP(n){if(n.length===3)throw new be("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function yP(n,e,t){const s=t.batchesPerEpoch!=null;if(I(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),I(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),I(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),I(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),I(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let o,a;if(r)if(Pb(t.validationData))I(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const g=gP(t.validationData);o=g.xs,a=g.ys}const i=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();const c=Qv(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=e$(c,h,t.epochs,null,null,xP(e,t),null,r,u);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,m=await e.iterator();for(;f<t.epochs;){const g={};await d.onEpochBegin(f);let y=0,x=0;for(s||(m=await e.iterator());!s||y<t.batchesPerEpoch;){const w=await m.next();if(s&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){const{xs:b,ys:$}=u$(n,w.value),N={};N.batch=x,N.size=b[0].shape[0],await d.onBatchBegin(x,N);const T=[];if(t.classWeight!=null){const E=i$(t.classWeight,n.outputNames);for(let S=0;S<E.length;++S)T.push(await l$($[S],null,E[S]))}const A=b.concat($).concat(T),k=i(A);ye(A);for(let E=0;E<l.length;++E){const S=l[E],D=k[E];N[S]=D,pt(D)}await d.onBatchEnd(x,N),Xv(N),x++,y++}if(s?y>=t.batchesPerEpoch:w.done){if(r){let b;Pb(t.validationData)?b=_e(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):b=_e(n.evaluate(o,a,{batchSize:t.validationBatchSize==null?mP:t.validationBatchSize,verbose:0}));for(let $=0;$<n.metricsNames.length;++$)g[`val_${n.metricsNames[$]}`]=b[$]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,g),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function xP(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function Pb(n){return typeof n.iterator=="function"}function bP(n){return typeof n.next=="function"}async function wP(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let o=[];if(t.verbose>0)throw new be("Verbose mode is not implemented yet.");I(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=bP(e)?e:await e.iterator();let i=0,l=0;for(;!s||l<t.batches;){const u=await a.next();if(o=B(()=>{if(u.value){const{xs:c,ys:h}=u$(n,u.value),d=c.concat(h),p=B(()=>r(d));if(ye(d),l===0)for(let m=0;m<p.length;++m)o.push(he(0));const f=d[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],y=o[m];o[m]=B(()=>Y(o[m],_(f,g))),l>0&&ye(y)}ye(p),i+=f,++l}return o}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=ue(o[u],i),ye(c)}return Xt(o)}function Op(n){I(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function ai(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Mr(s,e,t-e)):Mr(n,e,t-e)}function gf(n,e){return B(()=>n==null?null:Array.isArray(n)?n.map(t=>gf(t,e)):Gv(n,e.dtype==="int32"?e:ee(e,"int32")))}function _p(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function c$(n){const e=[];n instanceof Ae&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(pu(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function zn(n,e){if(n==null)return;const t=[];if(e instanceof Ae)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const o=e[r];t.push(o.id)}const s=[];if(n instanceof Ae)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const o=n[r];t.indexOf(o.id)===-1&&s.push(o)}s.forEach(r=>{r.isDisposed||r.dispose()})}function vP(n){return n instanceof Ae}function yf(n){return Array.isArray(n)}function zb(n){return!vP(n)&&!yf(n)}function Mb(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(yf(n)&&n.length>0)a=!0;else if(zb(n)){for(const i in n)if(n.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new P(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let o;if(zb(n)){n=n,o=[];for(const a of e){if(n[a]==null)throw new P(`No data provided for "${a}". Need data for each key in: ${e}`);o.push(n[a])}}else if(yf(n)){if(n=n,n.length!==e.length)throw new P(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(n=n,e.length>1)throw new P(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=c$(o),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const i=o[a];if(i.shape.length!==t[a].length)throw new P(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${i.shape}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const u=i.shape[l],c=t[a][l];if(c!=null&&c>=0&&u!==c)throw new P(`${r} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${r} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return o}function $P(n,e,t){const s=er(n.map(o=>o.shape[0]));s.sort();const r=er(e.map(o=>o.shape[0]));if(r.sort(),s.length>1)throw new P(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>1)throw new P(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>0&&r.length>0&&!Ce(s,r))throw new P(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function SP(n,e,t){const s=[fo,op,Di];for(let r=0;r<n.length;++r){const o=n[r],a=e[r],i=t[r];if(a!=null){if(a===Di&&o.shape[o.shape.length-1]===1)throw new P(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const l=o.shape.slice(1),u=i.slice(1);for(let c=0;c<l.length;++c){const h=l[c],d=u[c];if(d!=null&&h!==d)throw new P(`A target Tensor with shape ${o.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Bb(n,e,t,s=!0,r=""){let o;if(Array.isArray(n)){if(n.length!==e.length)throw new P(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(e.length>1)throw new P(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const i=o[a];if(i.shape.length!==t[a].length)throw new P(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const u=i.shape[l],c=t[a][l];if(c!=null&&c!==u)throw new P(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function IP(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let o=t.hasOwnProperty(r)?t[r]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}const NP="layers-model";class Ns extends Mn{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new P("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");iP(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=aP(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Bs))throw new P("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new P(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(Dp(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new P(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>Dp(i))}else{const a=Dp(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const i=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],zr("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const r=IP(e.metrics,this.outputNames),o=(a,i,l)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([l,a])};zr("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const i=r[a];(u=>{let h,d,p;for(const f of u){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===op?["accuracy","acc"].indexOf(f)!==-1?d=ay:["crossentropy","ce"].indexOf(f)!==-1&&(d=s$):this.lossFunctions[a]===Fc?["accuracy","acc"].indexOf(f)!==-1?d=r$:["crossentropy","ce"].indexOf(f)!==-1&&(d=o$):["accuracy","acc"].indexOf(f)!==-1?d=iy:["crossentropy","ce"].indexOf(f)!==-1&&(d=ly);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=d,h=""+y}else p=oP(f),h=""+_u(f);let m;zr(h,()=>{m=p}),o(a,h,m)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;Op(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const i=a[0].concat(a[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,i,r,s.verbose,s.steps);return Xt(u)}finally{zn(a[0],e),zn(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),wP(this,e,t)}checkNumSamples(e,t,s,r="steps"){let o;if(s!=null){if(o=null,t!=null)throw new P(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?o=e[0].shape[0]:o=e.shape[0];else throw new P(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return o}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new P("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],o=this.retrieveSymbolicTensors(r),a=new Xs;if(e instanceof Ae&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new P(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new P(`No value is provided for the model's input ${l.name}`);a.add(l,u)}const i=di(o,a);return s?i:i[0]}retrieveSymbolicTensors(e){const t=Yr(null,e.length);let s=e.length;for(const r of this.layers){const o=Array.isArray(r.output)?r.output:[r.output],a=o.map(i=>i.name);for(let i=0;i<e.length;++i){const l=a.indexOf(e[i]);if(l!==-1&&(t[i]=o[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((o,a)=>{o==null&&r.push(e[a])}),new P(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return B(()=>{const r=this.checkNumSamples(e);if(s)throw new be("Verbose predictLoop() is not implemented yet.");const o=_p(r,t),a=this.outputs.map(i=>[]);for(let i=0;i<o.length;++i)B(()=>{const u=o[i][0],c=o[i][1],h=ai(e,u,c),d=[];if(Array.isArray(h))for(let f=0;f<h.length;++f)d.push({key:this.inputs[f],value:h[f]});else d.push({key:this.inputs[0],value:h});const p=new Xs(d);return di(this.outputs,p)}).forEach((u,c)=>a[c].push(u));return Xt(a.map(i=>nt(i,0)))})}predict(e,t={}){const s=c$(e);Bb(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return Op(r),this.predictLoop(s,r)}finally{zn(s,e)}}predictOnBatch(e){Bb(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new Dn("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const i=this.feedOutputShapes[a];this.feedLossFns[a]===Fc?o.push(i.slice(0,i.length-1).concat([1])):o.push(i)}if(e=Mb(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Mb(t,this.feedOutputNames,o,!1,"target"),$P(e,t),SP(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new P(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,o=!0,a){const[i,l]=this.standardizeUserDataXY(e,t,o,a);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=i$(r,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await l$(l[h],null,c[h]))}return[i,l,u]}testLoop(e,t,s,r=0,o){return B(()=>{const a=this.checkNumSamples(t,s,o,"steps"),i=[];if(r>0)throw new be("Verbose mode is not implemented yet.");if(o!=null)throw new be("steps mode in testLoop() is not implemented yet");{const l=_p(a,s),u=Rt(qn(0,a));for(let c=0;c<l.length;++c){const h=l[c][0],d=l[c][1],p=Mr(u,h,d-h),f=gf(t,p),m=e(f);if(c===0)for(let g=0;g<m.length;++g)i.push(he(0));for(let g=0;g<m.length;++g){const y=m[g];i[g]=Y(i[g],_(d-h,y))}}for(let c=0;c<i.length;++c)i[c]=ue(i[c],a)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let o=r;if(Ib(e,r)>1){const a=Ib(e.slice(0,s),r);o+=`_${a}`}t.push(o)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:s[m]});const d=new Xs(h),p=di(this.outputs,d,{training:!0});let f;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(r[m],p[m]);o[m]!=null&&(y=fP(y,o[m]));const x=Ye(y);t.push(x),m===0?f=y:f=Y(f,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{const y=this.metricsTensors[m][0],x=this.metricsTensors[m][1];g=Ye(y(r[x],p[x]))}pt(g),a.push(g)}return f=Ye(f),this.calculateLosses().forEach(m=>{f=Y(f,m)}),f},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(i,!0,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>B(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:r[u]});const i=new Xs(a),l=di(this.outputs,i);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=Ye(c(o[u],l[u]));u===0?s=h:s=Y(s,h),t.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],d=Ye(c(o[h],l[h]));t.push(d)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,o,a,i,l,u,c,h,d;try{const p=s.batchSize==null?32:s.batchSize;Op(p);const m=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,p);r=m[0],o=m[1],d=m[2];let g=!1,y;if(s.validationData!=null&&s.validationData.length>0){if(g=!0,s.validationData.length===2)l=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new be("validationData including sample weights is not supported yet."):new P(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const E=await this.standardizeUserData(l,u,null,null,!0,p);c=E[0],h=E[1],y=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){g=!0;const k=Math.floor(r[0].shape[0]*(1-s.validationSplit)),E=r[0].shape[0];c=ai(r,k,E),a=r,r=ai(r,0,k),h=ai(o,k,E),i=o,o=ai(o,0,k),y=c.concat(h)}else s.validationSteps!=null&&(g=!0);const x=r.concat(o).concat(d);this.checkTrainableWeightsConsistency();const w=this.makeTrainFunction(),b=this.getDedupedMetricsNames();let $,N;g?(this.makeTestFunction(),$=this.testFunction,N=b.slice().concat(b.map(k=>"val_"+k))):($=null,y=[],N=b.slice());const T=Qv(s.callbacks,s.yieldEvery);return await this.fitLoop(w,x,b,p,s.epochs,s.verbose,T,$,y,s.shuffle,N,s.initialEpoch,null,null)}finally{this.isTraining=!1,zn(r,e),zn(o,t),zn(a,e),zn(i,t),zn(c,l),zn(h,u),d!=null&&ye(d)}}async fitLoop(e,t,s,r,o,a,i,l,u,c,h,d,p,f){r==null&&(r=32),o==null&&(o=1),c==null&&(c=!0),d==null&&(d=0);let m=!1;if(l!=null&&u!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new P("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,r,p,"steps_per_epoch");let y;g!=null&&(y=qn(0,g)),a==null&&(a=1);const{callbackList:x,history:w}=e$(i,a,o,d,g,p,r,m,h);x.setModel(this),this.history=w,await x.onTrainBegin(),this.stopTraining_=!1;for(let b=d;b<o;++b){await x.onEpochBegin(b);const $={};if(p!=null)throw new be("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new be("batch shuffling is not implemneted yet");c&&Mf(y);const N=Rt(y),T=_p(g,r);for(let A=0;A<T.length;++A){const k={};if(await x.onBatchBegin(A,k),B(()=>{const E=T[A][0],S=T[A][1],D=Mr(N,E,S-E);k.batch=A,k.size=S-E;const F=gf(t,D),z=e(F);for(let M=0;M<s.length;++M){const W=s[M],j=z[M];k[W]=j,pt(j)}if(A===T.length-1&&m){const M=this.testLoop(l,u,r);for(let W=0;W<s.length;++W){const j=s[W],U=M[W];pt(U),$["val_"+j]=U}}}),await x.onBatchEnd(A,k),Xv(k),this.stopTraining_)break}N.dispose()}if(await x.onEpochEnd(b,$),this.stopTraining_)break}return await x.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return yP(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],o=s[1],i=this.makeTrainFunction()(r.concat(o)),l=[];for(const u of i){const c=await u.data();l.push(c[0])}return ye(i),zn(s[0],e),zn(s[1],t),Xt(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||t.push({name:r[a].originalName,tensor:o[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=Yp().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Yp().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ws(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ws(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=ws(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ws(_u(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ws(_u(e)));{const e={};for(const t in this.metrics)e[t]=ws(_u(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Oi(e.optimizer_config),s=Hn(t);let r;if(typeof e.loss=="string")r=Ar(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>Ar(a));else if(e.loss!=null){r={};for(const a in e.loss)r[a]=Ar(e.loss[a])}let o;if(Array.isArray(e.metrics))o=e.metrics.map(a=>Ar(a));else if(e.metrics!=null){o={};for(const a in e.metrics)o[a]=Ar(e.metrics[a])}this.compile({loss:r,metrics:o,optimizer:s})}async save(e,t){if(typeof e=="string"){const u=Ew(e);if(u.length===0)throw new P(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new P(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new P("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Zp(this.getNamedWeights(t)),i={modelTopology:this.toJSON(null,!1),format:NP,generatedBy:`TensorFlow.js tfjs-layers v${ap}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await Zp(await this.optimizer.getWeights(),u);s.specs.push(...h),s.data=kw([s.data,c])}return this.userDefinedMetadata!=null&&(Fb(this.userDefinedMetadata,this.name,!0),i.userDefinedMetadata=this.userDefinedMetadata),i.weightData=s.data,i.weightSpecs=s.specs,e.save(i)}setUserDefinedMetadata(e){Fb(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ns.className="Model";Z(Ns);class h$ extends Ns{}h$.className="Functional";Z(h$);async function CP(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=Oi(t),r=Hn(s,e);if(n.weightsManifest!=null){const o=await G1(n.weightsManifest,n.pathPrefix,r.weights.map(i=>i.originalName)),a={};for(const i of r.weights)a[i.originalName]=o[i.originalName];r.loadWeights(a),ye(o)}return r}async function kP(n,e){if(e==null&&(e={}),typeof n=="string"){const t=Aw(n,e);if(t.length===0)t.push(q1(n,e));else if(t.length>1)throw new P(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return TP(n,void 0,e)}async function TP(n,e,t){if(t==null&&(t={}),n.load==null)throw new P("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const o=t.strict==null?!0:t.strict,a=s.weightData!=null&&s.weightSpecs!=null&&o,i=Hn(Oi(r),e,a),l=s.trainingConfig;if(l!=null&&i.loadTrainingConfig(l),s.userDefinedMetadata!=null&&i.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new P("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=EP(s.weightData,s.weightSpecs);i.loadWeights(u,o),i.optimizer!=null&&c.length>0&&await i.optimizer.setWeights(c),ye(u),ye(c.map(h=>h.tensor))}return i}function EP(n,e){const t=Zf(n,e),s={},r=[];return e.forEach(o=>{o.group==="optimizer"?r.push({name:o.name,tensor:t[o.name]}):s[o.name]=t[o.name]}),{modelWeights:s,optimizerWeights:r}}class Zr extends Ns{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Kd("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new P(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Zr||e instanceof Ns;let s;if(t){if(s=e,s.outputs.length!==1)throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new P("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new P("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=Kv({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new P(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new P("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=qv(this.outputs[0])}this.inboundNodes=[],new sp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Yr(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(De(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ns({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new Dn("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new Dn("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new Dn("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new Dn("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let o,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new P("Legacy serialization format not supported yet.");o=t}else I(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof Zr))throw new be(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const l of o){const c=Hn(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),i.add(c)}return i}set stopTraining(e){if(this.model==null)throw new P("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new P("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Zr.className="Sequential";Z(Zr);function AP(n){return new Ns(n)}function RP(n){return new Zr(n)}function d$(n){return Kv(n)}function DP(n,e){yn.registerCallbackConstructor(n,e)}let zt=class extends ho{getConfig(){return{}}};class p$ extends zt{apply(e,t=1){return YF(e,t)}}p$.className="elu";Z(p$);class f$ extends zt{apply(e){return Sd(e)}}f$.className="selu";Z(f$);class m$ extends zt{apply(e){return Jn(e)}}m$.className="relu";Z(m$);class g$ extends zt{apply(e){return B(()=>ir(6,Jn(e)))}}g$.className="relu6";Z(g$);class y$ extends zt{apply(e){return e}}y$.className="linear";Z(y$);class x$ extends zt{apply(e){return Gn(e)}}x$.className="sigmoid";Z(x$);class b$ extends zt{apply(e){return JF(e)}}b$.className="hardSigmoid";Z(b$);class w$ extends zt{apply(e){return uo(e)}}w$.className="softplus";Z(w$);class v$ extends zt{apply(e){return ZF(e)}}v$.className="softsign";Z(v$);class $$ extends zt{apply(e){return ar(e)}}$$.className="tanh";Z($$);let uy=class extends zt{apply(e,t=-1){return au(e,t)}};uy.className="softmax";Z(uy);class S$ extends zt{apply(e,t=-1){return gd(e,t)}}S$.className="logSoftmax";Z(S$);class I$ extends zt{apply(e){return B(()=>B(()=>{const t=Math.sqrt(2),s=_(.5,Y(1,pd(ue(e,t))));return _(e,s)}))}}I$.className="gelu";Z(I$);class N$ extends zt{apply(e){return B(()=>_(.5,_(e,Y(1,ar(_($t(ue(2,Math.PI)),Y(e,_(.044715,ps(e,3)))))))))}}N$.className="gelu_new";Z(N$);class C$ extends zt{apply(e){return B(()=>_(e,ar(uo(e))))}}C$.className="mish";Z(C$);class k$ extends zt{apply(e,t=1){return B(()=>_(Gn(_(e,t)),e))}}k$.className="swish";Z(k$);function ur(n){return n.getClassName()}function Fp(n,e={}){return du(n,bn.getMap().classNameMap,e,"activation")}function cr(n){if(n==null){const e={};return e.className="linear",e.config={},Fp(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},Fp(e)}else return n instanceof zt?n:Fp(n)}function cy(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class T$ extends ho{}class yu extends T${constructor(e){super(),cy(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return B(()=>{let t=lt([1]);return this.hasL1&&(t=Y(t,ie(_(this.l1,it(e))))),this.hasL2&&(t=Y(t,ie(_(this.l2,fu(e))))),L(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}yu.className="L1L2";Z(yu);function OP(n){return cy(n),new yu({l1:n!=null?n.l1:null,l2:0})}function _P(n){return cy(n),new yu({l2:n!=null?n.l2:null,l1:0})}const Vb={l1l2:"L1L2"};function Me(n){return Ug(n)}function Wb(n,e={}){return du(n,bn.getMap().classNameMap,e,"regularizer")}function qe(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in Vb?Vb[n]:n,config:{}};return Wb(t)}else return n instanceof T$?n:Wb(n)}class hy extends Ne{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=ge(e);let s=Jn(e);return this.maxValue!=null&&(s=en(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}hy.className="ReLU";Z(hy);class dy extends Ne{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=ge(e);return Yl(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}dy.className="LeakyReLU";Z(dy);class py extends Ne{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=je(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=qe(e.alphaRegularizer),this.alphaConstraint=gt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new P(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=De(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new ut({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=ge(e),su(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ze(this.alphaInitializer),alphaRegularizer:Me(this.alphaRegularizer),alphaConstraint:mt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}py.className="PReLU";Z(py);let fy=class extends Ne{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new be(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=ge(e);return za(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};fy.className="ELU";Z(fy);class my extends Ne{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=ge(e);return _(s,ee(qt(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}my.className="ThresholdedReLU";Z(my);class gy extends Ne{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new uy().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return B(()=>{let s=ge(e);const r=t.mask;if(r!=null){const o=_(oe(Yt(s.shape),ee(r,s.dtype)),he(-1e9));s=Y(s,o)}return this.axis instanceof Array?this.axis.length>1?tn(oe(s,Jl(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}gy.className="Softmax";Z(gy);function Co(n,e,t){if(typeof n=="number")return Yr(n,e);if(n.length!==e)throw new P(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!jF(r))throw new P(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function jn(n,e,t,s,r=1){if(n==null)return n;const o=e+(e-1)*(r-1);let a;return t==="same"?a=n:a=n-o+1,Math.floor((a+s-1)/s)}function ss(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+lr([t-e,0]);else if(s==="same")n=n*e;else throw new P(`Unsupport padding mode: ${s}.`);return n}function yy(n,e){return B(()=>(ot(e),e==="channelsFirst"?ke(n,[0,2,3,1]):n))}function E$(n,e){return B(()=>(ot(e),e==="channelsFirst"?ke(n,[0,2,3,4,1]):n))}function FP(n,e,t,s=1,r="valid",o,a=1){return B(()=>{if(o==null&&(o=Kn()),ot(o),n.shape.length!==3)throw new P(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new P(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new P(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(o==="channelsFirst"&&(n=ke(n,[0,2,1])),r==="causal")throw new be("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=ud(n,e,s,r==="same"?"same":"valid","NWC",a);return t!=null&&(i=Qn(i,t)),i})}function Ub(n,e,t,s=[1,1],r="valid",o,a,i=null){return B(()=>{if(o==null&&(o=Kn()),ot(o),n.rank!==3&&n.rank!==4)throw new P(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new P(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=yy(n,o);if(r==="causal")throw new be("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=A1({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:i}),o==="channelsFirst"&&(l=ke(l,[0,3,1,2])),l})}function LP(n,e,t,s=[1,1,1],r="valid",o,a){return B(()=>{if(o==null&&(o=Kn()),ot(o),n.rank!==4&&n.rank!==5)throw new P(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new P(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let i=E$(n,o);if(r==="causal")throw new be("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=$m(i,e,s,r==="same"?"same":"valid","NDHWC",a),t!=null&&(i=Qn(i,t)),o==="channelsFirst"&&(i=ke(i,[0,4,1,2,3])),i})}class ip extends Ne{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",ip.verifyArgs(t),this.rank=e,bt(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new be(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Co(t.kernelSize,e,"kernelSize"),this.strides=Co(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,kn(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ot(this.dataFormat),this.activation=cr(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=je(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=gt(t.biasConstraint),this.biasRegularizer=qe(t.biasRegularizer),this.activityRegularizer=qe(t.activityRegularizer),this.dilationRate=Co(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new P(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new P(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new P(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ns("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Gg(e.kernelSize,"number",1,3))throw new P(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ur(this.activation),useBias:this.useBias,biasInitializer:Ze(this.biasInitializer),biasRegularizer:Me(this.biasRegularizer),activityRegularizer:Me(this.activityRegularizer),biasConstraint:mt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Ha extends ip{constructor(e,t){super(e,t),this.kernel=null,Ha.verifyArgs(t),this.filters=t.filters,bt(this.filters,"filters"),this.kernelInitializer=je(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=gt(t.kernelConstraint),this.kernelRegularizer=qe(t.kernelRegularizer)}build(e){e=De(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new P(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return B(()=>{e=ge(e);let s;const r=this.bias==null?null:this.bias.read(),o=zv(this.activation.getClassName());if(o!=null&&this.rank===2)s=Ub(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=FP(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=Ub(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=LP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new be("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=De(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let o=0;o<s.length;++o){const a=jn(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Ze(this.kernelInitializer),kernelRegularizer:Me(this.kernelRegularizer),kernelConstraint:mt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new P(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class ja extends Ha{constructor(e){super(2,e),ja.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Gg(e.kernelSize,"number",1,2))throw new P(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}ja.className="Conv2D";Z(ja);class qa extends Ha{constructor(e){super(3,e),qa.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new P(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}qa.className="Conv3D";Z(qa);class xy extends ja{constructor(e){if(super(e),this.inputSpec=[new ut({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new P(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=De(e),e.length!==4)throw new P("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new P("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ut({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return B(()=>{let s=ge(e);if(s.shape.length!==4)throw new P(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);const l=r[a],u=r[i],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=ss(l,d,c,this.padding),m=ss(u,p,h,this.padding),g=[o,f,m,this.filters];this.dataFormat!=="channelsLast"&&(s=ke(s,[0,2,3,1]));let y=cd(s,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=ke(y,[0,3,1,2])),this.bias!=null&&(y=Qn(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=De(e);const t=e.slice();let s,r,o;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3):(s=3,r=1,o=2);const a=this.kernelSize[0],i=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[s]=this.filters,t[r]=ss(t[r],l,a,this.padding),t[o]=ss(t[o],u,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}xy.className="Conv2DTranspose";Z(xy);class by extends qa{constructor(e){if(super(e),this.inputSpec=[new ut({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new P(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=De(e),e.length!==5)throw new P("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new P("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ut({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return B(()=>{let s=ge(e);if(s.shape.length!==5)throw new P(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let a,i,l;this.dataFormat==="channelsFirst"?(l=2,a=3,i=4):(l=1,a=2,i=3);const u=r[l],c=r[a],h=r[i],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],x=ss(u,m,d,this.padding),w=ss(c,g,p,this.padding),b=ss(h,y,f,this.padding),$=[o,x,w,b,this.filters];this.dataFormat!=="channelsLast"&&(s=ke(s,[0,2,3,4,1]));let N=Sm(s,this.kernel.read(),$,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=ke(N,[0,4,1,2,3])),this.bias!==null&&(N=Qn(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(e){e=De(e);const t=e.slice();let s,r,o,a;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3,a=4):(s=4,r=1,o=2,a=3);const i=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return t[s]=this.filters,t[r]=ss(t[r],c,i,this.padding),t[o]=ss(t[o],h,l,this.padding),t[a]=ss(t[a],d,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}by.className="Conv3DTranspose";Z(by);class A$ extends Ha{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new P("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new P("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new P(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=je(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=qe(t.depthwiseRegularizer),this.depthwiseConstraint=gt(t.depthwiseConstraint),this.pointwiseInitializer=je(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=qe(t.pointwiseRegularizer),this.pointwiseConstraint=gt(t.pointwiseConstraint)}build(e){if(e=De(e),e.length<this.rank+2)throw new P(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new P(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let i=0;i<this.rank;++i)o.push(1);o.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new ut({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return B(()=>{e=ge(e);let s;if(this.rank===1)throw new be("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ke(e,[0,2,3,1])),s=Id(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Qn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=ke(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ze(this.depthwiseInitializer),e.pointwiseInitializer=Ze(this.pointwiseInitializer),e.depthwiseRegularizer=Me(this.depthwiseRegularizer),e.pointwiseRegularizer=Me(this.pointwiseRegularizer),e.depthwiseConstraint=mt(this.depthwiseConstraint),e.pointwiseConstraint=mt(this.pointwiseConstraint),e}}A$.className="SeparableConv";class wy extends A${constructor(e){super(2,e)}}wy.className="SeparableConv2D";Z(wy);class xu extends Ha{constructor(e){super(1,e),xu.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Gg(e.kernelSize,"number",1,1))throw new P(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}xu.className="Conv1D";Z(xu);class vy extends Ne{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return B(()=>{if(e=ge(e),this.dataFormat==="channelsLast"){const s=Ou(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ou(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Ou(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ou(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}vy.className="Cropping2D";Z(vy);class $y extends Ne{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ot(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,UF(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return B(()=>{let s=ge(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=ke(s,[0,2,3,1]);const o=this.size[0]*r[2],a=this.size[1]*r[3],i=this.interpolation==="nearest"?Rn.resizeNearestNeighbor(s,[o,a]):Rn.resizeBilinear(s,[o,a]);return ke(i,[0,3,1,2])}else{const o=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?Rn.resizeNearestNeighbor(s,[o,a]):Rn.resizeBilinear(s,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}$y.className="UpSampling2D";Z($y);function PP(n,e,t=[1,1],s="valid",r,o){return B(()=>{r==null&&(r=Kn()),ot(r);let a=yy(n,r);if(n.rank!==4)throw new P(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new P(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Pa(a,e,t,s==="same"?"same":"valid","NHWC",o),r==="channelsFirst"&&(a=ke(a,[0,3,1,2])),a})}class Sy extends ip{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=je(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=gt(e.depthwiseConstraint),this.depthwiseRegularizer=qe(e.depthwiseRegularizer)}build(e){if(e=De(e),e.length<4)throw new P(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new P(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{e=ge(e);let s=PP(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Qn(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=De(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=jn(t,this.kernelSize[0],this.padding,this.strides[0]),a=jn(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,o,a]:[e[0],o,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ze(this.depthwiseInitializer),e.depthwiseRegularizer=Me(this.depthwiseRegularizer),e.depthwiseConstraint=mt(this.depthwiseRegularizer),e}}Sy.className="DepthwiseConv2D";Z(Sy);function R$(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new P("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(o){return o==null||Array.isArray(o)?o:[o]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function D$(n,e,t,s=!1,r,o,a=!1,i=!1){return B(()=>{const l=e.shape.length;if(l<3)throw new P(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(qn(2,l));e=ke(e,u),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=ee(ee(r,"bool"),"float32"),r.rank===l-1&&(r=Tt(r,-1)),r=ke(r,u)),s&&(e=Nn(e,0),r!=null&&(r=Nn(r,0)));const c=[];let h,d=t;const p=e.shape[0],f=Cn(e);let m;r!=null&&(m=Cn(r));for(let y=0;y<p;++y){const x=f[y],w=B(()=>n(x,d));if(r==null)h=w[0],d=w[1];else{const b=B(()=>{const $=m[y],N=oe(pn($),$),T=Y(_(w[0],$),_(d[0],N)),A=d.map((k,E)=>Y(_(w[1][E],$),_(k,N)));return{output:T,newStates:A}});h=b.output,d=b.newStates}i&&c.push(h)}let g;return i&&(g=Gt(c,1)),[h,g,d]})}class es extends Ne{constructor(e){super(e);let t;if(e.cell==null)throw new P("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new cp({cells:e.cell}):t=e.cell,t.stateSize==null)throw new P("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new ut({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return qn(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){df(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const o=[];for(const a of t)o.push([e[0],a]);return[r].concat(o)}else return r}computeMask(e,t){return B(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(o=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new be("Constants support is not implemented in RNN yet.");df(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new ut({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!Ce(this.stateSpec.map(a=>a.shape[a.shape.length-1]),o))throw new P(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(a=>new ut({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){B(()=>{if(!this.stateful)throw new ts("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>lt([s,r])):this.states_=[lt([s,this.cell.stateSize])];else if(e==null)ye(this.states_),this.keptStates!=null&&(ye(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>lt([s,r])):this.states_[0]=lt([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):ye(this.states_);for(let r=0;r<this.states_.length;++r){const o=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,i=[s,a];if(!Ce(o.shape,i))throw new P(`State ${r} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${o.shape}`);this.states_[r]=o}}this.states_=this.states_.map(r=>pt(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const o=R$(e,s,r,this.numConstants);e=o.inputs,s=o.initialState,r=o.constants;let a=[],i=[];if(s!=null){t.initialState=s,a=a.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new ut({shape:u.shape}));i=i.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof Xn){const u=[e].concat(a),c=this.inputSpec.concat(i),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return B(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let o=t==null?null:t.initialState;e=ge(e),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new P(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},u=D$((f,m)=>{const g=this.cell.call([f].concat(m),i);return[g[0],g.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),c=u[0],h=u[1],d=u[2];this.stateful&&this.resetStates(d,r);const p=this.returnSequences?h:c;return this.returnState?[p].concat(d):p})}getInitialState(e){return B(()=>{let t=lt(e.shape);return t=ie(t,[1,2]),t=pu(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?cf(t,[1,s]):t):this.cell.stateSize>1?[cf(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===es.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,o=Hn(r,s);return new e(Object.assign(t,{cell:o}))}}es.className="RNN";Z(es);class bu extends Ne{}class lp extends bu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,bt(this.units,"units"),this.activation=cr(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=je(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=je(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=je(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qe(e.kernelRegularizer),this.recurrentRegularizer=qe(e.recurrentRegularizer),this.biasRegularizer=qe(e.biasRegularizer),this.kernelConstraint=gt(e.kernelConstraint),this.recurrentConstraint=gt(e.recurrentConstraint),this.biasConstraint=gt(e.biasConstraint),this.dropout=Fo([1,lr([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fo([1,lr([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=De(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new P(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hr({ones:()=>pn(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hr({ones:()=>pn(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let o;const a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?o=cs(_(e,a),this.kernel.read()):o=cs(e,this.kernel.read()),this.bias!=null&&(o=Qn(o,this.bias.read())),i!=null&&(s=_(s,i));let l=Y(o,cs(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ur(this.activation),useBias:this.useBias,kernelInitializer:Ze(this.kernelInitializer),recurrentInitializer:Ze(this.recurrentInitializer),biasInitializer:Ze(this.biasInitializer),kernelRegularizer:Me(this.kernelRegularizer),recurrentRegularizer:Me(this.recurrentRegularizer),biasRegularizer:Me(this.biasRegularizer),activityRegularizer:Me(this.activityRegularizer),kernelConstraint:mt(this.kernelConstraint),recurrentConstraint:mt(this.recurrentConstraint),biasConstraint:mt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}lp.className="SimpleRNNCell";Z(lp);class Iy extends es{constructor(e){e.cell=new lp(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return new e(t)}}Iy.className="SimpleRNN";Z(Iy);class up extends bu{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new P("GRUCell does not support reset_after parameter set to true.");this.units=e.units,bt(this.units,"units"),this.activation=cr(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cr(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=je(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=je(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=je(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=qe(e.kernelRegularizer),this.recurrentRegularizer=qe(e.recurrentRegularizer),this.biasRegularizer=qe(e.biasRegularizer),this.kernelConstraint=gt(e.kernelConstraint),this.recurrentConstraint=gt(e.recurrentConstraint),this.biasConstraint=gt(e.biasConstraint),this.dropout=Fo([1,lr([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fo([1,lr([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=De(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new P(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hr({ones:()=>pn(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hr({ones:()=>pn(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let i,l,u;0<this.dropout&&this.dropout<1&&(e=_(e,o[0]));let c=cs(e,this.kernel.read());this.useBias&&(c=Qn(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=_(r,a[0]));const h=this.recurrentKernel.read(),[d,p]=Zt(h,[2*this.units,this.units],h.rank-1),f=cs(r,d),[m,g,y]=Zt(c,3,c.rank-1),[x,w]=Zt(f,2,f.rank-1);i=this.recurrentActivation.apply(Y(m,x)),l=this.recurrentActivation.apply(Y(g,w));const b=cs(_(l,r),p);u=this.activation.apply(Y(y,b));const $=Y(_(i,r),_(Y(1,Ue(i)),u));return[$,$]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ur(this.activation),recurrentActivation:ur(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ze(this.kernelInitializer),recurrentInitializer:Ze(this.recurrentInitializer),biasInitializer:Ze(this.biasInitializer),kernelRegularizer:Me(this.kernelRegularizer),recurrentRegularizer:Me(this.recurrentRegularizer),biasRegularizer:Me(this.biasRegularizer),activityRegularizer:Me(this.activityRegularizer),kernelConstraint:mt(this.kernelConstraint),recurrentConstraint:mt(this.recurrentConstraint),biasConstraint:mt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}up.className="GRUCell";Z(up);class Ny extends es{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new up(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Ny.className="GRU";Z(Ny);class wu extends bu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,bt(this.units,"units"),this.activation=cr(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cr(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=je(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=je(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=je(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=qe(e.kernelRegularizer),this.recurrentRegularizer=qe(e.recurrentRegularizer),this.biasRegularizer=qe(e.biasRegularizer),this.kernelConstraint=gt(e.kernelConstraint),this.recurrentConstraint=gt(e.recurrentConstraint),this.biasConstraint=gt(e.biasConstraint),this.dropout=Fo([1,lr([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Fo([1,lr([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=De(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;r=new(t=class extends Fn{apply(l,u){const c=o.apply([a]),h=new Yd().apply([a]),d=o.apply([a*2]);return Cb(Cb(c,h),d)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return B(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new P(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hr({ones:()=>pn(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hr({ones:()=>pn(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=_(e,a[0]));let d=cs(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=_(r,i[0])),d=Y(d,cs(r,this.recurrentKernel.read())),this.useBias&&(d=Qn(d,this.bias.read()));const[p,f,m,g]=Zt(d,4,d.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=Y(_(u,o),_(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);const y=_(h,this.activation.apply(c));return[y,y,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ur(this.activation),recurrentActivation:ur(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ze(this.kernelInitializer),recurrentInitializer:Ze(this.recurrentInitializer),biasInitializer:Ze(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Me(this.kernelRegularizer),recurrentRegularizer:Me(this.recurrentRegularizer),biasRegularizer:Me(this.biasRegularizer),activityRegularizer:Me(this.activityRegularizer),kernelConstraint:mt(this.kernelConstraint),recurrentConstraint:mt(this.recurrentConstraint),biasConstraint:mt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}wu.className="LSTMCell";Z(wu);class Cy extends es{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new wu(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Cy.className="LSTM";Z(Cy);class cp extends bu{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return B(()=>{e=e;let s=e.slice(1);const r=[];for(const i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(s.splice(0,i.stateSize.length)):r.push(s.splice(0,1));r.reverse();const o=[];let a;for(let i=0;i<this.cells.length;++i){const l=this.cells[i];s=r[i],i===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=l.call(a,t),o.push(a.slice(1))}s=[];for(const i of o.slice().reverse())s.push(...i);return[a[0]].concat(s)})}build(e){df(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{zr(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=o=>({className:o.getClassName(),config:o.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const o of t.cells)r.push(Hn(o,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return pf(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,o=e.splice(r);for(let a=0;a<s.weights.length;++a)t.push([s.weights[a],o[a]])}Qg(t)}}cp.className="StackedRNNCells";Z(cp);function hr(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:o}=n,a=()=>o!=null?o(e(),t):Hv(e(),t),i=()=>mu(a,e,s);return!r||r<=1?pt(i().clone()):Array(r).fill(void 0).map(i).map(u=>pt(u.clone()))}var zP=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class O$ extends es{constructor(e){if(e.unroll)throw new be("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new be("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ut({ndim:5})]}call(e,t){return B(()=>{if(this.cell.dropoutMask!=null&&(ye(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ye(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new P("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return B(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)],a=lt(o);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){B(()=>{if(!this.stateful)throw new ts("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)];if(s[0]==null)throw new P("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>lt(o)):this.states_=[lt(o)];else if(e==null)ye(this.states_),this.keptStates!=null&&(ye(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>lt(o)):this.states_[0]=lt(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new P(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):ye(this.states_);for(let i=0;i<this.states_.length;++i){const l=e[i],u=o;if(!Ce(l.shape,u))throw new P(`State ${i} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[i]=l}}this.states_=this.states_.map(i=>pt(i.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:o,strides:a,dilationRate:i}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=jn(u,r[0],o,a[0],i[0]),d=jn(c,r[1],o,a[1],i[1]);return[...e.slice(0,2),...l?[s,h,d]:[h,d,s]]}}O$.className="ConvRNN2D";class hp extends wu{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:o,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,bt(this.filters,"filters"),this.kernelSize=Co(s,2,"kernelSize"),this.kernelSize.forEach(l=>bt(l,"kernelSize")),this.strides=Co(r||1,2,"strides"),this.strides.forEach(l=>bt(l,"strides")),this.padding=o||"valid",kn(this.padding),this.dataFormat=a||"channelsLast",ot(this.dataFormat),this.dilationRate=Co(i||1,2,"dilationRate"),this.dilationRate.forEach(l=>bt(l,"dilationRate"))}build(e){var t;e=De(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new P(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],o=4,a=this.kernelSize.concat([r,this.filters*o]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(t=class extends Fn{apply(d,p){const f=u.apply([c]),m=Yt([c]),g=u.apply([c*2]);return Hg([f,m,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return B(()=>{if(e.length!==3)throw new P(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],o=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hr({ones:()=>pn(r),rate:this.dropout,training:s,count:i,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(K,X,J)=>!X||!X[J]?K:_(X[J],K);let c=u(r,l,0),h=u(r,l,1),d=u(r,l,2),p=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hr({ones:()=>pn(o),rate:this.recurrentDropout,training:s,count:i,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=u(o,f,0),g=u(o,f,1),y=u(o,f,2),x=u(o,f,3);const w=3,[b,$,N,T]=Zt(this.kernel.read(),i,w),[A,k,E,S]=this.useBias?Zt(this.bias.read(),i):[null,null,null,null];c=this.inputConv(c,b,A,this.padding),h=this.inputConv(h,$,k,this.padding),d=this.inputConv(d,N,E,this.padding),p=this.inputConv(p,T,S,this.padding);const[D,F,z,M]=Zt(this.recurrentKernel.read(),i,w);m=this.recurrentConv(m,D),g=this.recurrentConv(g,F),y=this.recurrentConv(y,z),x=this.recurrentConv(x,M);const W=this.recurrentActivation.apply(Y(c,m)),j=this.recurrentActivation.apply(Y(h,g)),U=Y(_(j,a),_(W,this.activation.apply(Y(d,y)))),q=_(this.recurrentActivation.apply(Y(p,x)),this.activation.apply(U));return[q,q,U]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=zP(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const o=As(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Qn(o,s,this.dataFormat):o}recurrentConv(e,t){return As(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}hp.className="ConvLSTM2DCell";Z(hp);class ky extends O${constructor(e){const t=new hp(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}ky.className="ConvLSTM2D";Z(ky);class dp extends Ne{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return B(()=>{this.invokeCallHook(e,t);const s=ge(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,o=this.getNoiseShape(s);return mu(()=>Hv(s,this.rate,o,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}dp.className="Dropout";Z(dp);class Ty extends dp{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Ty.className="SpatialDropout1D";Z(Ty);class Ey extends Ne{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,bt(this.units,"units"),this.activation=cr(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=je(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=je(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=gt(e.kernelConstraint),this.biasConstraint=gt(e.biasConstraint),this.kernelRegularizer=qe(e.kernelRegularizer),this.biasRegularizer=qe(e.biasRegularizer),this.activityRegularizer=qe(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=De(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=De(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return B(()=>{this.invokeCallHook(e,t);const s=ge(e),r=zv(this.activation.getClassName());let o;return r!=null?o=cs(s,this.kernel.read(),r,this.bias?this.bias.read():null):(o=cs(s,this.kernel.read()),this.bias!=null&&(o=Qn(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:ur(this.activation),useBias:this.useBias,kernelInitializer:Ze(this.kernelInitializer),biasInitializer:Ze(this.biasInitializer),kernelRegularizer:Me(this.kernelRegularizer),biasRegularizer:Me(this.biasRegularizer),activityRegularizer:Me(this.activityRegularizer),kernelConstraint:mt(this.kernelConstraint),biasConstraint:mt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Ey.className="Dense";Z(Ey);class Ay extends Ne{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=De(e);for(const t of e.slice(1))if(t==null)throw new P(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],tr(e,1)]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let s=ge(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let o=2;o<s.rank;++o)r.push(o);r.push(1),s=ke(s,r)}return XF(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Ay.className="Flatten";Z(Ay);class Ry extends Ne{constructor(e){super(e),this.supportsMasking=!0,this.activation=cr(e.activation)}call(e,t){return B(()=>{this.invokeCallHook(e,t);const s=ge(e);return this.activation.apply(s)})}getConfig(){const e={activation:ur(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Ry.className="Activation";Z(Ry);class Dy extends Ne{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return B(()=>(e=ge(e),qF(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Dy.className="RepeatVector";Z(Dy);class Oy extends Ne{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let o=1,a=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(a===null)a=l;else throw new P("Can only specifiy one unknown dimension.");else o*=u}const i=tr(e);if(a!==null){if(o===0||i%o!==0)throw new P(s);r[a]=i/o}else if(i!==o)throw new P(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return B(()=>{this.invokeCallHook(e,t);const s=ge(e),r=s.shape,o=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return L(s,o)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Oy.className="Reshape";Z(Oy);class _y extends Ne{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=qn(1,e.dims.length+1);if(!Ce(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ut({ndim:this.dims.length+1})]}computeOutputShape(e){e=De(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return ke(ge(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}_y.className="Permute";Z(_y);class Fy extends Ne{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=ge(e);return Ti(qr(s,this.maskValue),-1)}call(e,t){return B(()=>{this.invokeCallHook(e,t);const s=ge(e),a=Ti(qr(s,this.maskValue),-1,!0);return _(s,ee(a,s.dtype))})}}Fy.className="Masking";Z(Fy);class Ly extends Ne{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(_e(e.inputLength))}this.inputDim=e.inputDim,bt(this.inputDim,"inputDim"),this.outputDim=e.outputDim,bt(this.outputDim,"outputDim"),this.embeddingsInitializer=je(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=qe(e.embeddingsRegularizer),this.activityRegularizer=qe(e.activityRegularizer),this.embeddingsConstraint=gt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return B(()=>this.maskZero?(e=ge(e),qr(e,Ee(e))):null)}computeOutputShape(e){if(e=De(e),this.inputLength==null)return[...e,this.outputDim];const t=_e(this.inputLength);if(t.length!==e.length-1)throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const o=t[r],a=e[r+1];if(o!=null&&a!=null&&o!==a)throw new P(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);o==null&&(t[s]=a),s++}}return[e[0],...t,this.outputDim]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let s=ge(e);s.dtype!=="int32"&&(s=us(s,"int32"));const r=Gv(this.embeddings.read(),L(s,[s.size]));return L(r,De(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ze(this.embeddingsInitializer),embeddingsRegularizer:Me(this.embeddingsRegularizer),activityRegularizer:Me(this.activityRegularizer),embeddingsConstraint:mt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Ly.className="Embedding";Z(Ly);class mo extends Ne{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new be}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const o=e[e.length-t.length+r],a=t[r];if(o==null||a==null||o<0||a<0)s.push(null);else if(o===1)s.push(a);else if(a===1)s.push(o);else{if(o!==a)throw new P("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(o)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[De(e)]),e=e,e.length<2)throw new P(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const o of e)o!=null&&o[0]!==null&&t.push(o[0]);if(t=er(t),t.length>1)throw new P(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let o=1;o<e.length;++o){const a=e[o]==null?null:e[o].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const r=e.map(o=>o.length);e.indexOf(null)===-1&&er(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return B(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(o=>o.rank);if(r.indexOf(null)===-1){const o=lr(r);for(let a of e){const i=a.rank;for(let l=0;l<o-i;++l)a=pu(a,1);s.push(a)}return this.mergeFunction(s)}else{let o=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],d=c.slice(1).concat([h]);let p=L(l,[h].concat(tr(c.slice(1))));p=ke(p,[1,0]),p=L(p,d),s.push(p),o=!0}else if(u>1){const c=qn(1,u).concat([0]);s.push(ke(l,c)),o=!0}else s.push(l)}let a=this.mergeFunction(s);const i=a.rank;if(o){if(i==null){const l=a.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));a=L(ke(L(a,[-1,c]),[1,0]),h)}else if(i>1){const l=[i-1].concat(qn(0,i-1));a=ke(a,l)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,o)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=er(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return B(()=>{if(t==null)return null;if(!Array.isArray(t))throw new P("`mask` should be an Array");if(!Array.isArray(e))throw new P("`inputs` should be an Array");if(t.length!==e.length)throw new P(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Tt(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=On(s,t[r]);return s})}}class Py extends mo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Y(t,e[s]);return t})}}Py.className="Add";Z(Py);class zy extends mo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=_(t,e[s]);return t})}}zy.className="Multiply";Z(zy);class My extends mo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Y(t,e[s]);return _(1/e.length,t)})}}My.className="Average";Z(My);class By extends mo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=gs(t,e[s]);return t})}}By.className="Maximum";Z(By);class Vy extends mo{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=ir(t,e[s]);return t})}}Vy.className="Minimum";Z(Vy);class Wy extends mo{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new P("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const o=e[r].slice();o.splice(this.axis,1);let a=!1;for(const i of s)if(Ce(i,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new P("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return B(()=>Hg(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new P("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const o of t.slice(1)){if(s[r]==null||o[r]==null){s[r]=null;break}s[r]+=o[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new P("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new P("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new P(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return B(()=>{let s=!0;if(t.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(ee(pn(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Tt(t[a],-1)):r.push(t[a]);const o=nt(r,this.axis);return ld(o,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Wy.className="Concatenate";Z(Wy);function ii(n,e){for(;n<0;)n+=e;return n}function MP(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new be("batchDot is not implemented for tensors of 4D or higher rank yet");if(I(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),I(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new be("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const o=t;return B(()=>{let a;if(s>r){a=s-r;const l=[];for(let u=0;u<a;++u)l.push(1);e=L(e,e.shape.concat(l))}else if(r>s){a=r-s;const l=[];for(let u=0;u<a;++u)l.push(1);n=L(n,n.shape.concat(l))}else a=0;let i;if(n.shape.length===2&&e.shape.length===2)o[0]===o[1]?i=ie(_(n,e),o[0]):i=ie(_(ke(n,[1,0]),e),o[1]);else{const l=o[0]!==n.shape.length-1,u=o[1]===e.shape.length-1;i=Se(n,e,l,u)}if(a>0){let l;s>r?l=s+r-3:l=s-1;const u=[];for(let c=l;c<l+a;++c)u.push(c);i=br(i,u)}return i.shape.length===1&&(i=Tt(i,1)),i})}class Uy extends mo{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){I(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new be("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new P(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new P(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((o,a)=>ii(o,e[a].shape.length)):r=[ii(this.axes,t.shape.length),ii(this.axes,s.shape.length)],this.normalize&&(t=_c(t,r[0]),s=_c(s,r[1])),MP(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[ii(this.axes,e.length),ii(this.axes,t.length)],s}computeOutputShape(e){I(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new be("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const o=t.concat(s);return o.length===1&&o.push(1),o}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Uy.className="Dot";Z(Uy);class Gy extends Ne{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);const s=ge(e);return mu(()=>Y(Xd(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}Gy.className="GaussianNoise";Z(Gy);class Hy extends Ne{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);const s=ge(e);return this.rate>0&&this.rate<1?mu(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return _(s,Xd(s.shape,1,o))},()=>s,t.training||!1):s})}}Hy.className="GaussianDropout";Z(Hy);class jy extends Ne{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ge(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return mu(()=>{const o=ge(e),i=-1.6732632423543772*1.0507009873554805;let l=Ps(xr(s),this.rate);l=us(l,"float32");const u=((1-this.rate)*(1+this.rate*i**2))**-.5,c=-u*i*this.rate,h=Y(_(o,l),_(Y(l,-1),i));return Y(_(h,u),c)},()=>ge(e),t.training||!1)}return e})}}jy.className="AlphaDropout";Z(jy);function _i(n,e,t,s,r,o=.001){let a;if(n.rank===2)a=dm(n,e,t,s,r,o);else if(n.rank===3)a=pm(n,e,t,s,r,o);else if(n.rank===4)a=fm(n,e,t,s,r,o);else throw new be(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function BP(n,e,t,s,r=.001){return B(()=>{const o=tu(n,s),a=o.mean,i=o.variance;return[_i(n,a,i,t,e,r),a,i]})}function VP(n,e,t,s,r=.001){return B(()=>{const o=tu(n,s),a=o.mean,i=o.variance,l=[];for(const f of qn(0,n.rank))s.indexOf(f)!==-1?l.push(1):l.push(n.shape[f]);const u=L(a,l),c=L(i,l),h=e==null?null:L(e,l),d=t==null?null:L(t,l);return[_i(n,u,c,d,h,r),a,i]})}function WP(n,e,t,s,r=.001){return Ce(s.slice().sort(),qn(0,n.rank-1))?BP(n,e,t,s,r):VP(n,e,t,s,r)}class qy extends Ne{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=je(e.betaInitializer||"zeros"),this.gammaInitializer=je(e.gammaInitializer||"ones"),this.movingMeanInitializer=je(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=je(e.movingVarianceInitializer||"ones"),this.betaConstraint=gt(e.betaConstraint),this.gammaConstraint=gt(e.gammaConstraint),this.betaRegularizer=qe(e.betaRegularizer),this.gammaRegularizer=qe(e.gammaRegularizer)}build(e){e=De(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new P(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ut({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return B(()=>{const s=t.training==null?!1:t.training,r=ge(e),o=r.shape,a=o.length,i=qn(0,a),l=this.axis>=0?this.axis:this.axis+a;i.splice(l,1);const u=Yr(1,a);u[l]=o[l];const c=i.slice();c.sort();const h=!Ce(c,qn(0,a).slice(0,a-1)),d=()=>{if(h){const x=L(this.movingMean.read(),u),w=L(this.movingVariance.read(),u),b=this.center?L(this.beta.read(),u):null,$=this.scale?L(this.gamma.read(),u):null;return _i(r,x,w,b,$,this.epsilon)}else return _i(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[p,f,m]=WP(r,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(x,w,b)=>{B(()=>{const $=1-b,N=x.read(),T=_(oe(N,w),$);x.write(oe(N,T))})};return g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ze(this.betaInitializer),gammaInitializer:Ze(this.gammaInitializer),movingMeanInitializer:Ze(this.movingMeanInitializer),movingVarianceInitializer:Ze(this.movingVarianceInitializer),betaRegularizer:Me(this.betaRegularizer),gammaRegularizer:Me(this.gammaRegularizer),betaConstraint:mt(this.betaConstraint),gammaConstraint:mt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}qy.className="BatchNormalization";Z(qy);class Ky extends Ne{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=je(e.betaInitializer||"zeros"),this.gammaInitializer=je(e.gammaInitializer||"ones"),this.betaRegularizer=qe(e.betaRegularizer),this.gammaRegularizer=qe(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=De(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=t);for(const o of this.axis)if(o<0||o>=t)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==er(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=ge(e),r=s.shape,o=r.length;return B(()=>{let{mean:i,variance:l}=tu(s,this.axis,!0);const u=Yr(1,o);for(const m of this.axis)u[m]=r[m];const c=m=>m!=null&&m.shape.length!==o?L(m,u):m;let h=this.scale?c(this.gamma.read()):null,d=this.center?c(this.beta.read()):null;const p=[],f=[];for(let m=0;m<o;++m)this.axis.indexOf(m)!==-1?(p.push(r[m]),f.push(1)):(p.push(1),f.push(r[m]));return i=wn(i,p),l=wn(l,p),h!=null&&(h=wn(h,f)),d!=null&&(d=wn(d,f)),_i(s,i,l,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ze(this.betaInitializer),gammaInitializer:Ze(this.gammaInitializer),betaRegularizer:Me(this.betaRegularizer),gammaRegularizer:Me(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Ky.className="LayerNormalization";Z(Ky);function UP(n,e,t){return B(()=>{if(n.rank!==4)throw new P(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new P("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Kn()),t!=="channelsLast"&&t!=="channelsFirst")throw new P(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],zs(n,s)})}class Xy extends Ne{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Kn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new P(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new P(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new P(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new ut({ndim:4})]}computeOutputShape(e){e=De(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return B(()=>UP(ge(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Xy.className="ZeroPadding2D";Z(Xy);function pp(n,e,t,s,r,o){return B(()=>{ot(r),Bv(o),kn(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=Kn()),o==null&&(o="max"),n=yy(n,r);let a;const i=s==="same"?"same":"valid";return o==="max"?a=eu(n,e,t,i):a=jl(n,e,t,i),r==="channelsFirst"&&(a=ke(a,[0,3,1,2])),a})}function _$(n,e,t,s,r,o){return B(()=>{ot(r),Bv(o),kn(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Kn()),o==null&&(o="max"),n=E$(n,r);let a;const i=s==="same"?"same":"valid";return o==="max"?a=Pm(n,e,t,i):a=hm(n,e,t,i),r==="channelsFirst"&&(a=ke(a,[0,4,1,2,3])),a})}class F$ extends Ne{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new P(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(bt(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new P(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);bt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,kn(this.padding),this.inputSpec=[new ut({ndim:3})]}computeOutputShape(e){e=De(e);const t=jn(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return B(()=>{this.invokeCallHook(e,t),e=pu(ge(e),2);const s=this.poolingFunction(ge(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return br(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Yy extends F${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return ot(o),kn(r),pp(e,t,s,r,o,"max")}}Yy.className="MaxPooling1D";Z(Yy);class Zy extends F${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return ot(o),kn(r),pp(e,t,s,r,o,"avg")}}Zy.className="AveragePooling1D";Z(Zy);class L$ extends Ne{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new P(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];bt(this.poolSize,"poolSize"),bt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ot(this.dataFormat),kn(this.padding),this.inputSpec=[new ut({ndim:4})]}computeOutputShape(e){e=De(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=jn(t,this.poolSize[0],this.padding,this.strides[0]),s=jn(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Jy extends L${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return ot(o),kn(r),pp(e,t,s,r,o,"max")}}Jy.className="MaxPooling2D";Z(Jy);class Qy extends L${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return ot(o),kn(r),pp(e,t,s,r,o,"avg")}}Qy.className="AveragePooling2D";Z(Qy);class P$ extends Ne{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new P(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];bt(this.poolSize,"poolSize"),bt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ot(this.dataFormat),kn(this.padding),this.inputSpec=[new ut({ndim:5})]}computeOutputShape(e){e=De(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=jn(t,this.poolSize[0],this.padding,this.strides[0]),s=jn(s,this.poolSize[1],this.padding,this.strides[1]),r=jn(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ex extends P${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return ot(o),kn(r),_$(e,t,s,r,o,"max")}}ex.className="MaxPooling3D";Z(ex);class tx extends P${constructor(e){super(e)}poolingFunction(e,t,s,r,o){return ot(o),kn(r),_$(e,t,s,r,o,"avg")}}tx.className="AveragePooling3D";Z(tx);class z$ extends Ne{constructor(e){super(e),this.inputSpec=[new ut({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new be}}class nx extends z${constructor(e){super(e||{})}call(e,t){return B(()=>{const s=ge(e);return Ye(s,1)})}}nx.className="GlobalAveragePooling1D";Z(nx);class sx extends z${constructor(e){super(e||{})}call(e,t){return B(()=>{const s=ge(e);return In(s,1)})}}sx.className="GlobalMaxPooling1D";Z(sx);class M$ extends Ne{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ot(this.dataFormat),this.inputSpec=[new ut({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new be}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class rx extends M${call(e,t){return B(()=>{const s=ge(e);return this.dataFormat==="channelsLast"?Ye(s,[1,2]):Ye(s,[2,3])})}}rx.className="GlobalAveragePooling2D";Z(rx);class ox extends M${call(e,t){return B(()=>{const s=ge(e);return this.dataFormat==="channelsLast"?In(s,[1,2]):In(s,[2,3])})}}ox.className="GlobalMaxPooling2D";Z(ox);class B$ extends Ne{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,o=Hn(r,s);delete t.layer;const a={layer:o};return Object.assign(a,t),new e(a)}}class ax extends B${constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=De(e),e.length<3)throw new P(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=De(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return B(()=>(e=ge(e),D$((a,i)=>[ge(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}ax.className="TimeDistributed";Z(ax);function GP(n){po(WF,"BidirectionalMergeMode",n)}const HP="concat";class ix extends B${constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=Hn(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Hn(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?HP:e.mergeMode,GP(this.mergeMode),e.weights)throw new be("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,o;return this.returnState&&(o=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):Xt(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const o=R$(e,s,r,this.numConstants);if(e=o.inputs,s=o.initialState,r=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const a=[],i=[];if(s!=null){const u=s.length;if(u%2>0)throw new P("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,a.push(...s);const c=s.map(h=>new ut({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),i.push(...c)}if(r!=null)throw new be("Support for constants in Bidirectional layers is not implemented yet.");const l=a[0]instanceof Xn;for(const u of a)if(u instanceof Xn!==l)throw new P("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(a),c=this.inputSpec.concat(i),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return B(()=>{const s=t.initialState;let r,o;if(s==null)r=this.forwardLayer.call(e,t),o=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),o=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(o.slice(1))),r=r[0],o=o[0]),this.returnSequences&&(o=Nn(o,1));let i;return this.mergeMode==="concat"?i=Hg([r,o]):this.mergeMode==="sum"?i=Y(r,o):this.mergeMode==="ave"?i=_(.5,Y(r,o)):this.mergeMode==="mul"?i=_(r,o):this.mergeMode==null&&(i=[r,o]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){zr(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),zr(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=Hn(t.layer);if(delete t.layer,t.numConstants!=null)throw new be("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}ix.className="Bidirectional";Z(ix);class lx extends Ne{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>(e=ge(e),e.dtype!=="float32"&&(e=us(e,"float32")),Y(_(e,this.scale),this.offset)))}}lx.className="Rescaling";Z(lx);const{resizeBilinear:jP,cropAndResize:qP}=Rn;class ux extends Ne{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,o,a,i,l){return B(()=>{let u,c=!1;const h=t/a,d=s/i,p=(r+t)/a,f=(o+s)/i,m=[h,d,p,f],g=[];e.rank===3?(c=!0,u=Gt([e])):u=e;for(let $=0;$<u.shape[0];$++)g.push(m);const y=cn(g,[g.length,4]),x=Kr(0,g.length,1,"int32"),b=qP(u,y,x,[r,o],"nearest");return us(c?ge(Cn(b)):b,l)})}upsize(e,t,s,r){return B(()=>{const o=jP(e,[t,s]);return us(o,r)})}call(e,t){return B(()=>{const s=ge(e),r=s.dtype,o=s.shape,a=o[o.length-3],i=o[o.length-2];let l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let u=0;return i!==this.width&&(u=Math.floor((i-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(s,l,u,this.height,this.width,a,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=De(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}ux.className="CenterCrop";Z(ux);function KP(n,e,t,s){let r=ge(n);if(r.dtype!=="int32"&&(r=us(r,"int32")),e==="int")return r;const o=r.shape;if(r.rank===0&&(r=Tt(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Tt(r,-1)),r.rank>2)throw new P(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${o} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(e),i=r;let l;if(typeof s<"u"&&e==="count"?l=Tc(i,s,t,a):l=Tc(i,[],t,a),e!=="tfIdf")return l;if(s)return _(l,s);throw new P("When outputMode is 'tfIdf', weights must be provided.")}class cx extends Ne{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=De(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return B(()=>{e=ge(e),e.dtype!=="int32"&&(e=us(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new P(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=ge(t.countWeights)}const r=In(e),o=Eo(e),a=qt(this.numTokens,r).bufferSync().get(0),i=Ps(o,0).bufferSync().get(0);if(!(a&&i))throw new P(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return KP(e,this.outputMode,this.numTokens,s)})}}cx.className="CategoryEncoding";Z(cx);const XP=["bilinear","nearest"],Gb=new Set(XP);class hx extends Ne{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(Gb.has(e.interpolation))this.interpolation=e.interpolation;else throw new P(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=De(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Rn.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Rn.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Gb]} are supported`)})}}hx.className="Resizing";Z(hx);class V${constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}V$.className="RandomSeed";class W$ extends Ne{constructor(e){super(e),this.randomGenerator=new V$(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}W$.className="BaseRandomLayer";const YP=["bilinear","nearest"],Hb=new Set(YP);class dx extends W${constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new P(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new P(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new P(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(Hb.has(s))this.interpolation=s;else throw new P(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=De(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return B(()=>{const s=ge(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=xr([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*r;o=Math.round(o);const a=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Rn.resizeBilinear(e,a);case"nearest":return Rn.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...Hb]} are supported`)}})}}dx.className="RandomWidth";Z(dx);function ZP(n){return new Ua(n)}function JP(n){return new fy(n)}function QP(n){return new hy(n)}function e3(n){return new dy(n)}function t3(n){return new py(n)}function n3(n){return new gy(n)}function s3(n){return new my(n)}function r3(n){return new xu(n)}function o3(n){return new ja(n)}function a3(n){return new xy(n)}function i3(n){return new qa(n)}function l3(n){return new by(n)}function u3(n){return new wy(n)}function c3(n){return new vy(n)}function h3(n){return new $y(n)}function d3(n){return new Sy(n)}function p3(n){return new Ry(n)}function f3(n){return new Ey(n)}function m3(n){return new dp(n)}function g3(n){return new Ty(n)}function y3(n){return new Ay(n)}function x3(n){return new Dy(n)}function b3(n){return new Oy(n)}function w3(n){return new _y(n)}function v3(n){return new Ly(n)}function $3(n){return new Py(n)}function S3(n){return new My(n)}function I3(n){return new Wy(n)}function N3(n){return new By(n)}function C3(n){return new Vy(n)}function k3(n){return new zy(n)}function T3(n){return new Uy(n)}function E3(n){return new qy(n)}function A3(n){return new Ky(n)}function R3(n){return new Xy(n)}function px(n){return new Zy(n)}function D3(n){return px(n)}function O3(n){return px(n)}function fx(n){return new Qy(n)}function _3(n){return fx(n)}function F3(n){return fx(n)}function mx(n){return new tx(n)}function L3(n){return mx(n)}function P3(n){return mx(n)}function z3(n){return new nx(n)}function M3(n){return new rx(n)}function U$(n){return new sx(n)}function G$(n){return new ox(n)}function H$(n){return new Yy(n)}function j$(n){return new Jy(n)}function B3(n){return new ex(n)}function V3(n){return new Ny(n)}function W3(n){return new up(n)}function U3(n){return new Cy(n)}function G3(n){return new wu(n)}function H3(n){return new Iy(n)}function j3(n){return new lp(n)}function q3(n){return new ky(n)}function K3(n){return new hp(n)}function X3(n){return new es(n)}function Y3(n){return new cp(n)}function Z3(n){return new ix(n)}function J3(n){return new ax(n)}const Q3=U$,ez=G$,tz=H$,nz=j$;function sz(n){return new Gy(n)}function rz(n){return new Hy(n)}function oz(n){return new jy(n)}function az(n){return new Fy(n)}function iz(n){return new lx(n)}function lz(n){return new ux(n)}function uz(n){return new hx(n)}function cz(n){return new cx(n)}function hz(n){return new dx(n)}const dz=Object.freeze(Object.defineProperty({__proto__:null,Layer:Ne,RNN:es,RNNCell:bu,activation:p3,add:$3,alphaDropout:oz,average:S3,averagePooling1d:px,averagePooling2d:fx,averagePooling3d:mx,avgPool1d:D3,avgPool2d:_3,avgPool3d:L3,avgPooling1d:O3,avgPooling2d:F3,avgPooling3d:P3,batchNormalization:E3,bidirectional:Z3,categoryEncoding:cz,centerCrop:lz,concatenate:I3,conv1d:r3,conv2d:o3,conv2dTranspose:a3,conv3d:i3,conv3dTranspose:l3,convLstm2d:q3,convLstm2dCell:K3,cropping2D:c3,dense:f3,depthwiseConv2d:d3,dot:T3,dropout:m3,elu:JP,embedding:v3,flatten:y3,gaussianDropout:rz,gaussianNoise:sz,globalAveragePooling1d:z3,globalAveragePooling2d:M3,globalMaxPool1d:Q3,globalMaxPool2d:ez,globalMaxPooling1d:U$,globalMaxPooling2d:G$,gru:V3,gruCell:W3,input:d$,inputLayer:ZP,layerNormalization:A3,leakyReLU:e3,lstm:U3,lstmCell:G3,masking:az,maxPool1d:tz,maxPool2d:nz,maxPooling1d:H$,maxPooling2d:j$,maxPooling3d:B3,maximum:N3,minimum:C3,multiply:k3,permute:w3,prelu:t3,randomWidth:hz,reLU:QP,repeatVector:x3,rescaling:iz,reshape:b3,resizing:uz,rnn:X3,separableConv2d:u3,simpleRNN:H3,simpleRNNCell:j3,softmax:n3,spatialDropout1d:g3,stackedRNNCells:Y3,thresholdedReLU:s3,timeDistributed:J3,upSampling2d:h3,zeroPadding2d:R3},Symbol.toStringTag,{value:"Module"}));function pz(n,e){return ay(n,e)}function fz(n,e){return s$(n,e)}function mz(n,e){return r$(n,e)}function gz(n,e){return iy(n,e)}function yz(n,e){return ly(n,e)}function xz(n,e){return n$(n,e)}function bz(n,e){return YL(n,e)}function wz(n,e){return oy(n,e)}function vz(n,e){return rp(n,e)}function $z(n,e){return Ga(n,e)}function Sz(n,e){return Ga(n,e)}function Iz(n,e){return Ga(n,e)}function Nz(n,e){return fo(n,e)}function Cz(n,e){return fo(n,e)}function kz(n,e){return fo(n,e)}function Tz(n,e){return ZL(n,e)}const Ez=Object.freeze(Object.defineProperty({__proto__:null,MAPE:Sz,MSE:Cz,binaryAccuracy:pz,binaryCrossentropy:fz,categoricalAccuracy:gz,categoricalCrossentropy:yz,cosineProximity:wz,mape:Iz,meanAbsoluteError:vz,meanAbsolutePercentageError:$z,meanSquaredError:Nz,mse:kz,precision:xz,r2Score:Tz,recall:bz,sparseCategoricalAccuracy:mz},Symbol.toStringTag,{value:"Module"}));const Az=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:CP},Symbol.toStringTag,{value:"Module"}));function Rz(n){return new yu(n)}function Dz(n){return OP(n)}function Oz(n){return _P(n)}const _z=Object.freeze(Object.defineProperty({__proto__:null,l1:Dz,l1l2:Rz,l2:Oz},Symbol.toStringTag,{value:"Module"}));class q$ extends Lo{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Ns))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function Fu(n,e){return n<e}function jb(n,e){return n>e}class K$ extends q${constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new be("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Fu:this.mode==="max"?this.monitorFunc=jb:this.monitor.indexOf("acc")!==-1?this.monitorFunc=jb:this.monitorFunc=Fu,this.monitorFunc===Fu&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Fu?1/0:-1/0}async onEpochEnd(e,t){await js(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function Fz(n){return new K$(n)}const Lz={earlyStopping:Fz};const Pz=V();Pz.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var on;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(on||(on={}));var qb;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(qb||(qb={}));const gx={};function zz(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};gx[n]=t}function X$(n){return gx[n]}function Mz(n){delete gx[n]}function v(n,e,t,s,r){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const i=o.inputIndexStart,l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?i+1:o.inputIndexEnd,u=i<0?e.inputNames.length+i:i;if(o.type==="tensor")return Et(e.inputNames[u],t,s,r);if(o.type==="tensors"){const d=e.inputs.slice(i,l);return e.inputNames.slice(i,l).filter((f,m)=>{var g;return((g=d[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(f=>Et(f,t,s,r))}const c=Et(e.inputNames[u],t,s,r),h=c.dataSync();return o.type==="number"?h[0]:Sn(c.shape,h)}const a=e.attrParams[n];return a&&a.value}function Et(n,e,t,s){const[r,o]=ln(n,t);if(s!=null){const i=s.getHashTableHandleByName(r);if(i!=null)return i}const a=t.currentContextIds.find(i=>!!e[Mc(r,i)]);return a!==void 0?e[Mc(r,a)][o]:void 0}function Kb(n,e,t){return e[Mc(n,t.currentContextId)]}function vs(n,e){const[t,s,r]=ln(n,e);return[Mc(t,e&&e.currentContextId),s,r]}function Mc(n,e){return e?`${n}-${e}`:n}function ln(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const o=e.parseNodeNameCache.get(n);if(o!=null)return o}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const o=s[0],a=s.length===3?s[1]:void 0,i=Number(s[s.length-1]);r=[o,i,a]}return t&&e.parseNodeNameCache.set(n,r),r}function Qu(n,e,t){let s=v("pad",n,e,t);if(s==="explicit"){s=v("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function $s(n){return n.kept?n:is(n)}const Bz=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Vz=Object.freeze(Object.defineProperty({__proto__:null,json:Bz},Symbol.toStringTag,{value:"Module"}));const Wz=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Uz=Object.freeze(Object.defineProperty({__proto__:null,json:Wz},Symbol.toStringTag,{value:"Module"}));const Gz=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Hz=Object.freeze(Object.defineProperty({__proto__:null,json:Gz},Symbol.toStringTag,{value:"Module"}));const jz=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],qz=Object.freeze(Object.defineProperty({__proto__:null,json:jz},Symbol.toStringTag,{value:"Module"}));const Kz=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Xz=Object.freeze(Object.defineProperty({__proto__:null,json:Kz},Symbol.toStringTag,{value:"Module"}));const Yz=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Zz=Object.freeze(Object.defineProperty({__proto__:null,json:Yz},Symbol.toStringTag,{value:"Module"}));const Jz=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Qz=Object.freeze(Object.defineProperty({__proto__:null,json:Jz},Symbol.toStringTag,{value:"Module"}));const eM=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],tM=Object.freeze(Object.defineProperty({__proto__:null,json:eM},Symbol.toStringTag,{value:"Module"}));const nM=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],sM=Object.freeze(Object.defineProperty({__proto__:null,json:nM},Symbol.toStringTag,{value:"Module"}));const rM=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],oM=Object.freeze(Object.defineProperty({__proto__:null,json:rM},Symbol.toStringTag,{value:"Module"}));const aM=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],iM=Object.freeze(Object.defineProperty({__proto__:null,json:aM},Symbol.toStringTag,{value:"Module"}));const lM=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],uM=Object.freeze(Object.defineProperty({__proto__:null,json:lM},Symbol.toStringTag,{value:"Module"}));const cM=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],hM=Object.freeze(Object.defineProperty({__proto__:null,json:cM},Symbol.toStringTag,{value:"Module"}));const dM=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],pM=Object.freeze(Object.defineProperty({__proto__:null,json:dM},Symbol.toStringTag,{value:"Module"}));const fM=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],mM=Object.freeze(Object.defineProperty({__proto__:null,json:fM},Symbol.toStringTag,{value:"Module"}));const gM=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],yM=Object.freeze(Object.defineProperty({__proto__:null,json:gM},Symbol.toStringTag,{value:"Module"}));const xM=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],bM=Object.freeze(Object.defineProperty({__proto__:null,json:xM},Symbol.toStringTag,{value:"Module"}));const wM=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],vM=Object.freeze(Object.defineProperty({__proto__:null,json:wM},Symbol.toStringTag,{value:"Module"}));const $M=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],SM=Object.freeze(Object.defineProperty({__proto__:null,json:$M},Symbol.toStringTag,{value:"Module"}));class Xb{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Vz,Uz,Hz,qz,Xz,Zz,Qz,tM,sM,oM,iM,uM,hM,pM,mM,yM,bM,vM,SM],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],o=[],a=[],i=s.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?o.push(m[g.name]):(g.input==null||g.input.length===0)&&a.push(m[g.name]),m),{});let l=[];const u=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach(m=>{const g=i[m];g.inputNames.forEach((y,x)=>{const[w,,b]=vs(y),$=i[w];if($.outputs!=null){const N=$.outputs.indexOf(b);if(N!==-1){const T=`${w}:${N}`;g.inputNames[x]=T}}g.inputs.push($),$.children.push(g)})}),Object.keys(h).length===0?d.forEach(m=>{const g=i[m];g.children.length===0&&u.push(g)}):Object.keys(h).forEach(m=>{const[g]=vs(m),y=i[g];y!=null&&(y.signatureKey=h[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=vs(m),y=i[g];y&&(y.signatureKey=c[m],l.push(y))}):l=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:i,inputs:l,outputs:u,weights:o,placeholders:r,signature:t,functions:p};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=X$(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,o)=>{const a=o.type;let i;switch(o.type){case"string":i=xf(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=xf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":i=Nf(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Nf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":i=wf(e.attr,o.tfName,o.defaultValue||0),i===void 0&&o.tfDeprecatedName&&(i=wf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":i=If(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=If(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":i=bf(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=bf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":i=kf(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=kf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":i=Sf(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Sf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":i=Cf(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Cf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":i=vf(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=vf(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":i=$f(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=$f(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":i=Yb(e.attr,o.tfName,o.defaultValue),i===void 0&&o.tfDeprecatedName&&(i=Yb(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:i,type:a},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let o={};t!=null&&(o=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));const a=[],i=[];e.signature.inputArg.forEach(h=>{const[d]=vs(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:yx(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,a.push(p),o[d]=p}),Object.keys(o).forEach(h=>{const d=o[h];d.inputNames.forEach((p,f)=>{const[m,,g]=vs(p),y=o[m];if(y.outputs!=null){const x=y.outputs.indexOf(g);if(x!==-1){const w=`${m}:${x}`;d.inputNames[f]=w}}d.inputs.push(y),y.children.push(d)})});const u=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=vs(u[h.name]),f=o[d];f!=null&&(f.defaultOutput=p,i.push(f))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:a,outputs:i,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function IM(n){const e=V().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Y$(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):IM(n);return e?t:t.toLowerCase()}function xf(n,e,t,s=!1){const r=n[e];return r!=null?Y$(r.s,s):t}function bf(n,e,t){const s=n[e];return s?s.b:t}function wf(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function yx(n){switch(typeof n=="string"&&(n=on[n]),n){case on.DT_FLOAT:case on.DT_HALF:return"float32";case on.DT_INT32:case on.DT_INT64:case on.DT_INT8:case on.DT_UINT8:return"int32";case on.DT_BOOL:return"bool";case on.DT_DOUBLE:return"float32";case on.DT_STRING:return"string";case on.DT_COMPLEX64:case on.DT_COMPLEX128:return"complex64";default:return null}}function Yb(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function vf(n,e,t){const s=n[e];return s&&s.type?yx(s.type):t}function $f(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>yx(r)):t}function Z$(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Sf(n,e,t){const s=n[e];return s&&s.shape?Z$(s.shape):t}function If(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function Nf(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(o=>Y$(o,s)):t}function Cf(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>Z$(r)):t}function kf(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}class NM{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return Et(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Et(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return wf(this.node.rawAttrs,e,t);if(s.s!=null)return xf(this.node.rawAttrs,e,t);if(s.b!=null)return bf(this.node.rawAttrs,e,t);if(s.shape!=null)return Sf(this.node.rawAttrs,e,t);if(s.type!=null)return vf(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return If(this.node.rawAttrs,e,t);if(s.list.s!=null)return Nf(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Cf(this.node.rawAttrs,e,t);if(s.list.b!=null)return kf(this.node.rawAttrs,e,t);if(s.list.type!=null)return $f(this.node.rawAttrs,e,t)}return t}}const Lt=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Kf,abs:it,acos:nm,acosh:sm,add:Y,addN:zw,all:ld,any:Ti,argMax:Gr,argMin:rm,asin:om,asinh:am,atan:im,atan2:lm,atanh:um,avgPool:jl,avgPool3d:hm,basicLSTMCell:Mw,batchNorm:La,batchNorm2d:dm,batchNorm3d:pm,batchNorm4d:fm,batchToSpaceND:ql,bincount:mm,bitwiseAnd:Bw,booleanMaskAsync:I1,broadcastArgs:Vw,broadcastTo:Pr,buffer:we,cast:ee,ceil:gm,clipByValue:en,clone:is,complex:Es,concat:nt,concat1d:ym,concat2d:xm,concat3d:bm,concat4d:wm,conv1d:ud,conv2d:As,conv2dTranspose:cd,conv3d:$m,conv3dTranspose:Sm,cos:Kl,cosh:hd,cosineWindow:_d,cumprod:Ri,cumsum:dd,denseBincount:Tc,depthToSpace:Im,depthwiseConv2d:Pa,diag:Uw,dilation2d:Nm,div:ue,divNoNan:Cm,dot:km,dropout:sg,einsum:Er,elu:za,enclosingPowerOfTwo:rg,ensureShape:Gw,equal:hn,erf:pd,euclideanNorm:Em,exp:tn,expandDims:Tt,expm1:Am,eye:fd,fft:iu,fill:lo,floor:Ba,floorDiv:id,fused:O1,gather:Va,gatherND:T1,greater:qt,greaterEqual:Ps,ifft:_o,imag:Xl,image:Rn,inTopKAsync:E1,irfft:Td,isFinite:Rm,isInf:Dm,isNaN:Om,leakyRelu:Yl,less:Ao,lessEqual:yr,linalg:ig,linspace:qw,localResponseNormalization:_m,log:dn,log1p:Zl,logSigmoid:Fm,logSoftmax:gd,logSumExp:Jl,logicalAnd:On,logicalNot:Ql,logicalOr:yd,logicalXor:Lm,losses:B1,lowerBound:Xw,matMul:Se,max:In,maxPool:eu,maxPool3d:Pm,maxPoolWithArgmax:Yw,maximum:gs,mean:Ye,meshgrid:Zw,min:Eo,minimum:ir,mirrorPad:zm,mod:Mm,moments:tu,movingAverage:N1,mul:_,multiRNNCell:Jw,multinomial:Qw,neg:Ue,norm:Ma,notEqual:qr,oneHot:Ro,ones:Yt,onesLike:pn,op:O,outerProduct:e1,pad:zs,pad1d:t1,pad2d:n1,pad3d:s1,pad4d:r1,pool:Bm,pow:ps,prelu:su,print:tm,prod:Vm,raggedGather:o1,raggedRange:a1,raggedTensorToTensor:i1,rand:l1,randomGamma:h1,randomNormal:bd,randomStandardNormal:d1,randomUniform:xr,randomUniformInt:p1,range:Kr,real:Do,reciprocal:qm,relu:Jn,relu6:wd,reshape:L,reverse:Nn,reverse1d:f1,reverse2d:m1,reverse3d:g1,reverse4d:y1,rfft:lu,round:vd,rsqrt:$d,scalar:he,scatterND:C1,searchSorted:xd,selu:Sd,separableConv2d:Id,setdiff1dAsync:x1,sigmoid:Gn,sign:Km,signal:M1,sin:Nd,sinh:Cd,slice:Te,slice1d:ru,slice2d:kd,slice3d:ou,slice4d:Oo,softmax:au,softplus:uo,spaceToBatchND:nu,sparse:V1,sparseToDense:k1,spectral:z1,split:Zt,sqrt:$t,square:Pe,squaredDifference:Ed,squeeze:br,stack:Gt,step:co,stridedSlice:Xm,string:W1,sub:oe,sum:ie,tan:Ym,tanh:ar,tensor:cn,tensor1d:Rt,tensor2d:Qs,tensor3d:Zm,tensor4d:b1,tensor5d:w1,tensor6d:v1,tensorScatterUpdate:$1,tile:wn,topk:Qm,transpose:ke,truncatedNormal:Rd,unique:eg,unsortedSegmentSum:Dd,unstack:Cn,upperBound:S1,variable:tg,where:wt,whereAsync:ng,zeros:lt,zerosLike:Ee},Symbol.toStringTag,{value:"Module"}));const CM=(n,e,t,s=Lt)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(v("a",n,e,t),v("b",n,e,t))];case"AddN":return[s.addN(v("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(v("a",n,e,t),v("b",n,e,t))];case"Mul":return[s.mul(v("a",n,e,t),v("b",n,e,t))];case"RealDiv":case"Div":return[s.div(v("a",n,e,t),v("b",n,e,t))];case"DivNoNan":return[s.divNoNan(v("a",n,e,t),v("b",n,e,t))];case"FloorDiv":return[s.floorDiv(v("a",n,e,t),v("b",n,e,t))];case"Sub":return[s.sub(v("a",n,e,t),v("b",n,e,t))];case"Minimum":return[s.minimum(v("a",n,e,t),v("b",n,e,t))];case"Maximum":return[s.maximum(v("a",n,e,t),v("b",n,e,t))];case"Pow":return[s.pow(v("a",n,e,t),v("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(v("a",n,e,t),v("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const kM=(n,e,t,s=Lt)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(v("x",n,e,t))];case"Acos":return[s.acos(v("x",n,e,t))];case"Acosh":return[s.acosh(v("x",n,e,t))];case"Asin":return[s.asin(v("x",n,e,t))];case"Asinh":return[s.asinh(v("x",n,e,t))];case"Atan":return[s.atan(v("x",n,e,t))];case"Atan2":return[s.atan2(v("x",n,e,t),v("y",n,e,t))];case"Atanh":return[s.atanh(v("x",n,e,t))];case"Ceil":return[s.ceil(v("x",n,e,t))];case"Complex":return[s.complex(v("real",n,e,t),v("imag",n,e,t))];case"Cos":return[s.cos(v("x",n,e,t))];case"Cosh":return[s.cosh(v("x",n,e,t))];case"Elu":return[s.elu(v("x",n,e,t))];case"Erf":return[s.erf(v("x",n,e,t))];case"Exp":return[s.exp(v("x",n,e,t))];case"Expm1":return[s.expm1(v("x",n,e,t))];case"Floor":return[s.floor(v("x",n,e,t))];case"Log":return[s.log(v("x",n,e,t))];case"Log1p":return[s.log1p(v("x",n,e,t))];case"Imag":return[s.imag(v("x",n,e,t))];case"Neg":return[s.neg(v("x",n,e,t))];case"Reciprocal":return[s.reciprocal(v("x",n,e,t))];case"Real":return[s.real(v("x",n,e,t))];case"Relu":return[s.relu(v("x",n,e,t))];case"Round":return[s.round(v("x",n,e,t))];case"Selu":return[s.selu(v("x",n,e,t))];case"Sigmoid":return[s.sigmoid(v("x",n,e,t))];case"Sin":return[s.sin(v("x",n,e,t))];case"Sign":return[s.sign(v("x",n,e,t))];case"Sinh":return[s.sinh(v("x",n,e,t))];case"Softplus":return[s.softplus(v("x",n,e,t))];case"Sqrt":return[s.sqrt(v("x",n,e,t))];case"Square":return[s.square(v("x",n,e,t))];case"Tanh":return[s.tanh(v("x",n,e,t))];case"Tan":return[s.tan(v("x",n,e,t))];case"ClipByValue":return[s.clipByValue(v("x",n,e,t),v("clipValueMin",n,e,t),v("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(v("x",n,e,t))];case"Rsqrt":return[s.rsqrt(Et(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(v("x",n,e,t),v("alpha",n,e,t))];case"Prelu":return[s.prelu(v("x",n,e,t),v("alpha",n,e,t))];case"IsNan":return[s.isNaN(Et(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(Et(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(Et(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function An(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){I(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],o=e[s];I(r<0||o<0||r===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function Zb(n){return!(typeof n=="number"||n.some(e=>e<0))}function li(n,e,t){let s=Tf(n,t);const r=!Zb(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=Tf(o.shape,s)}),!Zb(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Tf(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:o}return t}class TM{constructor(e,t,s,r,o,a,i){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=he(0),pt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),An(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,pt(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return cn([],[0].concat(this.elementShape));const s=this.readMany(e);return An(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Gt(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return cn([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return An(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),nt(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Cn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:t.size/s,a=[];B(()=>{t=L(t,[1,s,o]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:r[l-1],0],h=[1,e[l],o];a[l]=L(Te(t,c,h),this.elementShape)}return a});const i=[];for(let l=0;l<e.length;l++)i[l]=l;this.writeMany(i,a)}}class Jr{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);An(t,o.shape,"TensorList shape mismatch: "),pt(o)}),this.idTensor=he(0),this.maxNumElements=r,pt(this.idTensor)}copy(){return new Jr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);An(e,this.elementShape,"TensorList shape mismatch: ");const r=li(this.elementShape,this.tensors,e);return B(()=>{const o=this.tensors.map(a=>L(a,r));return Gt(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=li(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,An(r.shape,e,"TensorList shape mismatch: "),L(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(An(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");pt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Jr([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);An(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=li(this.elementShape,this.tensors,t);return L(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);An(this.elementShape,t.shape,"TensorList shape mismatch: "),pt(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);An(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=li(this.elementShape,this.tensors,s);return e.length===0?cn([],[0].concat(r)):B(()=>{const o=e.map(a=>L(this.tensors[a],r));return Gt(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);An(this.elementShape,t,"TensorList shape mismatch: ");const s=li(this.elementShape,this.tensors,t);return this.size()===0?cn([],[0].concat(s)):B(()=>{const r=this.tensors.map(o=>L(o,s));return nt(r,0)})}}function EM(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);An(r,e,"TensorList shape mismatch: ");const o=Cn(n);return new Jr(o,e,s)}function AM(n,e,t,s){return new Jr([],n,e,s)}function RM(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new Jr([],t,n.dtype,s),a=Cn(n,0);return e.forEach((i,l)=>{o.setItem(i,a[l])}),o}function DM(n,e,t){let s=0;const r=e.map(c=>(s+=c,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),a=Tf(o,t),i=s===0?0:n.size/s,l=B(()=>{const c=[];n=L(n,[1,s,i]);for(let h=0;h<e.length;++h){const p=[0,h===0?0:r[h-1],0],f=[1,e[h],i];c[h]=L(Te(n,p,f),a)}return n.dispose(),c}),u=new Jr([],t,n.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}const OM=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=v("thenBranch",n,e,t),r=v("elseBranch",n,e,t),o=v("cond",n,e,t),a=v("args",n,e,t);return(await o.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=v("body",n,e,t),r=v("cond",n,e,t),o=v("args",n,e,t),a=await t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),i=o.map(c=>c.id);let l=await a[0].data();a.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let u=o;for(;l[0];){const c=u;u=await t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(p=>p.id);c.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const s=v("pred",n,e,t);return[$s(s)]}case"Switch":{const s=v("pred",n,e,t);let r=v("data",n,e,t);return r.kept||(r=$s(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>Et(r,e,t)!==void 0);if(s){const r=Et(s,e,t);return[$s(r)]}return}case"Enter":{const s=v("frameName",n,e,t),r=v("tensor",n,e,t);return t.enterFrame(s),[$s(r)]}case"Exit":{const s=v("tensor",n,e,t);return t.exitFrame(),[$s(s)]}case"NextIteration":{const s=v("tensor",n,e,t);return t.nextIteration(),[$s(s)]}case"TensorArrayV3":{const s=v("size",n,e,t),r=v("dtype",n,e,t),o=v("elementShape",n,e,t),a=v("dynamicSize",n,e,t),i=v("clearAfterRead",n,e,t),l=v("identicalElementShapes",n,e,t),u=v("name",n,e,t),c=new TM(u,r,s,o,l,a,i);return t.addTensorArray(c),[c.idTensor,he(1)]}case"TensorArrayWriteV3":{const s=v("tensorArrayId",n,e,t),r=v("index",n,e,t),o=v("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(r,o),[a.idTensor]}case"TensorArrayReadV3":{const s=v("tensorArrayId",n,e,t),r=v("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=v("tensorArrayId",n,e,t),r=v("indices",n,e,t),o=v("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=v("tensorArrayId",n,e,t),r=v("indices",n,e,t),o=v("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(r,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=v("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),o=v("dtype",n,e,t);return[r.concat(o)]}case"TensorArraySplitV3":{const s=v("tensorArrayId",n,e,t),r=v("tensor",n,e,t),o=v("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(o,r),[a.idTensor]}case"TensorArraySizeV3":{const s=v("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[he(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=v("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=v("tensorListId",n,e,t),r=v("index",n,e,t),o=v("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(r,o),[a.idTensor]}case"TensorListGetItem":{const s=v("tensorListId",n,e,t),r=v("index",n,e,t),o=v("elementShape",n,e,t),a=v("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=v("indices",n,e,t),r=v("tensor",n,e,t),o=v("elementShape",n,e,t),a=v("numElements",n,e,t),i=RM(r,s,o,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=v("elementShape",n,e,t),r=v("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const a=v(o,n,e,t),i=n.op==="TensorListReserve"?-1:a,l=AM(s,r,a,i);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=v("tensorListId",n,e,t),r=v("indices",n,e,t),o=v("elementShape",n,e,t),a=v("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,a,o)]}case"TensorListStack":{const s=v("tensorListId",n,e,t),r=v("elementShape",n,e,t),o=v("elementDType",n,e,t),a=v("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,o,a)]}case"TensorListFromTensor":{const s=v("tensor",n,e,t),r=v("elementShape",n,e,t),o=v("elementDType",n,e,t),a=EM(s,r,o);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=v("tensorListId",n,e,t),r=t.getTensorList(s.id),o=v("dtype",n,e,t),a=v("elementShape",n,e,t);return[r.concat(o,a)]}case"TensorListPushBack":{const s=v("tensorListId",n,e,t),r=v("tensor",n,e,t),o=t.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=v("tensorListId",n,e,t),r=v("elementShape",n,e,t),o=v("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=v("tensor",n,e,t),r=v("elementShape",n,e,t),o=v("lengths",n,e,t),a=DM(s,o,r);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=v("tensorListId",n,e,t),r=t.getTensorList(s.id);return[he(r.size(),"int32")]}case"TensorListResize":{const s=v("tensorListId",n,e,t),r=v("size",n,e,t),a=t.getTensorList(s.id).resize(r);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Jb(n,e,t){const[s,r]=v("fusedOps",n,e,t),o=s==="biasadd",a=!o,i=r==="prelu",l=s==="fusedbatchnorm",u=v("numArgs",n,e,t);if(o){if(i&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&o&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=v("strides",n,e,t),h=Qu(n,e,t),d=v("dataFormat",n,e,t).toUpperCase(),p=v("dilations",n,e,t);let[f,m]=v("args",n,e,t);a&&(m=f,f=void 0);const g=v("leakyreluAlpha",n,e,t);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:g}}const _M=(n,e,t,s=Lt)=>{switch(n.op){case"Conv1D":{const r=v("stride",n,e,t),o=v("pad",n,e,t),a=v("dataFormat",n,e,t).toUpperCase(),i=v("dilation",n,e,t);return[s.conv1d(v("x",n,e,t),v("filter",n,e,t),r,o,a,i)]}case"Conv2D":{const r=v("strides",n,e,t),o=Qu(n,e,t),a=v("dataFormat",n,e,t).toUpperCase(),i=v("dilations",n,e,t);return[s.conv2d(v("x",n,e,t),v("filter",n,e,t),[r[1],r[2]],o,a,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Jb(n,e,t);return[s.fused.conv2d({x:v("x",n,e,t),filter:v("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:a,dilations:i,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=Jb(n,e,t);return[s.fused.depthwiseConv2d({x:v("x",n,e,t),filter:v("filter",n,e,t),strides:[r[1],r[2]],pad:o,dataFormat:a,dilations:[i[1],i[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=v("outputShape",n,e,t),o=v("strides",n,e,t),a=Qu(n,e,t);return[s.conv2dTranspose(v("x",n,e,t),v("filter",n,e,t),r,[o[1],o[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=v("strides",n,e,t),o=Qu(n,e,t),a=v("dilations",n,e,t),i=v("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(v("input",n,e,t),v("filter",n,e,t),[r[1],r[2]],o,i,[a[1],a[2]])]}case"Conv3D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),a=v("dataFormat",n,e,t).toUpperCase(),i=v("dilations",n,e,t);return[s.conv3d(v("x",n,e,t),v("filter",n,e,t),[r[1],r[2],r[3]],o,a,[i[1],i[2],i[3]])]}case"AvgPool":{const r=v("strides",n,e,t),o=v("pad",n,e,t),a=v("kernelSize",n,e,t);return[s.avgPool(v("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=v("strides",n,e,t),o=v("pad",n,e,t),a=v("kernelSize",n,e,t);return[s.maxPool(v("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=v("strides",n,e,t),o=v("pad",n,e,t),a=v("kernelSize",n,e,t),i=v("includeBatchInIndex",n,e,t),{result:l,indexes:u}=s.maxPoolWithArgmax(v("x",n,e,t),[a[1],a[2]],[r[1],r[2]],o,i);return[l,u]}case"AvgPool3D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),a=v("kernelSize",n,e,t);return[s.avgPool3d(v("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),a=v("kernelSize",n,e,t);return[s.maxPool3d(v("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=v("strides",n,e,t),o=v("pad",n,e,t),a=v("dilations",n,e,t),i=r[1],l=r[2],u=a[1],c=a[2];return[s.dilation2d(v("x",n,e,t),v("filter",n,e,t),[i,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const FM=(n,e,t,s=Lt)=>{switch(n.op){case"Fill":{const r=v("shape",n,e,t),o=v("dtype",n,e,t),a=v("value",n,e,t);return[s.fill(r,a,o)]}case"LinSpace":{const r=v("start",n,e,t),o=v("stop",n,e,t),a=v("num",n,e,t);return[s.linspace(r,o,a)]}case"Multinomial":{const r=v("logits",n,e,t),o=v("numSamples",n,e,t),a=v("seed",n,e,t);return[s.multinomial(r,o,a)]}case"OneHot":{const r=v("indices",n,e,t),o=v("depth",n,e,t),a=v("onValue",n,e,t),i=v("offValue",n,e,t),l=v("dtype",n,e,t);return[s.oneHot(r,o,a,i,l)]}case"Ones":return[s.ones(v("shape",n,e,t),v("dtype",n,e,t))];case"OnesLike":return[s.onesLike(v("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(v("shape",n,e,t),v("dtype",n,e,t),v("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(v("shape",n,e,t),v("minval",n,e,t),v("maxval",n,e,t),v("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(v("shape",n,e,t),v("minval",n,e,t),v("maxval",n,e,t),v("seed",n,e,t))];case"Range":{const r=v("start",n,e,t),o=v("stop",n,e,t),a=v("step",n,e,t);return[s.range(r,o,a,v("dtype",n,e,t))]}case"TruncatedNormal":{const r=v("shape",n,e,t),o=v("mean",n,e,t),a=v("stdDev",n,e,t),i=v("seed",n,e,t);return[s.truncatedNormal(r,o,a,v("dtype",n,e,t),i)]}case"Zeros":return[s.zeros(v("shape",n,e,t),v("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(v("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Lp(n,e,t){const s=v("boxes",n,e,t),r=v("scores",n,e,t),o=v("maxOutputSize",n,e,t),a=v("iouThreshold",n,e,t),i=v("scoreThreshold",n,e,t),l=v("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:a,scoreThreshold:i,softNmsSigma:l}}const LM=async(n,e,t,s,r=Lt)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=Lp(n,e,t),h=await r.image.nonMaxSuppressionWithScoreAsync(o,a,i,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u}=Lp(n,e,t),c=v("padToMaxOutputSize",n,e,t),h=await r.image.nonMaxSuppressionPaddedAsync(o,a,i,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:i,iouThreshold:l,scoreThreshold:u}=Lp(n,e,t);return[await r.image.nonMaxSuppressionAsync(o,a,i,l,u)]}case"Where":{const o=r.cast(v("condition",n,e,t),"bool"),a=[await r.whereAsync(o)];return o.dispose(),a}case"ListDiff":return r.setdiff1dAsync(v("x",n,e,t),v("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const PM=(n,e,t,s=Lt)=>{switch(n.op){case"LowerBound":{const r=v("sortedSequence",n,e,t),o=v("values",n,e,t);return[s.lowerBound(r,o)]}case"TopKV2":{const r=v("x",n,e,t),o=v("k",n,e,t),a=v("sorted",n,e,t),i=s.topk(r,o,a);return[i.values,i.indices]}case"UpperBound":{const r=v("sortedSequence",n,e,t),o=v("values",n,e,t);return[s.upperBound(r,o)]}case"Unique":{const r=v("x",n,e,t),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=v("x",n,e,t),o=v("axis",n,e,t),a=s.unique(r,o);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const zM=(n,e,t,s=Lt)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=v("default",n,e,t);return[Et(n.name,e,t)||r];case"Placeholder":return[Et(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=v("x",n,e,t);return[$s(c)]}case"IdentityN":return v("x",n,e,t).map(c=>$s(c));case"Snapshot":const o=v("x",n,e,t);return[$s(o)];case"Shape":return[s.tensor1d(v("x",n,e,t).shape,"int32")];case"ShapeN":return v("x",n,e,t).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(v("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(v("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=v("x",n,e,t),i=v("data",n,e,t),l=v("message",n,e,t),u=v("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class MM{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=he(0),this.tensorMap=new Map,pt(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return he(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),B(()=>{const r=Cn(t),o=s.length,a=r.length;I(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let i=0;i<o;i++){const l=s[i],u=r[i];pt(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return B(()=>{const r=[];for(let o=0;o<s.length;o++){const a=s[o],i=this.findWithDefault(a,t);r.push(i)}return Gt(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const BM=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const o=v("keyDType",n,e,t),a=v("valueDType",n,e,t),i=new MM(o,a);return s.addHashTable(n.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=v("tableHandle",n,e,t,s),o=v("keys",n,e,t),a=v("values",n,e,t);return[await s.getHashTableById(r.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=v("tableHandle",n,e,t,s),o=v("keys",n,e,t),a=v("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=v("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const VM=(n,e,t,s=Lt)=>{switch(n.op){case"ResizeBilinear":{const r=v("images",n,e,t),o=v("size",n,e,t),a=v("alignCorners",n,e,t),i=v("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[o[0],o[1]],a,i)]}case"ResizeNearestNeighbor":{const r=v("images",n,e,t),o=v("size",n,e,t),a=v("alignCorners",n,e,t),i=v("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],a,i)]}case"CropAndResize":{const r=v("image",n,e,t),o=v("boxes",n,e,t),a=v("boxInd",n,e,t),i=v("cropSize",n,e,t),l=v("method",n,e,t),u=v("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,o,a,i,l,u)]}case"ImageProjectiveTransformV3":{const r=v("images",n,e,t),o=v("transforms",n,e,t),a=v("outputShape",n,e,t),i=v("fillValue",n,e,t),l=v("interpolation",n,e,t),u=v("fillMode",n,e,t);return[s.image.transform(r,o,l.toLowerCase(),u.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const WM=(n,e,t,s=Lt)=>{switch(n.op){case"Equal":return[s.equal(v("a",n,e,t),v("b",n,e,t))];case"NotEqual":return[s.notEqual(v("a",n,e,t),v("b",n,e,t))];case"Greater":return[s.greater(v("a",n,e,t),v("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(v("a",n,e,t),v("b",n,e,t))];case"Less":return[s.less(v("a",n,e,t),v("b",n,e,t))];case"LessEqual":return[s.lessEqual(v("a",n,e,t),v("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(v("a",n,e,t),v("b",n,e,t))];case"LogicalNot":return[s.logicalNot(v("a",n,e,t))];case"LogicalOr":return[s.logicalOr(v("a",n,e,t),v("b",n,e,t))];case"Select":case"SelectV2":return[s.where(v("condition",n,e,t),v("a",n,e,t),v("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(v("a",n,e,t),v("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const UM=(n,e,t,s=Lt)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(v("a",n,e,t),v("b",n,e,t),v("transposeA",n,e,t),v("transposeB",n,e,t))];case"Einsum":return[s.einsum(v("equation",n,e,t),...v("tensors",n,e,t))];case"Transpose":return[s.transpose(v("x",n,e,t),v("perm",n,e,t))];case"_FusedMatMul":const[r,o]=v("fusedOps",n,e,t),a=r==="biasadd",i=o==="prelu",l=v("numArgs",n,e,t),u=v("leakyreluAlpha",n,e,t);if(a){if(i&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=v("args",n,e,t);return[s.fused.matMul({a:v("a",n,e,t),b:v("b",n,e,t),transposeA:v("transposeA",n,e,t),transposeB:v("transposeB",n,e,t),bias:c,activation:o,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[s.linalg.bandPart(v("a",n,e,t),v("numLower",n,e,t),v("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const GM=(n,e,t,s=Lt)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(v("x",n,e,t),v("axis",n,e,t),v("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(v("x",n,e,t),v("mean",n,e,t),v("variance",n,e,t),v("offset",n,e,t),v("scale",n,e,t),v("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(v("x",n,e,t),v("mean",n,e,t),v("variance",n,e,t),v("offset",n,e,t),v("scale",n,e,t),v("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(v("x",n,e,t),v("radius",n,e,t),v("bias",n,e,t),v("alpha",n,e,t),v("beta",n,e,t))];case"Softmax":return[s.softmax(v("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(v("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const HM=(n,e,t,s=Lt)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(v("paramsNestedSplits",n,e,t),v("paramsDenseValues",n,e,t),v("indices",n,e,t),v("outputRaggedRank",n,e,t));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(v("starts",n,e,t),v("limits",n,e,t),v("splits",n,e,t));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(v("shape",n,e,t),v("values",n,e,t),v("defaultValue",n,e,t),v("rowPartitionTensors",n,e,t),v("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const jM=(n,e,t,s=Lt)=>{switch(n.op){case"Max":{const i=v("axis",n,e,t),l=v("keepDims",n,e,t);return[s.max(v("x",n,e,t),i,l)]}case"Mean":{const i=v("axis",n,e,t),l=v("keepDims",n,e,t);return[s.mean(v("x",n,e,t),i,l)]}case"Min":{const i=v("axis",n,e,t),l=v("keepDims",n,e,t);return[s.min(v("x",n,e,t),i,l)]}case"Sum":{const i=v("axis",n,e,t),l=v("keepDims",n,e,t);return[s.sum(v("x",n,e,t),i,l)]}case"All":{const i=v("axis",n,e,t),l=v("keepDims",n,e,t);return[s.all(v("x",n,e,t),i,l)]}case"Any":{const i=v("axis",n,e,t),l=v("keepDims",n,e,t);return[s.any(v("x",n,e,t),i,l)]}case"ArgMax":{const i=v("axis",n,e,t);return[s.argMax(v("x",n,e,t),i)]}case"ArgMin":{const i=v("axis",n,e,t);return[s.argMin(v("x",n,e,t),i)]}case"Prod":{const i=v("axis",n,e,t),l=v("keepDims",n,e,t);return[s.prod(v("x",n,e,t),i,l)]}case"Cumprod":{const i=v("axis",n,e,t),l=v("exclusive",n,e,t),u=v("reverse",n,e,t);return[s.cumprod(v("x",n,e,t),i,l,u)]}case"Cumsum":{const i=v("axis",n,e,t),l=v("exclusive",n,e,t),u=v("reverse",n,e,t);return[s.cumsum(v("x",n,e,t),i,l,u)]}case"Bincount":const r=v("x",n,e,t),o=v("weights",n,e,t),a=v("size",n,e,t);return[s.bincount(r,o,a)];case"DenseBincount":{const i=v("x",n,e,t),l=v("weights",n,e,t),u=v("size",n,e,t),c=v("binaryOutput",n,e,t);return[s.denseBincount(i,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const qM=(n,e,t,s=Lt)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=v("n",n,e,t),o=v("axis",n,e,t);let a=v("tensors",n,e,t);return a=a.slice(0,r),[s.concat(a,o)]}case"Gather":{const r=v("x",n,e,t),o=v("indices",n,e,t);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=v("axis",n,e,t),o=v("batchDims",n,e,t),a=v("x",n,e,t),i=v("indices",n,e,t);return[s.gather(a,s.cast(i,"int32"),r,o)]}case"Reverse":{const r=v("dims",n,e,t),o=[];for(let i=0;i<r.length;i++)r[i]&&o.push(i);const a=v("x",n,e,t);return[s.reverse(a,o)]}case"ReverseV2":{const r=v("axis",n,e,t),o=v("x",n,e,t);return[s.reverse(o,r)]}case"Slice":{const r=v("begin",n,e,t),o=v("size",n,e,t);return[s.slice(v("x",n,e,t),r,o)]}case"StridedSlice":{const r=v("begin",n,e,t),o=v("end",n,e,t),a=v("strides",n,e,t),i=v("beginMask",n,e,t),l=v("endMask",n,e,t),u=v("ellipsisMask",n,e,t),c=v("newAxisMask",n,e,t),h=v("shrinkAxisMask",n,e,t),d=v("x",n,e,t);return[s.stridedSlice(d,r,o,a,i,l,u,c,h)]}case"Pack":return B(()=>{const r=v("axis",n,e,t),o=v("tensors",n,e,t),a=o[0].shape,i=s.squeeze(o[0]).shape,l=o.map(u=>{const c=Ce(u.shape,a);if(!c&&!Ce(s.squeeze(u).shape,i))throw new Error("the input tensors shape does not match");return c?u:s.reshape(u,a)});return[s.stack(l,r)]});case"Unpack":{const r=v("axis",n,e,t),o=v("tensor",n,e,t);return s.unstack(o,r)}case"Tile":{const r=v("reps",n,e,t);return[s.tile(v("x",n,e,t),r)]}case"Split":case"SplitV":{const r=v("axis",n,e,t),o=v("numOrSizeSplits",n,e,t),a=v("x",n,e,t);return s.split(a,o,r)}case"ScatterNd":{const r=v("indices",n,e,t),o=v("values",n,e,t),a=v("shape",n,e,t);return[s.scatterND(r,o,a)]}case"GatherNd":{const r=v("x",n,e,t),o=v("indices",n,e,t);return[s.gatherND(r,o)]}case"SparseToDense":{const r=v("sparseIndices",n,e,t),o=v("outputShape",n,e,t),a=v("sparseValues",n,e,t),i=v("defaultValue",n,e,t);return[s.sparseToDense(r,a,o,a.dtype===i.dtype?i:s.cast(i,a.dtype))]}case"TensorScatterUpdate":{const r=v("indices",n,e,t),o=v("values",n,e,t),a=v("tensor",n,e,t);return[s.tensorScatterUpdate(a,r,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const KM=(n,e,t,s=Lt)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:a,reverseIndexMap:i}=s.sparse.sparseFillEmptyRows(v("indices",n,e,t),v("values",n,e,t),v("denseShape",n,e,t),v("defaultValue",n,e,t));return[r,o,a,i]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(v("inputIndices",n,e,t),v("inputShape",n,e,t),v("newShape",n,e,t));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(v("data",n,e,t),v("indices",n,e,t),v("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(v("data",n,e,t),v("indices",n,e,t),v("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const XM=(n,e,t,s=Lt)=>{switch(n.op){case"FFT":return[s.fft(v("x",n,e,t))];case"IFFT":return[s.ifft(v("x",n,e,t))];case"RFFT":return[s.rfft(v("x",n,e,t))];case"IRFFT":return[s.irfft(v("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const YM=(n,e,t,s=Lt)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(v("input",n,e,t),v("pattern",n,e,t),v("rewrite",n,e,t),v("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(v("data",n,e,t),v("dataSplits",n,e,t),v("separator",n,e,t),v("nGramWidths",n,e,t),v("leftPad",n,e,t),v("rightPad",n,e,t),v("padWidth",n,e,t),v("preserveShortSequences",n,e,t));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:a}=s.string.stringSplit(v("input",n,e,t),v("delimiter",n,e,t),v("skipEmpty",n,e,t));return[r,o,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(v("input",n,e,t),v("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const ZM=(n,e,t,s=Lt)=>{switch(n.op){case"Cast":return[s.cast(v("x",n,e,t),v("dtype",n,e,t))];case"ExpandDims":{const r=v("axis",n,e,t);return[s.expandDims(v("x",n,e,t),r)]}case"Squeeze":{const r=v("axis",n,e,t);return[s.squeeze(v("x",n,e,t),r)]}case"Reshape":return[s.reshape(v("x",n,e,t),v("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(v("x",n,e,t),v("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(v("x",n,e,t),v("padding",n,e,t),v("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(v("x",n,e,t),v("padding",n,e,t),v("constantValue",n,e,t))];case"SpaceToBatchND":{const r=v("blockShape",n,e,t),o=v("paddings",n,e,t);return[s.spaceToBatchND(v("x",n,e,t),r,o)]}case"BatchToSpaceND":{const r=v("blockShape",n,e,t),o=v("crops",n,e,t);return[s.batchToSpaceND(v("x",n,e,t),r,o)]}case"DepthToSpace":{const r=v("blockSize",n,e,t),o=v("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(v("x",n,e,t),r,o)]}case"BroadcastTo":return[s.broadcastTo(v("x",n,e,t),v("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(v("s0",n,e,t),v("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Qb(n,e,t,s,r=B){const o=((a,i,l)=>{switch(a.category){case"arithmetic":return r(()=>CM(a,i,l));case"basic_math":return r(()=>kM(a,i,l));case"control":return OM(a,i,l);case"convolution":return r(()=>_M(a,i,l));case"creation":return r(()=>FM(a,i,l));case"dynamic":return LM(a,i,l);case"evaluation":return r(()=>PM(a,i,l));case"image":return r(()=>VM(a,i,l));case"graph":return r(()=>zM(a,i,l));case"logical":return r(()=>WM(a,i,l));case"matrices":return r(()=>UM(a,i,l));case"normalization":return r(()=>GM(a,i,l));case"ragged":return r(()=>HM(a,i,l));case"reduction":return r(()=>jM(a,i,l));case"slice_join":return r(()=>qM(a,i,l));case"sparse":return r(()=>KM(a,i,l));case"spectral":return r(()=>XM(a,i,l));case"string":return r(()=>YM(a,i,l));case"transformation":return r(()=>ZM(a,i,l));case"hash_table":return BM(a,i,l,s);case"custom":const u=X$(a.op);if(u&&u.customExecutor)return u.customExecutor(new NM(a,i,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Cs(o)?o.then(a=>[].concat(a)):[].concat(o)}class e0{constructor(e={},t={},s={},r={},o){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function t0(n,e,t,s){const r=new Set,o=[];let a=null,i=null;const l=new Set,u=new Set(Object.keys(n).map(d=>ln(d)[0]));s=s||[];const c=new Set(s.map(d=>ln(d.name)[0])),h=[...e];for(;h.length>0;){const d=h.pop();if((Rr(d)||oB(d)||aB(d))&&a==null&&(a=d,i=a.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),t[d.name]==null&&!u.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:a,syncInputs:i}}function JM(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(g=>ln(g)[0]).map(g=>n.nodes[g]),o=n.initNodes||[],a=g=>t.has(typeof g=="string"?g:g.name);function i(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=i([...r,...n.weights,...o]).filter(a),u=i([...l,...Object.values(n.nodes)]).filter(a),c=new Map(u.map(g=>[g.name,g])),h={};for(const g of u){h[g.name]=h[g.name]||0;for(const y of g.children)a(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const d=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),p=[...d];for(;d.length>0;){const g=d.pop(),y=c.get(g);for(const x of y.children.filter(a))--h[x.name]===0&&(p.push(x.name),d.push(x.name))}const f=p.map(g=>c.get(g)),m=QM(f,l);return eB(m,l),m}function QM(n,e){const t=new Map(n.map(a=>[a.name,a])),s=e.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),i=t.get(a);for(const l of i.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(a=>r.has(a.name))}class Lu extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function eB(n,e){const t=new Map(n.map((i,l)=>[i.name,l])),s=new Set(e.map(i=>i.name)),r=i=>s.has(typeof i=="string"?i:i.name),o=new Set(n.map(i=>i.name)),a=i=>o.has(typeof i=="string"?i:i.name);for(const i of n){for(const l of i.children.filter(a)){if(!t.has(l.name))throw new Lu(`Child ${l.name} of node ${i.name} is unreachable.`);if(t.get(i.name)>t.get(l.name))throw new Lu(`Node ${i.name} is scheduled to run after its child ${l.name}.`)}if(!r(i))for(const l of i.inputs){if(!t.has(l.name))throw new Lu(`Input ${l.name} of node ${i.name} is unreachable.`);if(t.get(l.name)>t.get(i.name))throw new Lu(`Node ${i.name} is scheduled to run before its input ${l.name}.`)}}}function tB(n){const e=new Map(n.map((i,l)=>[i.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((i,l)=>Rr(i)?t:l),r=i=>{const l=s[e.get(i.name)];return l??-1},o=n.map((i,l)=>i.children.map(r).reduce((u,c)=>Math.max(u,c),s[l])),a=new Map;for(let i=0;i<n.length;++i){const l=o[i];if(l===t)continue;const u=n[i],c=n[l];a.has(c.name)||a.set(c.name,[]),a.get(c.name).push(u)}return a}const nB=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),sB=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),rB=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Rr(n){return nB.has(n.op)}function oB(n){return sB.has(n.op)}function aB(n){return rB.has(n.op)}class Bc{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Bc(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(o=>o.name).sort(),r=t.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=t0(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:a}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const u=t.map(h=>h.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const i=JM(this.graph,s),l=tB(i);return{orderedNodes:i,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return pt(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(d=>this.graph.nodes[ln(d)[0]]),o=t.map(d=>ln(d)[0]),a=new Set(o);let i=o.map(d=>this.graph.nodes[d]);i.length===0&&(i=this._outputs);const l=this.getCompilationKey(r,i);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,i),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},h={};return B(()=>{const d=new e0(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[x,w]=ln(y,d),b=[];b[w]=e[y],p[x]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(b))});const f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=u;for(const y of m){if(p[y.name])continue;const x=Qb(y,p,d,this._resourceManager);if(Cs(x))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,d,f,a,g.get(y.name))}return this.parent==null&&d.dispose(f),t.map(y=>Et(y,p,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,o,a,i){if(!(Rr(t)||a.has(e))){for(const l of s[e])l!=null&&(i[l.id]=(i[l.id]||0)+t.children.length);for(const l of t.inputs){if(Rr(l))continue;const u=Kb(l.name,s,r);if(u!=null)for(const c of u){if(!c||c.kept||o.has(c.id))continue;const h=i[c.id];h===1?(c.dispose(),delete i[c.id]):h!=null&&i[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,o,a){function i(l){return Rr(l)||o.has(l.name)}if(!(Rr(e)||a==null))for(const l of a){if(i(l))continue;const u=Kb(l.name,t,s);for(const c of u)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const a=new e0(this.weightMap,r,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,s),l=t.map(d=>Et(d,i,a)),u=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(i).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&a.dispose(h),l}async executeFunctionAsync(e,t,s){const r=e.reduce((o,a,i)=>(o[this.inputs[i].name]=a,o),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const o=Object.keys(e),a=o.map(b=>this.graph.nodes[ln(b)[0]]),i=s.map(b=>ln(b)[0]),l=new Set(i);let u=i.map(b=>this.graph.nodes[b]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:d,syncInputs:p}=t0(e,u,this.weightMap,this._initNodes),f=[...a,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{const[$,N]=ln(b),T=[];T[N]=e[b],m[$]=T});const g={},y=this.getFrozenTensorIds(m),x={};for(;f.length>0;){const b=this.processStack(a,f,t,m,x,y,l,g,c);await Promise.all(b)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=u.filter(b=>!Rr(b)&&!Et(b.name,m,t)).map(b=>b.name);if(w.length>0){let b="";throw d!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${o}]. Consider providing the following inputs: [${h}]. ${b}`)}return m}processStack(e,t,s,r,o,a,i,l,u){const c=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&v("isConstant",h.node,r,s)&&([d]=vs(h.node.name,s)),r[h.node.name]==null){const p=Qb(h.node,r,s,this._resourceManager);d||([d]=vs(h.node.name,s));const f=s.currentContext;Cs(p)?c.push(p.then(m=>(r[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),s.currentContext=f,this.checkTensorForDisposal(d,h.node,r,s,a,i,l),this.processChildNodes(h.node,t,s,r,o,u),m))):(r[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,r,s,a,i,l),this.processChildNodes(h.node,t,s,r,o,u))}else this.processChildNodes(h.node,t,s,r,o,u)}return c}processChildNodes(e,t,s,r,o,a){e.children.forEach(i=>{const[l]=vs(i.name,s);o[l]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(u=>!!Et(u,r,s))&&(o[l]=!0,t.push({contexts:s.currentContext,node:i})):i.inputNames.every(u=>!!Et(u,r,s))&&(o[l]=!0,t.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=ln(t),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const a=o.attrParams.shape.value,i=a.length===s.shape.length&&s.shape.every((l,u)=>a[u]===-1||a[u]===l);I(i,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&I(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const o in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[o];a!=null?r[a.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=ln(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return o!=null?o.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=ln(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class iB{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const lB="?tfjs-format=file",uB="model.json";class xx{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=gg){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new iB}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Cs(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Cw(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(r=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Bc(Xb.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=Xb.Instance.transformGraph(e.modelInitializer);this.initializer=new Bc(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Ae?[e]:e,s={};return t.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof Ae)&&!Array.isArray(e)){const o=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(o!=null)for(const a in o){const i=o[a];i.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,a)=>{var i,l,u;const c=(u=(l=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||l===void 0?void 0:l[a])===null||u===void 0?void 0:u.resourceId;return c!=null?o[a]=this.resourceIdToCapturedInput[c]:o[a]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const o=s[r],a=t[o];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ye(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function cB(n,e={},t=gg){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=dB(n));const s=new xx(n,e,t);return await s.load(),s}function hB(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,r]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const o=kc(s.weightsManifest),a=Qf(s,o,r);e=Ec(a)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=Ec(n);else throw new Error("Unknown model format");const t=new xx(e);return t.load(),t}function dB(n){return n.endsWith("/")||(n=n+"/"),`${n}${uB}${lB}`}const J$="4.22.0";var ec={exports:{}},pB=ec.exports,n0;function fB(){return n0||(n0=1,(function(n){(function(e,t,s){function r(l){var u=this,c=i();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function o(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function a(l,u){var c=new r(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&o(h,c),d.state=function(){return o(c,{})}),d}function i(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=a:this.alea=a})(pB,n)})(ec)),ec.exports}var tc={exports:{}},mB=tc.exports,s0;function gB(){return s0||(s0=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xor128=a})(mB,n)})(tc)),tc.exports}var nc={exports:{}},yB=nc.exports,r0;function xB(){return r0||(r0=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l.v=i.v,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xorwow=a})(yB,n)})(nc)),nc.exports}var sc={exports:{}},bB=sc.exports,o0;function wB(){return o0||(o0=1,(function(n){(function(e,t,s){function r(i){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,i)}function o(i,l){return l.x=i.x.slice(),l.i=i.i,l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.x&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xorshift7=a})(bB,n)})(sc)),sc.exports}var rc={exports:{}},vB=rc.exports,a0;function $B(){return a0||(a0=1,(function(n){(function(e,t,s){function r(i){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,f;return l.w=c=c+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(c^c>>>16)|0};function u(c,h){var d,p,f,m,g,y=[],x=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,x=Math.max(x,h.length)),f=0,m=-32;m<x;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,d=y[m&127]^=p+g,f=d==0?f+1:0);for(f>=128&&(y[(h&&h.length||0)&127]=-1),f=127,m=512;m>0;--m)p=y[f+34&127],d=y[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,y[f]=p^d;c.w=g,c.X=y,c.i=f}u(l,i)}function o(i,l){return l.i=i.i,l.w=i.w,l.X=i.X.slice(),l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.X&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xor4096=a})(vB,n)})(rc)),rc.exports}var oc={exports:{}},SB=oc.exports,i0;function IB(){return i0||(i0=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,i===Math.floor(i)?(l.a=i/4294967296|0,l.b=i|0):u+=i;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.a=i.a,l.b=i.b,l.c=i.c,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.tychei=a})(SB,n)})(oc)),oc.exports}var ac={exports:{}},NB=ac.exports,l0;function CB(){return l0||(l0=1,(function(n){(function(e,t,s){var r=256,o=6,a=52,i="random",l=s.pow(r,o),u=s.pow(2,a),c=u*2,h=r-1,d;function p(b,$,N){var T=[];$=$==!0?{entropy:!0}:$||{};var A=y(g($.entropy?[b,w(t)]:b??x(),3),T),k=new f(T),E=function(){for(var S=k.g(o),D=l,F=0;S<u;)S=(S+F)*r,D*=r,F=k.g(1);for(;S>=c;)S/=2,D/=2,F>>>=1;return(S+F)/D};return E.int32=function(){return k.g(4)|0},E.quick=function(){return k.g(4)/4294967296},E.double=E,y(w(k.S),t),($.pass||N||function(S,D,F,z){return z&&(z.S&&m(z,k),S.state=function(){return m(k,{})}),F?(s[i]=S,D):S})(E,A,"global"in $?$.global:this==s,$.state)}function f(b){var $,N=b.length,T=this,A=0,k=T.i=T.j=0,E=T.S=[];for(N||(b=[N++]);A<r;)E[A]=A++;for(A=0;A<r;A++)E[A]=E[k=h&k+b[A%N]+($=E[A])],E[k]=$;(T.g=function(S){for(var D,F=0,z=T.i,M=T.j,W=T.S;S--;)D=W[z=h&z+1],F=F*r+W[h&(W[z]=W[M=h&M+D])+(W[M]=D)];return T.i=z,T.j=M,F})(r)}function m(b,$){return $.i=b.i,$.j=b.j,$.S=b.S.slice(),$}function g(b,$){var N=[],T=typeof b,A;if($&&T=="object")for(A in b)try{N.push(g(b[A],$-1))}catch{}return N.length?N:T=="string"?b:b+"\0"}function y(b,$){for(var N=b+"",T,A=0;A<N.length;)$[h&A]=h&(T^=$[h&A]*19)+N.charCodeAt(A++);return w($)}function x(){try{var b;return d&&(b=d.randomBytes)?b=b(r):(b=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(b)),w(b)}catch{var $=e.navigator,N=$&&$.plugins;return[+new Date,e,N,e.screen,w(t)]}}function w(b){return String.fromCharCode.apply(0,b)}if(y(s.random(),t),n.exports){n.exports=p;try{d=Wm}catch{}}else s["seed"+i]=p})(typeof self<"u"?self:NB,[],Math)})(ac)),ac.exports}var Pp,u0;function kB(){if(u0)return Pp;u0=1;var n=fB(),e=gB(),t=xB(),s=wB(),r=$B(),o=IB(),a=CB();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=o,Pp=a,Pp}var Q$=kB();function TB(n,e){return Vc(n,e)}function Vc(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(Po(n)){const o=Array.isArray(n)?[]:{};s.add(n);for(const a in n){const i=n[a],l=Vc(i,e,t,s);o[a]=l}return s.delete(n),n.__proto__&&(o.__proto__=n.__proto__),o}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,r.value),r.value}function EB(n,e=tS){return eS(n,e)}function eS(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(Po(s)){const o=Array.isArray(s)?[]:{};t.add(s);for(const a in s){const i=n.map(u=>u[a]),l=eS(i,e,t);o[a]=l}return t.delete(s),o}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function tS(n){return n===null?null:Po(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function nS(n,e){const t=new Map;Vc(n,e,t);for(const r of Array.from(t.keys())){const o=t.get(r);if(Cs(o)){const a=await o;t.set(r,a)}}return Vc(n,e,t)}function Po(n){let e=!1;if(V().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof Ae)&&!(n instanceof Promise)&&!e)}function AB(n){return n==null||RB(n)||Array.isArray(n)||typeof n=="object"&&n instanceof Ae||dt(n)}function RB(n){return n===null||typeof n!="object"&&typeof n!="function"}function DB(n){return TB(n,OB)}function OB(n){return n instanceof Ae?{value:n.clone(),recurse:!1}:Po(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class sS{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}class fp extends sS{constructor(){super(fp.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let r=0;r<s;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}fp.INITIAL_CAPACITY=32;function rS(n){return new LB(n)}function bx(n){return new PB(n)}function _B(n,e){return new oS(n,e)}function FB(n,e=Ys.FAIL){return new jB(n,e)}class St{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new GB(this,e)}filter(e){return new WB(this,e)}map(e){return new UB(this,e)}mapAsync(e){return new c0(this,e)}serialMapAsync(e){return new c0(this,e).serial()}flatmap(e){return new HB(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new VB(this,e,t)}columnMajorBatch(e,t=!0,s=tS){return this.rowMajorBatch(e,t).map(o=>EB(o,s))}concatenate(e,t){return new oS(rS([this,e]),t)}take(e){return e<0||e==null?this:new BB(this,e)}skip(e){return e<0||e==null?this:new MB(this,e)}prefetch(e){return new aS(this,e)}shuffle(e,t){return new qB(this,e,t)}serial(){return new zB(this)}}class LB extends St{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:DB(e),done:!1}}}class PB extends St{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class zB extends St{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class MB extends St{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;ye(e.value)}return this.upstream.next()}}class BB extends St{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class VB extends St{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class WB extends St{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;ye(e.value)}}}class UB extends St{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Ts(e.value),s=this.transform(e.value),r=Ts(s);for(const o of t)ad(o,r)||o.dispose();return{value:s,done:!1}}}class GB extends St{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class c0 extends St{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Ts(e.value),s=await this.transform(e.value),r=Ts(s);for(const o of t)ad(o,r)||o.dispose();return{value:s,done:!1}}}class wx extends St{constructor(){super(),this.outputQueue=new fp,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class HB extends wx{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Ts(e.value),s=this.transform(e.value),r=Ts(s);this.outputQueue.pushAll(s);for(const o of t)ad(o,r)||o.dispose();return!0}}class oS extends St{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var Ys;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Ys||(Ys={}));class jB extends St{constructor(e,t=Ys.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function r(a){return a instanceof St?{value:a.next().then(l=>(t++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}const o=await nS(this.iterators,r);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case Ys.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Ys.SHORTEST:return{value:null,done:!0};case Ys.LONGEST:}return this.count++,{value:o,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class aS extends St{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new sS(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class qB extends aS{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Q$.alea(s||kt().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}class Ka{constructor(){this.size=null}batch(e,t=!0){const s=this;I(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),an(async()=>(await s.iterator()).columnMajorBatch(e,t,YB),r)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,an(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,an(async()=>(await t.iterator()).filter(r=>B(()=>e(r))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return an(async()=>(await t.iterator()).map(s=>B(()=>e(s))),this.size)}mapAsync(e){const t=this;return an(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return an(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,an(async()=>{const r=bx(async()=>({value:await t.iterator(),done:!1}));return _B(r.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,an(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,o=Q$.alea(t||kt().toString());return an(async()=>{let a=o.int32();return s&&(a+=o.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,an(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}Ka.MAX_BUFFER_SIZE=1e4;function an(n,e=null){return new class extends Ka{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function KB(n){return an(async()=>rS(n),n.length)}function XB(n){if(!Po(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return an(async()=>{const t=await nS(n,s=>{if(s instanceof Ka)return{value:s.iterator(),recurse:!1};if(Po(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return FB(t,Ys.SHORTEST)},e)}function YB(n){if(n===null)return null;const e=n[0];return AB(e)?{value:ZB(n),recurse:!1}:{value:null,recurse:!0}}function ZB(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof Ae?Gt(n):cn(n)}class iS extends Ka{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}const Pu='"',ui=Symbol("out"),h0=Symbol("field"),zu=Symbol("quote"),zp=Symbol("quoteafterquote"),d0=Symbol("quoteinquote");class lS extends Ka{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&I(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,o)=>(r[o]=r[o]+1||1,r),{}),s=Object.keys(t).filter(r=>t[r]>1);if(I(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new iS(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(I(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},r={};for(let o=0;o<this.fullColumnNames.length;o++){const a=this.fullColumnNames[o],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){const l=t[o];let u=null;if(l==="")if(i&&i.default!==void 0)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);u=void 0}else{const c=Number(l);if(isNaN(c))i&&i.dtype==="bool"?u=this.getBoolean(l):u=l;else if(!i||!i.dtype)u=c;else switch(i.dtype){case"float32":u=c;break;case"int32":u=Math.floor(c);break;case"bool":u=this.getBoolean(l);break;default:u=c}}i&&i.isLabel?r[a]=u:s[a]=u}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let r=0;const o=e.length;let a=ui;for(let i=0;i<o;i++)switch(a){case ui:switch(e.charAt(i)){case Pu:r=i+1,a=zu;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),a=ui;break;default:a=h0,r=i;break}break;case h0:e.charAt(i)===this.delimiter&&(s.push(e.substring(r,i)),a=ui,r=i+1);break;case zu:e.charAt(i)===Pu&&(a=zp);break;case zp:switch(e.charAt(i)){case this.delimiter:s.push(e.substring(r,i-1)),a=ui,r=i+1;break;case Pu:a=zu;break;default:a=d0;break}break;case d0:e.charAt(i)===Pu&&(a=zu);break}if(a===zp?s.push(e.substring(r,o-1)):s.push(e.substring(r)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class vx extends St{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!V().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new vx(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(r=>{const o=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(o),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((r,o)=>s.set(r,o*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(G(t));return s.set(e,s.length-e.length),cn(s,t)}}class $x extends St{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Rt([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,o=(1-s)/2,a=(1-r)/2,i=o+s,l=r+a;this.cropBox=Qs([a,o,l,i],[1,4])}else this.cropBox=Qs([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!V().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new $x(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&I(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Z1(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return B(()=>{const t=Tt(ee(e,"float32"),0);let s;s=Rn.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return L(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class uS{}class cS extends St{split(e){return new JB(this,e)}}class JB extends cS{constructor(e,t){super(),this.upstream=e,this.impl=new QB(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class QB extends wx{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}class eV extends St{decodeUTF8(){return new tV(this)}}class tV extends cS{constructor(e){super(),this.upstream=e,this.impl=new nV(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class nV extends wx{constructor(e){if(super(),this.upstream=e,V().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return V().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}class hS extends eV{constructor(e,t={}){super(),this.file=e,this.options=t,I(e instanceof Uint8Array||(V().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{const o=new FileReader;o.onload=i=>{let l=o.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(l)},o.onabort=i=>s(new Error("Aborted")),o.onerror=i=>s(new Error(i.type));const a=this.file.slice(this.offset,r);o.readAsArrayBuffer(a)}this.offset=r}),done:!1}}}async function sV(n,e={},t){let s,r;typeof n=="string"?s=n:(s=n.url,r=rV(n));const o=await gw(s,r);if(o.ok){const a=new Uint8Array(await o.arrayBuffer());return new hS(a,e)}else throw new Error(o.statusText)}const rV=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});function dS(n){return typeof n=="string"&&n.slice(0,7)==="file://"}class pS extends uS{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(dS(this.input)&&V().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new hS(this.input,this.options)}}class fS extends uS{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return dS(this.url)?new pS(this.url,this.fileOptions).iterator():sV(this.url,this.fileOptions)}}function oV(n,e={}){return new lS(new fS(n),e)}function aV(n){const e=bx(n);return an(async()=>e)}function iV(n){return an(async()=>{const e=await n();return bx(()=>e.next())})}async function lV(n,e){return $x.create(n,e)}async function uV(n){return vx.create(n)}const mS="4.22.0";const cV=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:lS,Dataset:Ka,FileDataSource:pS,TextLineDataset:iS,URLDataSource:fS,array:KB,csv:oV,func:aV,generator:iV,microphone:uV,version_data:mS,webcam:lV,zip:XB},Symbol.toStringTag,{value:"Module"}));function le(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&I(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const hV=Od;class vu extends Yc{nextDataId(){return vu.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new zf(this,Bn())}write(e,t,s){this.firstUse&&(this.firstUse=!1,V().get("IS_NODE")&&xn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&rs(s[0])){const o=s.map(a=>as(a));r=this.write(o,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,o){this.data.set(e,{values:t,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return Rs(r,o)}return rw(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>ks(r));return we(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return we(e.shape,e.dtype,t)}makeOutput(e,t,s){return Bn().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=kt();return e(),{kernelMs:kt()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){le([e],"where");const t=this.readSync(e.dataId);return hV(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}vu.nextDataId=0;function gS(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const dV=n=>{const{x:e}=n.inputs,t=n.backend;le(e,"abs");let s=new Float32Array(G(e.shape));const r=t.data.get(e.dataId).values;return s=gS(r),t.makeOutput(s,e.shape,e.dtype)},pV={kernelName:Bi,backendName:"cpu",kernelFunc:dV};function at(n){return(e,t,s,r,o)=>{const a=xe(e,t),i=a.length,l=de(a),u=G(a),c=vt(o,u),h=e.length,d=t.length,p=de(e),f=de(t),m=jr(e,a),g=jr(t,a);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=n(s[y%s.length],r[y%r.length]);else for(let y=0;y<c.length;++y){const x=ao(y,i,l),w=x.slice(-h);m.forEach(T=>w[T]=0);const b=Un(w,h,p),$=x.slice(-d);g.forEach(T=>$[T]=0);const N=Un($,d,f);c[y]=n(s[b],r[N])}return[c,a]}}function un(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,i=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(i.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",o),imag:t.makeTensorInfo(r.shape,"float32",a)},i}const fV={kernelName:oh,backendName:"cpu",kernelFunc:un};function Wc(n,e,t="float32"){if(t==="complex64"){const r=Wc(n,e,"float32"),o=Wc(n,e,"float32");return un({inputs:{real:r,imag:o},backend:n})}const s=Dt(G(e),t);return n.makeTensorInfo(e,t,s)}function ms(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const mV={kernelName:ia,backendName:"cpu",kernelFunc:ms};function Qr(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const gV={kernelName:zh,backendName:"cpu",kernelFunc:Qr};function yS(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=pr([0],t),[o,a]=at((i,l)=>i!==l?1:0)(e,[],n,r,"bool");return[a,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function dr(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return ms({inputs:{x:r},backend:t});const c=Wc(t,r.shape,r.dtype),h=dr({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),d=un({inputs:{real:h,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){const c=Qr({inputs:{input:r},backend:t}),h=dr({inputs:{x:c},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(c),h}if(!Vf(r.dtype,o)){const c=ms({inputs:{x:r},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:o}}const a=t.data.get(r.dataId).values,[i,l,u]=yS(a,r.shape,r.dtype,o);return t.makeTensorInfo(i,l,u)}const yV={kernelName:Ko,backendName:"cpu",kernelFunc:dr};function yt(n,e,t,s){return t==null?({inputs:r,backend:o})=>{const{a,b:i}=r,l=o;le([a,i],n);const u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,h=a.dtype==="string"?Ds(u):u,d=a.dtype==="string"?Ds(c):c,p=s||a.dtype,[f,m]=e(a.shape,i.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:({inputs:r,backend:o})=>{const{a,b:i}=r,l=o;if(a.dtype==="complex64"||i.dtype==="complex64"){const u=dr({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=dr({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,x=g.complexTensorInfos.imag,w=l.data.get(y.dataId).values,b=l.data.get(x.dataId).values,[$,N,T]=t(a.shape,i.shape,p,f,w,b),A=l.makeTensorInfo(T,"float32",$),k=l.makeTensorInfo(T,"float32",N),E=un({inputs:{real:A,imag:k},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(k),E}else{const u=l.data.get(a.dataId).values,c=l.data.get(i.dataId).values,h=s||a.dtype,[d,p]=e(a.shape,i.shape,u,c,h);return l.makeTensorInfo(p,h,d)}}}function Sx(n){return(e,t,s,r,o,a)=>{const i=xe(e,t),l=G(i),u=i.length,c=de(i),h=vt("float32",l),d=vt("float32",l),p=jr(e,i),f=jr(t,i),m=Rs(s,r),g=Rs(o,a),y=e.length,x=de(e),w=t.length,b=de(t);if(p.length+f.length===0)for(let $=0;$<h.length;$++){const N=$%m.length,T=$%g.length,A=n(m[N*2],m[N*2+1],g[T*2],g[T*2+1]);h[$]=A.real,d[$]=A.imag}else for(let $=0;$<h.length;$++){const N=ao($,u,c),T=N.slice(-y);p.forEach(D=>T[D]=0);const A=Un(T,y,x),k=N.slice(-w);f.forEach(D=>k[D]=0);const E=Un(k,w,b),S=n(m[A*2],m[A*2+1],g[E*2],g[E*2+1]);h[$]=S.real,d[$]=S.imag}return[h,d,i]}}const xS=at(((n,e)=>n+e)),xV=Sx(((n,e,t,s)=>({real:n+t,imag:e+s}))),zo=yt(io,xS,xV),bV={kernelName:io,backendName:"cpu",kernelFunc:zo};function Ix(n,e,t,s,r){const o=G(s),a=Dt(r,t);for(let i=0;i<n.length;i++){const l=n[i];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o>0?a[l]+=e[i]:a[l]+=1)}return a}function bS(n,e,t,s=!1){const r=n.shape[0],o=n.shape[1],a=we([r,t],e.dtype);for(let i=0;i<r;i++)for(let l=0;l<o;l++){const u=n.get(i,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(s?a.set(1,i,u):e.size>0?a.set(a.get(i,u)+e.get(i,l),i,u):a.set(a.get(i,u)+1,i,u))}return a}const wS=at(((n,e)=>n&e)),wV=yt(Ki,wS),vV={kernelName:Ki,backendName:"cpu",kernelFunc:wV};function ys(n){return(e,t,s)=>{const r=tt(t,e.length);for(let o=0;o<e.length;++o)r[o]=n(e[o],s);return r}}function Fe(n,e,t){const s=ys(e);return vr(n,s,t)}function vr(n,e,t){return({inputs:s,attrs:r,backend:o})=>{const{x:a}=s;le(a,n);const i=o,l=i.data.get(a.dataId).values;let u;if(a.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Ds(l)}else u=l;const c=t||a.dtype,h=e(u,c,r);return i.makeTensorInfo(a.shape,c,h)}}const vS=ys(n=>Math.ceil(n)),$V=vr(Xo,vS),SV={kernelName:Xo,backendName:"cpu",kernelFunc:$V};function $S(n,e,t,s){const r=tt(t,G(e));if(s&&t!=="string"){let o=0;n.forEach(a=>{const i=G(a.shape);r.set(a.vals,o),o+=i})}else{let o=0;n.forEach(a=>{const i=t==="string"?Ds(a.vals):a.vals;let l=0;for(let u=0;u<a.shape[0];++u){const c=u*e[1]+o;for(let h=0;h<a.shape[1];++h)r[c+h]=i[l++]}o+=a.shape[1]})}return r}const SS=at((n,e)=>n===e?1:0),IS=yt(sl,SS,null,"bool"),IV={kernelName:sl,backendName:"cpu",kernelFunc:IS};const NS=ys(n=>Math.exp(n)),CS=vr(na,NS,"float32"),NV={kernelName:na,backendName:"cpu",kernelFunc:CS};const kS=ys(n=>Math.expm1(n)),CV=vr(sa,kS),kV={kernelName:sa,backendName:"cpu",kernelFunc:CV};const TS=ys(n=>Math.floor(n)),TV=vr(ra,TS),EV={kernelName:ra,backendName:"cpu",kernelFunc:TV};const ES=at((n,e)=>Math.floor(n/e)),AV=yt(oa,ES,null,"int32"),RV={kernelName:oa,backendName:"cpu",kernelFunc:AV};function AS(n,e,t,s,r,o,a,i,l){const u=we([s,o],t);for(let c=0;c<s;c++){const h=[];let d=0;for(let p=0;p<r;p++){const f=n[c*r+p];d+=f*a[p],h.push(f)}if(d<0||d>=l/o)throw new Error(`Invalid indices: ${h} does not index into ${i}`);for(let p=0;p<o;p++)u.values[c*o+p]=e.get(...e.indexToLoc(d*o+p))}return u}function RS(n,e,t){const s=we(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),i=a[0],l=a[2],u=e.locToIndex([i,l]);a[2]=e.values[u];const c=n.locToIndex(a);0<=c&&c<n.values.length&&(s.values[r]=n.values[c])}return s}const DS=at((n,e)=>n>e?1:0),DV=yt(il,DS,null,"bool"),OV={kernelName:il,backendName:"cpu",kernelFunc:DV};const OS=at((n,e)=>n>=e?1:0),_V=yt(aa,OS,null,"bool"),FV={kernelName:aa,backendName:"cpu",kernelFunc:_V};const _S=at((n,e)=>n<e?1:0),LV=yt(ul,_S,null,"bool"),PV={kernelName:ul,backendName:"cpu",kernelFunc:LV};const FS=at((n,e)=>n<=e?1:0),zV=yt(cl,FS,null,"bool"),MV={kernelName:cl,backendName:"cpu",kernelFunc:zV};function LS(n,e,t){const s=(e-n)/(t-1),r=Dt(t,"float32");r[0]=n;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}const PS=ys(n=>Math.log(n)),BV=vr(ha,PS),VV={kernelName:ha,backendName:"cpu",kernelFunc:BV};function zS(n,e,t,s){const r=vt(s,G(t));for(let o=0;o<r.length;++o){const a=o*e;let i=n[a];for(let l=0;l<e;++l){const u=n[a+l];(Number.isNaN(u)||u>i)&&(i=u)}r[o]=i}return r}const MS=at(((n,e)=>Math.max(n,e))),WV=yt(pa,MS),UV={kernelName:pa,backendName:"cpu",kernelFunc:WV};const BS=at(((n,e)=>Math.min(n,e))),GV=yt(fa,BS),HV={kernelName:fa,backendName:"cpu",kernelFunc:GV};const Nx=at(((n,e)=>n*e)),jV=Sx(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),mp=yt(ga,Nx,jV),qV={kernelName:ga,backendName:"cpu",kernelFunc:mp};function VS(n,e,t){const s=_s(-1,t);return Nx([],e,s,n,t)}function KV(n){const{inputs:e,backend:t}=n,{x:s}=e;le(s,"neg");const r=t.data.get(s.dataId).values,[o,a]=VS(r,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}const XV={kernelName:vl,backendName:"cpu",kernelFunc:KV};const WS=at(((n,e)=>n!==e?1:0)),YV=yt($l,WS,null,"bool"),ZV={kernelName:$l,backendName:"cpu",kernelFunc:YV};function Cx(n,e,t,s,r){const o=e.length,a=G(e),i=de(e),l=de(r),u=vt(t,G(r));for(let c=0;c<a;++c){const h=ao(c,o,i),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[s[f]];const p=Un(d,o,l);u[p]=n[c]}return u}function sn(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:o}=t;le(r,"transpose");const a=r.shape.length,i=new Array(a);for(let h=0;h<i.length;h++)i[h]=r.shape[o[h]];const l=s.data.get(r.dataId).values,u=Cx(l,r.shape,r.dtype,o,i);return{dataId:s.write(u,i,r.dtype),shape:i,dtype:r.dtype}}const JV={kernelName:Lr,backendName:"cpu",kernelFunc:sn};function US(n,e,t,s){const[r,o]=Nt(n,s),a=Jt(e,"int32"),i=Dt(G(r),a),l=G(o);for(let u=0;u<i.length;++u){const c=u*l;let h=1;for(let d=0;d<l;++d)h*=t[c+d];i[u]=h}return{outVals:i,outShape:r,outDtype:a}}function QV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;le(r,"prod");const i=r.shape.length,l=Ie(o,r.shape),u=Qe(l,i);let c=l,h=r;const d=[];u!=null&&(h=sn({inputs:{x:r},backend:t,attrs:{perm:u}}),d.push(h),c=rt(c.length,i));const p=t.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=US(h.shape,h.dtype,p,c);let y=m;return a&&(y=st(m,l)),d.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(y,g,f)}const eW={kernelName:Tl,backendName:"cpu",kernelFunc:QV};function tW(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const o=ao(r,e.length,de(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${t})`)}})}function nW(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function sW(n,e,t,s){const r=[];let o=0;const a=e.length-1+t.length,i=new Array(a).fill(null).map(()=>[0]);nW(t,s);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)i[u].push(h*c)}for(let u=0;u<n.length;++u){let c=n[u],h=n[u]+1;for(let d=0;d<t.length;++d){const p=t[d],f=d+e.length-1;if(f>=0){const m=i[f],g=m[m.length-1]-p[c];for(let y=c;y<h;++y)i[f].push(p[y+1]+g)}c=p[c],h=p[h]}h!==c&&(r.push([c,h]),o+=h-c)}return{outSplits:i,valueSlices:r,numValues:o}}function rW(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=tt("int32",s);e.push(r),n[t].forEach((o,a)=>r[a]=o)}return e}function p0(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function oW(n,e,t,s,r,o){const a=p0(e,2)[1],i=p0(o,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let h=0;h<s;++h)r[l*i+h]=n[c*a+h];++l}}function aW(n,e,t,s,r){const o=e.slice();o[0]=r;const a=tt(t,G(o)),i=n.length,l=i===0?0:i/e[0];return oW(n,e,s,l,a,o),[a,o]}function GS(n,e,t,s,r,o,a,i){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(tW(o,a,l),s.length===0)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:h,numValues:d}=sW(o,a,n,u),p=rW(c),f=aW(t,s,r,h,d);return[p,f[0],f[1]]}const f0=2147483647;function HS(n,e,t,s,r,o,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const i=e.length===0,l=r.length===0,u=a.length===0,c=[];i||c.push(e[0]),l||c.push(r[0]),u||c.push(a[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=tt("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const y=i?n[0]:n[g],x=l?s[0]:s[g],w=u?o[0]:o[g];if(w===0)throw new Error("Requires delta != 0");let b;if(w>0&&x<y||w<0&&x>y)b=0;else if(b=Math.ceil(Math.abs((x-y)/w)),b>f0)throw new Error(`Requires ((limit - start) / delta) <= ${f0}`);d[g+1]=d[g]+b}const p=d[h],f=tt(t,p);let m=0;for(let g=0;g<h;++g){const y=d[g+1]-d[g];let x=i?n[0]:n[g];const w=u?o[0]:o[g];for(let b=0;b<y;++b)f[m++]=x,x+=w}return[d,f]}var En=Wn;class Uc{constructor(e,t,s,r,o,a,i,l,u,c){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=cv(c),this.raggedRank=hv(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===En.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===En.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case En.VALUE_ROWIDS:return Uc.getMaxWidthValueRowID(t);case En.ROW_SPLITS:return Uc.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${En[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],o=0;for(let a=1;a<t;++a){const i=e[a];i!==r&&(r=i,o=Math.max(a-s,o),s=a)}return Math.max(t-s,o)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return g0(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;dv(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=uv(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),o=[];let a=0;for(let i=0;i<r;++i,a+=t)o.push(a);for(let i=r;i<e;++i)o.push(-1);return I(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,s,r){const o=e.length,a=[];for(let i=0;i<o-1;++i){const l=e[i+1]-e[i];let u=Math.min(r,l),c=t[i];c===-1&&(u=0);for(let h=0;h<u;++h)a.push(c),c+=s;for(let h=0;h<l-u;++h)a.push(-1)}if(o>0&&a.length!==e[o-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const o=e.length,a=[];if(o===0)return[];let i=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];a.push(u);for(let c=1;c<o;++c){const h=e[c];if(h===l)u>=0&&(++i,i<r?u+=s:u=-1);else{if(i=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const o=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case En.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,s,r);case En.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,s,r);default:throw new Error(`Unsupported partition type: ${En[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case En.FIRST_DIM_SIZE:return e[0];case En.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case En.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${En[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const o=g0(s,!1),a=tt(this.valuesDType,G(o));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,a,o)}return[o,a]}setOutput(e,t,s,r){if(s.length===0)return;const o=this.values,a=s;let i=r.slice();i=i.slice(e+1);const l=G(i),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const f=this.defaultValueShape;B(()=>{const m=L(c,f);c=Pr(m,i).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=u;++f){let m=f<u?t[f]:-1;if(m===p){++p;continue}if(d<p){const g=o.subarray(h*l),y=a.subarray(d*l),x=(p-d)*l;m0(y,g,x)}if(f>=u){const g=s.length;m=Math.floor(g/l)}if(m>p)if(this.defaultValue.length===1)a.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){const g=a.slice(p*l);m0(g,c,l),++p}m<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function m0(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function g0(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function jS(n,e,t,s,r,o,a,i,l,u){return new Uc(n,e,t,s,r,o,a,i,l,u).compute()}function qS(n,e,t,s){const r=n===e,o=n<e&&t<0,a=e<n&&t>1;if(r||o||a)return Dt(0,s);const i=Math.abs(Math.ceil((e-n)/t)),l=Dt(i,s);e<n&&t===1&&(t=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}const KS=ys(n=>1/Math.sqrt(n)),iW=vr($a,KS),lW={kernelName:$a,backendName:"cpu",kernelFunc:iW};function _r(n,e,t,s,r,o,a,i,l,u){const c=[s/r,r],h=n.values,d=e.values;if(s===0)return we(t,e.dtype);const p=l instanceof ct?l:we(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<o;f++){const m=[];let g=0;for(let y=0;y<a;y++){const x=h[f*a+y];m.push(x),g+=x*i[y]}if(g<0||g>=s/r)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<r;y++)u?p.values[g*r+y]+=d[f*r+y]:p.values[g*r+y]=e.rank===0?d[0]:d[f*r+y]}return p}const uW=ys(n=>1/(1+Math.exp(-n))),XS=Fe(ka,n=>1/(1+Math.exp(-n))),cW={kernelName:ka,backendName:"cpu",kernelFunc:XS};function YS(n,e,t,s,r){const o=bg(s,e,t),a=G(t),i=de(s);if(o){const h=wg(e,i);return r==="string"?n.slice(h,h+a):n.subarray(h,h+a)}const l=r==="string"?Ds(n):n,u=we(s,r,l),c=we(t,r);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),p=d.map((f,m)=>f+e[m]);c.set(u.get(...p),...d)}return r==="string"?Dv(c.values):c.values}function eo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:a}=s;le(r,"slice");const[i,l]=Gd(r,o,a);yg(r,i,l);const u=t.data.get(r.dataId).values,c=YS(u,i,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,c)}const hW={kernelName:_l,backendName:"cpu",kernelFunc:eo};function ZS(n,e,t,s,r,o,a){const i=e[0],l=o[0],u=new Array(l),c=new Array(i),h=e[1];if(l===0){if(i!==0)throw new Error(bv(i));const g=tt(t,0),y=tt(r,0);return[g,[0,h],y,u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<i;++g){const y=n[g*h];if(y<0)throw new Error(wv(g,y));if(y>=l)throw new Error(vv(g,y,l));++f[y],d=d&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){const y=f[g]===0;u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const g=n,y=s;for(let x=0;x<i;++x)c[x]=x;return[g,[i,h],y,u,c]}else{const g=f[l-1],y=tt(t,g*h),x=tt(r,g),w=new Array(l).fill(0);for(let b=0;b<i;++b){const $=n[b*h],N=w[$],T=($===0?0:f[$-1])+N;w[$]++;for(let A=0;A<h;++A)y[T*h+A]=n[b*h+A];x[T]=s[b],c[b]=T}for(let b=0;b<l;++b)if(w[b]===0){const N=b===0?0:f[b-1];y[N*h+0]=b;for(let T=1;T<h;++T)y[N*h+T]=0;x[N]=a}return[y,[g,h],x,u,c]}}function JS(n,e,t,s,r){const o=G(s),a=e[0],i=r.length,l=[];let u=1,c=-1;for(let g=0;g<i;++g){const y=r[g];if(y===-1){if(c!==-1)throw new Error($v(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(Sv(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(Iv());const g=Math.trunc(o/u);if(u*g!==o)throw new Error(Nv(s,l));l[c]=g}if(G(l)!==o)throw new Error(Cv(s,l));const d=s.length,p=[];if(d>0){p[d-1]=1;for(let g=d-2;g>=0;--g)p[g]=p[g+1]*s[g+1]}const f=[];if(i>0){f[i-1]=1;for(let g=i-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}const m=tt(t,a*i);for(let g=0;g<a;++g){let y=0;for(let x=0;x<d;++x)y+=n[g*d+x]*p[x];for(let x=0;x<i;++x)m[g*i+x]=Math.trunc(y/f[x]),y%=f[x]}return[m,[a,i],l]}function kx(n,e,t,s,r,o=!1,a=0){const i=s.length,l=[e[0],n.length/e[0]],u=l[1],h=i>0?r[i-1]+1:0;if(h<0)throw new Error(lf());const d=e.slice();d[0]=h;const p=d.reduce((w,b)=>w*b,1),f=tt(t,p);if(i===0)return h>0&&f.fill(a),[f,d];if(h<=0)throw new Error(lf());let m=0,g=1,y=0,x=r[m];for(;;){let w=0;if(g<i){if(w=r[g],x===w){++g;continue}if(x>=w)throw new Error(kv())}if(x<0||x>=h)throw new Error(Tv(x,h));x>y&&f.fill(a,y*u,x*u);for(let b=m;b<g;++b){const $=s[b];if($<0||$>=l[0])throw new Error(Ev(b,s[b],l[0]));for(let N=0;N<u;N++)f[x*u+N]+=n[$*u+N]}if(o)for(let b=0;b<u;b++)f[x*u+b]/=g-m;if(m=g,++g,y=x+1,x=w,g>i)break}return y<h&&f.fill(a,y*u,h*u),[f,d]}const dW=ys(n=>Math.sqrt(n)),pW=Fe(Ea,n=>Math.sqrt(n)),fW={kernelName:Ea,backendName:"cpu",kernelFunc:pW};const QS=at(((n,e)=>{const t=n-e;return t*t})),mW=yt(Aa,QS),gW={kernelName:Aa,backendName:"cpu",kernelFunc:mW};const eI=ys((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),yW=vr(Ml,eI),xW={kernelName:Ml,backendName:"cpu",kernelFunc:yW};function tI(n,e,t,s){const r=we(n,e.dtype);for(let o=0;o<r.size;o++){const a=r.indexToLoc(o),i=new Array(a.length);for(let l=0;l<i.length;l++)i[l]=a[l]*t[l]+s[l];r.set(e.get(...i),...a)}return r}class bW{constructor(e,t,s,r,o,a){this.separator=as(e),this.nGramWidths=t,this.leftPad=as(s),this.rightPad=as(r),this.padWidth=o,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,o,a){for(let i=0;i<o;++i){const l=this.getPadWidth(a),u=Math.max(0,l-i),c=Math.max(0,l-(o-(i+1))),h=a-(u+c),d=t+(u>0?0:i-l);let p=0;p+=u*this.leftPad.length;for(let x=0;x<h;++x)p+=e[d+x].length;p+=c*this.rightPad.length;const f=u+c+h-1;p+=f*this.separator.length,s[r+i]=new Uint8Array(p);const m=s[r+i];let g=0;const y=x=>x.forEach(w=>m[g++]=w);for(let x=0;x<u;++x)y(this.leftPad),y(this.separator);for(let x=0;x<h-1;++x)y(e[d+x]),y(this.separator);if(h>0){y(e[d+h-1]);for(let x=0;x<c;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<c-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=t[u]>=l;if(c=c&&t[u]<=s,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${s}]`);l=t[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const o=r-1,a=tt("int32",r);if(s===0||r===0){const l=new Array(s);for(let u=0;u<=o;++u)a[u]=0;return[l,a]}a[0]=0;for(let l=1;l<=o;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),a[l]=a[l-1]+c}const i=new Array(a[o]);for(let l=0;l<o;++l){const u=t[l];let c=a[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,u,i,c,p,h),c+=p}),this.preserveShort&&c===a[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(e,u,i,c,1,d)}}return[i,a]}}function nI(n,e,t,s,r,o,a,i){return new bW(t,s,r,o,a,i).compute(n,e)}function wW(n,e,t,s){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)s.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let a=n.indexOf(o);for(;a!==-1;){const i=n.subarray(0,a);(!t||i.length!==0)&&s.push(i),n=n.subarray(a+1),a=n.indexOf(o)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const a=n.subarray(r,o);(!t||a.length!==0)&&s.push(a),r=o+1}}function sI(n,e,t){const s=n.length,r=[];let o=0,a=0;const i=new Array(s);for(let d=0;d<s;++d){const p=r.length;wW(n[d],e,t,r);const f=r.length-p;i[d]=f,o+=f,a=Math.max(a,f)}const l=tt("int32",o*2),u=new Array(o),c=[s,a];let h=0;for(let d=0;d<s;++d)for(let p=0;p<i[d];++p)l[h*2]=d,l[h*2+1]=p,u[h]=r[h],++h;return[l,u,c]}function rI(n,e){const t=tt("int32",n.length);for(let s=0;s<n.length;++s)t[s]=mw(n[s]).modulo(e).getLowBitsUnsigned();return t}const oI=at(((n,e)=>n-e)),vW=Sx(((n,e,t,s)=>({real:n-t,imag:e-s}))),Tx=yt(Ra,oI,vW),$W={kernelName:Ra,backendName:"cpu",kernelFunc:Tx};function aI(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=we(t,n.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),a=new Array(n.rank);for(let l=0;l<a.length;l++)a[l]=o[l]%n.shape[l];const i=n.locToIndex(a);s.values[r]=n.values[i]}return s}const pi=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function iI(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const i=s-t+1,l=e-t+1,u=Math.log(i),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(i-c)/i)*Math.sign(l-i/2),d=Math.max(t,Math.floor(e-l*c/i+h)),p=Math.min(s,Math.floor(e+(i-l)*c/i+h));iI(n,e,d,p)}const r=n[e];let o=t,a=s;for(Ss(n,t,e),pi(n[s],r)>0&&Ss(n,t,s);o<a;){for(Ss(n,o,a),o++,a--;pi(n[o],r)<0;)o=o+1;for(;pi(n[a],r)>0;)a=a-1}pi(n[t],r)===0?Ss(n,t,a):(a=a+1,Ss(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function lI(n,e,t,s,r){const o=e[e.length-1],[a,i]=[n.length/o,o],l=vt(t,a*s),u=vt("int32",a*s);for(let h=0;h<a;h++){const d=h*i,p=n.subarray(d,d+i);let f=new Array(p.length);p.forEach((x,w)=>f[w]={value:x,index:w}),s<f.length&&(iI(f,s),f=f.slice(0,s)),r&&f.sort(pi);const m=h*s,g=l.subarray(m,m+s),y=u.subarray(m,m+s);for(let x=0;x<s;x++)g[x]=f[x].value,y[x]=f[x].index}const c=e.slice();return c[c.length-1]=s,[we(c,t,l),we(c,"int32",u)]}function uI(n,e,t,s){const r=Ie(e,t)[0],o=[1,t[0],1];for(let f=0;f<r;f++)o[0]*=t[f];o[1]=t[r];for(let f=r+1;f<t.length;f++)o[2]*=t[f];const a=new Map,i=new Int32Array(t[r]),l=new ct(o,s,n),u=[],c=o[0]===1&&o[2]===1;for(let f=0;f<t[r];f++){let m;if(c)m=n[f].toString();else{const y=[];for(let x=0;x<o[0];x++)for(let w=0;w<o[2];w++)y.push(l.get(x,f,w));m=y.join(",")}const g=a.get(m);if(g!=null)i[f]=g;else{const y=a.size;a.set(m,y),i[f]=y,u.push(f)}}const h=o.slice();h[1]=a.size;const d=new ct(h,s);u.forEach((f,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)d.set(l.get(g,f,y),g,m,y)});const p=t.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:i}}const cI=Object.freeze(Object.defineProperty({__proto__:null,addImpl:xS,bincountImpl:Ix,bincountReduceImpl:bS,bitwiseAndImpl:wS,castImpl:yS,ceilImpl:vS,concatImpl:$S,equalImpl:SS,expImpl:NS,expm1Impl:kS,floorDivImpl:ES,floorImpl:TS,gatherNdImpl:AS,gatherV2Impl:RS,greaterEqualImpl:OS,greaterImpl:DS,lessEqualImpl:FS,lessImpl:_S,linSpaceImpl:LS,logImpl:PS,maxImpl:zS,maximumImpl:MS,minimumImpl:BS,multiplyImpl:Nx,negImpl:VS,notEqualImpl:WS,prodImpl:US,raggedGatherImpl:GS,raggedRangeImpl:HS,raggedTensorToTensorImpl:jS,rangeImpl:qS,rsqrtImpl:KS,scatterImpl:_r,sigmoidImpl:uW,simpleAbsImpl:gS,sliceImpl:YS,sparseFillEmptyRowsImpl:ZS,sparseReshapeImpl:JS,sparseSegmentReductionImpl:kx,sqrtImpl:dW,squaredDifferenceImpl:QS,staticRegexReplaceImpl:eI,stridedSliceImpl:tI,stringNGramsImpl:nI,stringSplitImpl:sI,stringToHashBucketFastImpl:rI,subImpl:oI,tileImpl:aI,topKImpl:lI,transposeImpl:Cx,uniqueImpl:uI},Symbol.toStringTag,{value:"Module"}));const hI="4.22.0";Xf("cpu",()=>new vu,1);const dI=Fe(ea,n=>n>=0?n:Math.exp(n)-1),SW={kernelName:ea,backendName:"cpu",kernelFunc:dI};function pI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s;le([r],"leakyRelu");const a=G(r.shape),i=t.data.get(r.dataId).values,l=vt("float32",a);for(let u=0;u<i.length;u++)l[u]=i[u]<0?o*i[u]:i[u];return t.makeTensorInfo(r.shape,"float32",l)}const IW={kernelName:ll,backendName:"cpu",kernelFunc:pI};const NW=at((n,e)=>n<0?e*n:n);function fI(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;le([s,r],"prelu");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,[i,l]=NW(s.shape,r.shape,o,a,"float32");return t.makeTensorInfo(l,"float32",i)}const CW={kernelName:kl,backendName:"cpu",kernelFunc:fI};const mI=Fe(ba,n=>Math.max(0,n)),kW={kernelName:ba,backendName:"cpu",kernelFunc:mI};const gI=Fe(wa,n=>Math.min(Math.max(0,n),6)),TW={kernelName:wa,backendName:"cpu",kernelFunc:gI};function Gc(n,e,t,s,r){if(t==="linear")return ms({inputs:{x:e},backend:n});if(t==="relu")return mI({inputs:{x:e},backend:n});if(t==="elu")return dI({inputs:{x:e},backend:n});if(t==="relu6")return gI({inputs:{x:e},backend:n});if(t==="prelu")return fI({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return pI({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return XS({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function Ge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,a=G(r.shape),i=Bf(o,a),l=G(i);I(a===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const u=t.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=i,h.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const EW={kernelName:El,backendName:"cpu",kernelFunc:Ge};function yI(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:a,transposeB:i}=s;le([r,o],"matMul");const l=r.shape.length,u=o.shape.length,c=a?r.shape[l-2]:r.shape[l-1],h=i?o.shape[u-1]:o.shape[u-2],d=a?r.shape[l-1]:r.shape[l-2],p=i?o.shape[u-2]:o.shape[u-1],f=r.shape.slice(0,-2),m=o.shape.slice(0,-2),g=G(f),y=G(m),w=xe(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([d,p]);I(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${a} and transposeB=${i} must match.`);const b=a?[g,c,d]:[g,d,c],$=i?[y,p,h]:[y,h,p],N=Ge({inputs:{x:r},backend:t,attrs:{shape:b}}),T=Ge({inputs:{x:o},backend:t,attrs:{shape:$}}),A=a?N.shape[1]:N.shape[2],k=a?N.shape[2]:N.shape[1],E=i?T.shape[1]:T.shape[2],S=Math.max(g,y),D=t.data.get(N.dataId).values,F=t.data.get(T.dataId).values,z=de(N.shape),M=de(T.shape),[W,j,U]=a?[z[0],1,z[1]]:[z[0],z[1],1],[q,K,X]=i?[1,M[1],M[0]]:[M[1],1,M[0]],J=k*E,Q=we([S,k,E],N.dtype),ne=Q.values,te=t.blockSize;for(let ae=0;ae<S;ae++){const pe=ae%g,me=ae%y;for(let fe=0;fe<k;fe+=te){const ve=Math.min(fe+te,k);for(let $e=0;$e<E;$e+=te){const Oe=Math.min($e+te,E);for(let Be=0;Be<A;Be+=te){const et=Math.min(Be+te,A);for(let Ve=fe;Ve<ve;Ve++)for(let Le=$e;Le<Oe;Le++){let Ke=0;for(let He=Be;He<et;He++){const xs=D[pe*W+Ve*j+He*U],Ct=F[He*q+Le*K+me*X];Ke+=xs*Ct}ne[ae*J+(Ve*E+Le)]+=Ke}}}}}return t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(T),t.makeTensorInfo(w,Q.dtype,Q.values)}const AW={kernelName:ji,backendName:"cpu",kernelFunc:yI};function RW(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const m=[];d=yI({inputs:{a:r,b:o},attrs:{transposeA:l,transposeB:u},backend:t}),a&&(p=zo({inputs:{a:d,b:a},backend:t}),m.push(d),d=p),c&&(f=Gc(t,d,c,i,h),m.push(d),d=f);for(const y of m)t.disposeIntermediateTensorInfo(y);return d}const DW={kernelName:vi,backendName:"cpu",kernelFunc:RW};const OW=Fe(Vo,n=>Math.acos(n)),_W={kernelName:Vo,backendName:"cpu",kernelFunc:OW};const FW=Fe(Wo,n=>Math.acosh(n)),LW={kernelName:Wo,backendName:"cpu",kernelFunc:FW};function PW(n){const{inputs:e,backend:t}=n,s=e;le(e,"addN");const r=s.map(i=>t.data.get(i.dataId).values),o=we(s[0].shape,s[0].dtype),a=o.values;for(let i=0;i<s.length;i++){const l=r[i];for(let u=0;u<a.length;u++)a[u]+=l[u]}return t.makeTensorInfo(o.shape,o.dtype,o.values)}const zW={kernelName:Vi,backendName:"cpu",kernelFunc:PW};function MW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;le(r,"all");const i=Ie(o,r.shape);let l=i;const u=Qe(l,r.shape.length);let c=r;u!=null&&(c=sn({inputs:{x:r},backend:t,attrs:{perm:u}}),l=rt(l.length,r.shape.length)),Ft("all",l,c.shape.length);const[h,d]=Nt(c.shape,l),p=G(d),f=Dt(G(h),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const x=y*p;let w=m[x];for(let b=0;b<p;++b){const $=m[x+b];w=w&&$}f[y]=w}u!=null&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(h,c.dtype,f);if(a){const y=st(h,i),x=Ge({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}const BW={kernelName:Qc,backendName:"cpu",kernelFunc:MW};function VW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;le(r,"any");const i=Ie(o,r.shape);let l=i;const u=Qe(l,r.shape.length);let c=r;u!=null&&(c=sn({inputs:{x:r},backend:t,attrs:{perm:u}}),l=rt(l.length,r.shape.length)),Ft("any",l,c.shape.length);const[h,d]=Nt(c.shape,l),p=G(d),f=Dt(G(h),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const x=y*p;let w=m[x];for(let b=0;b<p;++b){const $=m[x+b];w=w||$}f[y]=w}u!=null&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(h,c.dtype,f);if(a){const y=st(h,i),x=Ge({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}const WW={kernelName:eh,backendName:"cpu",kernelFunc:VW};function UW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;le(r,"argMax");let a=Ie(o,r.shape);const i=Qe(a,r.shape.length);let l=r;const u=[];i!=null&&(l=sn({inputs:{x:r},backend:t,attrs:{perm:i}}),u.push(l),a=rt(a.length,l.shape.length)),a=[a[0]],Ft("argMax",a,l.shape.length);const[c,h]=Nt(l.shape,a),d=G(c),p=Dt(d,"int32"),f=G(h),m=t.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let x=m[y],w=0;for(let b=0;b<f;++b){const $=m[y+b];$>x&&(x=$,w=b)}p[g]=w}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",p)}const GW={kernelName:Wi,backendName:"cpu",kernelFunc:UW};function HW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;le(r,"argMin");let a=Ie(o,r.shape);const i=Qe(a,r.shape.length);let l=r;const u=[];i!=null&&(l=sn({inputs:{x:r},backend:t,attrs:{perm:i}}),u.push(l),a=rt(a.length,l.shape.length)),a=[a[0]],Ft("argMin",a,l.shape.length);const[c,h]=Nt(l.shape,a),d=G(c),p=Dt(d,"int32"),f=G(h),m=t.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let x=m[y],w=0;for(let b=0;b<f;++b){const $=m[y+b];$<x&&(x=$,w=b)}p[g]=w}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",p)}const jW={kernelName:Ui,backendName:"cpu",kernelFunc:HW};const qW=Fe(Uo,n=>Math.asin(n)),KW={kernelName:Uo,backendName:"cpu",kernelFunc:qW};const XW=Fe(Go,n=>Math.asinh(n)),YW={kernelName:Go,backendName:"cpu",kernelFunc:XW};const ZW=Fe(Ho,n=>Math.atan(n)),JW={kernelName:Ho,backendName:"cpu",kernelFunc:ZW};const QW=at((n,e)=>Math.atan2(n,e)),e4=yt(qo,QW),t4={kernelName:qo,backendName:"cpu",kernelFunc:e4};const n4=Fe(jo,n=>Math.atanh(n)),s4={kernelName:jo,backendName:"cpu",kernelFunc:n4};function Ex(n,e,t,s,r,o){const a=r.strideHeight,i=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=we(r.outShape,t),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],x=r.outShape[2]*r.outShape[3],w=r.outShape[3];for(let b=0;b<r.batchSize;++b){const $=b*y,N=b*s[0];for(let T=0;T<r.inChannels;++T)for(let A=0;A<r.outHeight;++A){const k=A*a-d,E=Math.max(0,k),S=Math.min(r.inHeight,c+k),D=$+A*x;for(let F=0;F<r.outWidth;++F){const z=F*i-p,M=Math.max(0,z),W=Math.min(r.inWidth,h+z);let j=f,U=0,q=0;for(let X=E;X<S;X+=l){const J=N+X*s[1];for(let Q=M;Q<W;Q+=u){const ne=J+Q*s[2],te=n[ne+T];o==="max"&&te>j?j=te:o==="avg"&&(U+=te,q++)}if(isNaN(j))break}const K=D+F*w+T;g[K]=o==="avg"?U/q:j}}}return m}function xI(n,e,t,s,r=!1,o=!1){const a=we(s.outShape,"int32"),i=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=we(e,t,n);for(let g=0;g<s.batchSize;++g)for(let y=0;y<s.inChannels;++y)for(let x=0;x<s.outHeight;++x){const w=x*i-p;let b=w;for(;b<0;)b+=u;const $=Math.min(s.inHeight,h+w);for(let N=0;N<s.outWidth;++N){const T=N*l-f;let A=T;for(;A<0;)A+=c;const k=Math.min(s.inWidth,d+T);let E=Number.NEGATIVE_INFINITY,S=-1;for(let D=b;D<$;D+=u){const F=D-w;for(let z=A;z<k;z+=c){const M=z-T,W=m.get(g,D,z,y);W>E&&(E=W,r?S=o?((g*s.inHeight+D)*s.inWidth+z)*s.inChannels+y:(D*s.inWidth+z)*s.inChannels+y:S=F*d+M)}}a.set(S,g,x,N,y)}}return a}function bI(n,e,t,s,r,o){const a=r.strideDepth,i=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,x=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=we(r.outShape,t),b=w.values,$=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[2]*r.outShape[3]*r.outShape[4],T=r.outShape[3]*r.outShape[4],A=r.outShape[4];for(let k=0;k<r.batchSize;++k){const E=k*$,S=k*s[0];for(let D=0;D<r.inChannels;++D)for(let F=0;F<r.outDepth;++F){const z=F*a-m;let M=z;for(;M<0;)M+=u;const W=Math.min(r.inDepth,d+z),j=E+F*N;for(let U=0;U<r.outHeight;++U){const q=U*i-g;let K=q;for(;K<0;)K+=c;const X=Math.min(r.inHeight,p+q),J=j+U*T;for(let Q=0;Q<r.outWidth;++Q){const ne=Q*l-y;let te=ne;for(;te<0;)te+=h;const ae=Math.min(r.inWidth,f+ne),pe=J+Q*A;let me=x,fe=0,ve=0;for(let Oe=M;Oe<W;Oe+=u){const Be=S+Oe*s[1];for(let et=K;et<X;et+=c){const Ve=Be+et*s[2];for(let Le=te;Le<ae;Le+=h){const Ke=Ve+Le*s[3],He=n[Ke+D];if(o==="max"&&He>me?me=He:o==="avg"&&(fe+=He,ve++),isNaN(me))break}if(isNaN(me))break}if(isNaN(me))break}const $e=pe+D;b[$e]=o==="avg"?fe/Math.max(ve,1):me}}}}return w}function r4(n,e){const t=we(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,o=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const x=y*s-d;let w=x;for(;w<0;)w+=a;const b=Math.min(e.inDepth,u+x);for(let $=0;$<e.outHeight;++$){const N=$*r-p;let T=N;for(;T<0;)T+=i;const A=Math.min(e.inHeight,c+N);for(let k=0;k<e.outWidth;++k){const E=k*o-f;let S=E;for(;S<0;)S+=l;const D=Math.min(e.inWidth,h+E);let F=Number.NEGATIVE_INFINITY,z=-1;for(let M=w;M<b;M+=a){const W=M-x;for(let j=T;j<A;j+=i){const U=j-N;for(let q=S;q<D;q+=l){const K=q-E,X=n.get(m,M,j,q,g);X>=F&&(F=X,z=W*c*h+U*c+K)}}}t.set(z,m,y,$,k,g)}}}return t}function o4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;le(r,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;I(_t(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=_n(r.shape,o,a,u,i,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Ce(c.inShape,c.outShape))h=ms({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=de(r.shape),f=Ex(d,r.shape,r.dtype,p,c,"avg");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const a4={kernelName:Gi,backendName:"cpu",kernelFunc:o4};function i4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=s;le(r,"avgPool3d");const c=Fs(r.shape,o,a,1,i,l,u),h=t.data.get(r.dataId).values,d=bI(h,r.shape,r.dtype,de(r.shape),c,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const l4={kernelName:Hi,backendName:"cpu",kernelFunc:i4};function u4(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=s;le([r,o],"avgPool3DGrad");const c=Fs(o.shape,a,i,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,x=c.dilationHeight,w=c.dilationWidth,b=c.effectiveFilterDepth,$=c.effectiveFilterHeight,N=c.effectiveFilterWidth,T=b-1-c.padInfo.front,A=N-1-c.padInfo.left,k=$-1-c.padInfo.top,E=we(o.shape,"float32"),S=1/(f*m*g),D=t.bufferSync(r);for(let F=0;F<c.batchSize;++F)for(let z=0;z<c.inChannels;++z)for(let M=0;M<c.inDepth;++M)for(let W=0;W<c.inHeight;++W)for(let j=0;j<c.inWidth;++j){const U=M-T,q=W-k,K=j-A;let X=0;for(let J=0;J<b;J+=y){const Q=(U+J)/h;if(!(Q<0||Q>=c.outDepth||Math.floor(Q)!==Q))for(let ne=0;ne<$;ne+=x){const te=(q+ne)/d;if(!(te<0||te>=c.outHeight||Math.floor(te)!==te))for(let ae=0;ae<N;ae+=w){const pe=(K+ae)/p;if(pe<0||pe>=c.outWidth||Math.floor(pe)!==pe)continue;const me=D.get(F,Q,te,pe,z);X+=me}}}E.set(X*S,F,M,W,j,z)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const c4={kernelName:nh,backendName:"cpu",kernelFunc:u4};function h4(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o;le([r,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=s,c=_n(a.shape,i,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=x-1-c.padInfo.left,b=y-1-c.padInfo.top,$=we(a.shape,"float32"),N=1/(p*f),T=t.data.get(r.dataId).values,A=we(r.shape,"float32",T);for(let k=0;k<c.batchSize;++k)for(let E=0;E<c.inChannels;++E)for(let S=0;S<c.inHeight;++S)for(let D=0;D<c.inWidth;++D){const F=S-b,z=D-w;let M=0;for(let W=0;W<y;W+=m){const j=(F+W)/h;if(!(j<0||j>=c.outHeight||Math.floor(j)!==j))for(let U=0;U<x;U+=g){const q=(z+U)/d;if(q<0||q>=c.outWidth||Math.floor(q)!==q)continue;const K=A.get(k,j,q,E);M+=K}}$.set(M*N,k,S,D,E)}return t.makeTensorInfo($.shape,$.dtype,$.values)}const d4={kernelName:th,backendName:"cpu",kernelFunc:h4};function p4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:o,offset:a,mean:i,variance:l}=e;I(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),le([r,i,l,o,a],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=t.data.get(l.dataId).values,p=o?t.data.get(o.dataId).values:new Float32Array([1]),f=a?t.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,x=d.length,w=h.length;let b=0,$=0,N=0,T=0;for(let A=0;A<c.length;++A)m[A]=f[b++]+(c[A]-h[$++])*p[N++]/Math.sqrt(d[T++]+u),b>=g&&(b=0),$>=w&&($=0),N>=y&&(N=0),T>=x&&(T=0);return t.makeTensorInfo(r.shape,r.dtype,m)}const f4={kernelName:ol,backendName:"cpu",kernelFunc:p4};function m4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:a}=s;le([r],"batchToSpaceND");const i=o.reduce((y,x)=>y*x),l=uu(r.shape,o,i),u=cu(l.length,o.length),c=hu(r.shape,o,i),h=Cg(a,o.length),d=kg(c,a,o.length),p=Ge({inputs:{x:r},backend:t,attrs:{shape:l}}),f=sn({inputs:{x:p},backend:t,attrs:{perm:u}}),m=Ge({inputs:{x:f},backend:t,attrs:{shape:c}}),g=eo({inputs:{x:m},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}const g4={kernelName:qi,backendName:"cpu",kernelFunc:m4};function y4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a}=s,i=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,u=Ix(i,l,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,u)}const x4={kernelName:sh,backendName:"cpu",kernelFunc:y4};function b4(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,i=xe(Array.from(o),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const w4={kernelName:rh,backendName:"cpu",kernelFunc:b4};const v4=Fe(Yo,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),$4={kernelName:Yo,backendName:"cpu",kernelFunc:v4};const S4=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(G(e.shape)),r=t.data.get(e.dataId),o=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,i=t.data.get(o.dataId).values,l=t.data.get(a.dataId).values;for(let u=0;u<i.length;u++){const c=i[u],h=l[u];s[u]=Math.hypot(c,h)}return t.makeOutput(s,e.shape,"float32")},I4={kernelName:Xi,backendName:"cpu",kernelFunc:S4};function Mo(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}const N4={kernelName:Ih,backendName:"cpu",kernelFunc:Mo};function Bo(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Ie(r,e[0].shape)[0],a=e.map(m=>m.shape);Sg(a,o);let i=ls(e.map(m=>m.shape),o);if(G(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);const l=e.filter(m=>G(m.shape)>0);if(l.length===1)return ms({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const m=l.map(b=>Qr({inputs:{input:b},backend:t})),g=l.map(b=>Mo({inputs:{input:b},backend:t})),y=Bo({inputs:m,backend:t,attrs:{axis:o}}),x=Bo({inputs:g,backend:t,attrs:{axis:o}}),w=un({inputs:{real:y,imag:x},backend:t});return m.forEach(b=>t.disposeIntermediateTensorInfo(b)),g.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),w}const u=l.map(m=>{const y=[-1,G(m.shape.slice(o))];return Ge({inputs:{x:m},backend:t,attrs:{shape:y}})}),c=u.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));i=ls(u.map(m=>m.shape),1);const h=u[0].shape[0]===1,d=$S(c,i,e[0].dtype,h),p=ls(l.map(m=>m.shape),o),f=t.makeTensorInfo(p,e[0].dtype,d);return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const C4={kernelName:Yi,backendName:"cpu",kernelFunc:Bo};function wI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=s;le([r,o],"conv2d");const h=Ls(l),d=It(r.shape,o.shape,a,u,i,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,x=d.padInfo.top,w=d.dataFormat==="channelsLast",b=new ct(d.outShape,r.dtype),$=de(r.shape),N=de(o.shape),T=$[0],A=w?$[1]:$[2],k=w?$[2]:1,E=w?1:$[1],S=b.strides[0],D=w?b.strides[1]:b.strides[2],F=w?b.strides[2]:1,z=w?1:b.strides[1],M=t.data.get(r.dataId).values,W=t.data.get(o.dataId).values,j=b.values;for(let U=0;U<d.batchSize;++U){const q=U*T,K=U*S;for(let X=0;X<d.outHeight;++X){const J=K+X*D,Q=X*d.strideHeight-x;for(let ne=0;ne<p;++ne){const te=Q+ne*m;if(te<0||te>=d.inHeight)continue;const ae=ne*N[0],pe=q+te*A;for(let me=0;me<d.outWidth;++me){const fe=J+me*F,ve=me*d.strideWidth-y;for(let $e=0;$e<f;++$e){const Oe=ve+$e*g;if(Oe<0||Oe>=d.inWidth)continue;const Be=ae+$e*N[1],et=pe+Oe*k;let Ve=Be;for(let Le=0;Le<d.inChannels;++Le){const Ke=M[et+Le*E];for(let He=0;He<d.outChannels;++He)j[fe+He*z]+=Ke*W[Ve+He];Ve+=d.outChannels}}}}}}return t.makeTensorInfo(b.shape,b.dtype,j)}const k4={kernelName:Zi,backendName:"cpu",kernelFunc:wI};function T4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;le([r,o],"conv2dBackpropFilter");const h=Ls(l),d=It(r.shape,c,a,1,i,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y=d.dataFormat==="channelsLast",x=new ct(d.filterShape,"float32"),w=d.padInfo.left,b=d.padInfo.top,$=t.data.get(r.dataId).values,N=t.data.get(o.dataId).values,T=new ct(r.shape,r.dtype,$),A=new ct(o.shape,o.dtype,N);for(let k=0;k<m;++k){const E=Math.max(0,Math.ceil((b-k)/p)),S=Math.min(d.outHeight,(d.inHeight+b-k)/p);for(let D=0;D<g;++D){const F=Math.max(0,Math.ceil((w-D)/f)),z=Math.min(d.outWidth,(d.inWidth+w-D)/f);for(let M=0;M<d.inChannels;++M)for(let W=0;W<d.outChannels;++W){let j=0;for(let U=0;U<d.batchSize;++U)for(let q=E;q<S;++q){const K=k+q*p-b;for(let X=F;X<z;++X){const J=D+X*f-w;y?j+=T.get(U,K,J,M)*A.get(U,q,X,W):j+=T.get(U,M,K,J)*A.get(U,W,q,X)}}x.set(j,k,D,M,W)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const E4={kernelName:ah,backendName:"cpu",kernelFunc:T4};function A4(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=s;le([r,o],"conv2dBackpropInput");const h=de(o.shape),d=de(r.shape);let p=Ls(u);const f=It(a,o.shape,i,1,l,c,!1,p),m=new ct(f.inShape,"float32"),g=m.values,y=t.data.get(r.dataId).values,x=t.data.get(o.dataId).values,[w,b,$]=h,{batchSize:N,filterHeight:T,filterWidth:A,inChannels:k,inHeight:E,inWidth:S,outChannels:D,outHeight:F,outWidth:z,strideHeight:M,strideWidth:W}=f;p=f.dataFormat;const j=T-1-f.padInfo.top,U=A-1-f.padInfo.left,q=p==="channelsLast",K=m.strides[0],X=q?m.strides[1]:m.strides[2],J=q?m.strides[2]:1,Q=q?1:m.strides[1],ne=d[0],te=q?d[1]:d[2],ae=q?d[2]:1,pe=q?1:d[1];for(let me=0;me<N;++me)for(let fe=0;fe<k;++fe)for(let ve=0;ve<E;++ve){const $e=ve-j,Oe=Math.max(0,Math.ceil($e/M)),Be=Math.min(F,(T+$e)/M);for(let et=0;et<S;++et){const Ve=et-U,Le=Math.max(0,Math.ceil(Ve/W)),Ke=Math.min(z,(A+Ve)/W);let He=0;for(let Ct=Oe;Ct<Be;++Ct){const Ws=Ct*M-$e;for(let gn=Le;gn<Ke;++gn){const Sr=gn*W-Ve,Pn=ne*me+te*Ct+ae*gn,bs=w*(T-1-Ws)+b*(A-1-Sr)+$*fe;for(let Us=0;Us<D;++Us){const Gs=y[Pn+pe*Us],Hs=x[bs+Us];He+=Gs*Hs}}}const xs=K*me+X*ve+J*et+Q*fe;g[xs]=He}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const R4={kernelName:Ji,backendName:"cpu",kernelFunc:A4};function D4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l}=s;le([r,o],"conv3d");const u=mr(r.shape,o.shape,a,l,i),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,x=g.left,w=g.top,b=new ct(u.outShape,r.dtype),$=t.data.get(r.dataId).values,N=t.data.get(o.dataId).values,T=b.values,A=de(r.shape),k=de(o.shape);for(let E=0;E<u.batchSize;++E){const S=E*A[0],D=E*b.strides[0];for(let F=0;F<u.outDepth;++F){const z=D+F*b.strides[1],M=F*u.strideDepth-y;for(let W=0;W<c;++W){const j=M+W*p;if(j<0||j>=u.inDepth)continue;const U=W*k[0],q=S+j*A[1];for(let K=0;K<u.outHeight;++K){const X=z+K*b.strides[2],J=K*u.strideHeight-w;for(let Q=0;Q<h;++Q){const ne=J+Q*f;if(ne<0||ne>=u.inHeight)continue;const te=U+Q*k[1],ae=q+ne*A[2];for(let pe=0;pe<u.outWidth;++pe){const me=X+pe*u.outChannels,fe=pe*u.strideWidth-x;for(let ve=0;ve<d;++ve){const $e=fe+ve*m;if($e<0||$e>=u.inWidth)continue;const Oe=te+ve*k[2],Be=ae+$e*u.inChannels;let et=Oe;for(let Ve=0;Ve<u.inChannels;++Ve){const Le=$[Be+Ve];for(let Ke=0;Ke<u.outChannels;++Ke)T[me+Ke]+=Le*N[et+Ke];et+=u.outChannels}}}}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const O4={kernelName:Qi,backendName:"cpu",kernelFunc:D4};function _4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:i,filterShape:l}=s;le([r,o],"conv3dBackpropFilterV2");const u=de(r.shape),c=de(o.shape),h=mr(r.shape,l,a,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,x=new ct(h.filterShape,"float32"),w=x.values,[b,$,N,T]=x.strides,A=t.data.get(o.dataId).values,[k,E,S,D]=c,F=t.data.get(r.dataId).values,[z,M,W,j]=u,U=h.padInfo.front,q=h.padInfo.left,K=h.padInfo.top;for(let X=0;X<m;++X){const J=Math.max(0,Math.ceil((U-X)/d)),Q=Math.min(h.outDepth,(h.inDepth+U-X)/d),ne=X*b;for(let te=0;te<g;++te){const ae=Math.max(0,Math.ceil((K-te)/p)),pe=Math.min(h.outHeight,(h.inHeight+K-te)/p),me=te*$+ne;for(let fe=0;fe<y;++fe){const ve=Math.max(0,Math.ceil((q-fe)/f)),$e=Math.min(h.outWidth,(h.inWidth+q-fe)/f),Oe=fe*N+me;for(let Be=0;Be<h.inChannels;++Be){const et=Be*T+Oe;for(let Ve=0;Ve<h.outChannels;++Ve){let Le=0;for(let Ke=0;Ke<h.batchSize;++Ke){const He=Ke*z,xs=Ke*k;for(let Ct=J;Ct<Q;++Ct){const gn=(X+Ct*d-U)*M+He,Sr=Ct*E+xs;for(let Pn=ae;Pn<pe;++Pn){const Us=(te+Pn*p-K)*W+gn,Gs=Pn*S+Sr;for(let Hs=ve;Hs<$e;++Hs){const wp=(fe+Hs*f-q)*j+Us,vp=Hs*D+Gs;Le+=F[wp+Be]*A[vp+Ve]}}}}w[et+Ve]=Le}}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const F4={kernelName:ih,backendName:"cpu",kernelFunc:_4};function L4(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:a,strides:i,inputShape:l}=s;le([r],"conv3dBackpropInputV2");const u=de(r.shape),c=de(o.shape),h=mr(l,o.shape,i,1,a),d=new ct(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,x=t.data.get(r.dataId).values,[w,b,$,N]=u,T=t.data.get(o.dataId).values,[A,k,E,S]=c,{batchSize:D,filterDepth:F,filterHeight:z,filterWidth:M,inChannels:W,inDepth:j,inHeight:U,inWidth:q,outChannels:K,outDepth:X,outHeight:J,outWidth:Q,strideDepth:ne,strideHeight:te,strideWidth:ae}=h,pe=F-1-h.padInfo.front,me=z-1-h.padInfo.top,fe=M-1-h.padInfo.left;for(let ve=0;ve<D;++ve)for(let $e=0;$e<W;++$e)for(let Oe=0;Oe<j;++Oe){const Be=Oe-pe,et=Math.max(0,Math.ceil(Be/ne)),Ve=Math.min(X,(F+Be)/ne);for(let Le=0;Le<U;++Le){const Ke=Le-me,He=Math.max(0,Math.ceil(Ke/te)),xs=Math.min(J,(z+Ke)/te);for(let Ct=0;Ct<q;++Ct){const Ws=Ct-fe,gn=Math.max(0,Math.ceil(Ws/ae)),Sr=Math.min(Q,(M+Ws)/ae);let Pn=0;for(let bs=et;bs<Ve;++bs){const Us=bs*ne-Be;for(let Gs=He;Gs<xs;++Gs){const Hs=Gs*te-Ke;for(let ri=gn;ri<Sr;++ri){const wp=ri*ae-Ws,vp=w*ve+b*bs+$*Gs+N*ri,nC=A*(F-1-Us)+k*(z-1-Hs)+E*(M-1-wp)+S*$e;for(let Tu=0;Tu<K;++Tu){const sC=x[vp+Tu],rC=T[nC+Tu];Pn+=sC*rC}}}}p[f*ve+m*Oe+g*Le+y*Ct+$e]=Pn}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const P4={kernelName:lh,backendName:"cpu",kernelFunc:L4};const z4=Fe(Zo,n=>Math.cos(n)),M4={kernelName:Zo,backendName:"cpu",kernelFunc:z4};const B4=Fe(Jo,n=>Math.cosh(n)),V4={kernelName:Jo,backendName:"cpu",kernelFunc:B4};function W4(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:u}=s,[c,h,d,p]=r.shape,f=o.shape[0],[m,g]=i,y=we([f,m,g,p],"float32"),x=t.data.get(o.dataId).values,w=t.data.get(a.dataId).values,b=t.data.get(r.dataId).values,$=de(r.shape),N=de(y.shape);for(let T=0;T<f;T++){const A=T*4,k=x[A],E=x[A+1],S=x[A+2],D=x[A+3],F=w[T];if(F>=c)continue;const z=m>1?(S-k)*(h-1)/(m-1):0,M=g>1?(D-E)*(d-1)/(g-1):0;for(let W=0;W<m;W++){const j=m>1?k*(h-1)+W*z:.5*(k+S)*(h-1);if(j<0||j>h-1){for(let U=0;U<g;U++)for(let q=0;q<p;q++){const K=q+U*N[2]+W*N[1]+T*N[0];y.values[K]=u}continue}if(l==="bilinear"){const U=Math.floor(j),q=Math.ceil(j),K=j-U;for(let X=0;X<g;X++){const J=g>1?E*(d-1)+X*M:.5*(E+D)*(d-1);if(J<0||J>d-1){for(let ae=0;ae<p;ae++){const pe=ae+X*N[2]+W*N[1]+T*N[0];y.values[pe]=u}continue}const Q=Math.floor(J),ne=Math.ceil(J),te=J-Q;for(let ae=0;ae<p;ae++){let pe=ae+Q*$[2]+U*$[1]+F*$[0];const me=b[pe];pe=ae+ne*$[2]+U*$[1]+F*$[0];const fe=b[pe];pe=ae+Q*$[2]+q*$[1]+F*$[0];const ve=b[pe];pe=ae+ne*$[2]+q*$[1]+F*$[0];const $e=b[pe],Oe=me+(fe-me)*te,Be=ve+($e-ve)*te;pe=ae+X*N[2]+W*N[1]+T*N[0],y.values[pe]=Oe+(Be-Oe)*K}}}else for(let U=0;U<g;++U){const q=g>1?E*(d-1)+U*M:.5*(E+D)*(d-1);if(q<0||q>d-1){for(let J=0;J<p;J++){const Q=J+U*N[2]+W*N[1]+T*N[0];y.values[Q]=u}continue}const K=Math.round(q),X=Math.round(j);for(let J=0;J<p;J++){const Q=J+K*$[2]+X*$[1]+F*$[0],ne=J+U*N[2]+W*N[1]+T*N[0];y.values[ne]=b[Q]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const U4={kernelName:ch,backendName:"cpu",kernelFunc:W4};function G4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;le(r,"cumprod");const l=Qe([o],r.shape.length);let u=r;l!=null&&(u=sn({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=rt(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Jt(u.dtype,"int32"),d=Jc(G(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=i?(y,x)=>y+f-x-1:(y,x)=>y+x;for(let y=0;y<p.length;y+=f)for(let x=0;x<f;x++){const w=m(y,x);if(x===0)d[w]=a?1:p[w];else{const b=m(y,x-1);d[w]=a?p[b]*d[b]:p[w]*d[b]}}const g=t.makeTensorInfo(u.shape,h,d);if(l!=null){const y=gr(l),x=sn({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),x}return g}const H4={kernelName:uh,backendName:"cpu",kernelFunc:G4};function j4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;le(r,"cumsum");const l=Qe([o],r.shape.length);let u=r;l!=null&&(u=sn({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=rt(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Jt(u.dtype,"int32"),d=Dt(G(u.shape),h),p=t.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=i?(y,x)=>y+f-x-1:(y,x)=>y+x;for(let y=0;y<p.length;y+=f)for(let x=0;x<f;x++){const w=m(y,x);if(x===0)d[w]=a?0:p[w];else{const b=m(y,x-1);d[w]=a?p[b]+d[b]:p[w]+d[b]}}const g=t.makeTensorInfo(u.shape,h,d);if(l!=null){const y=gr(l),x=sn({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),x}return g}const q4={kernelName:el,backendName:"cpu",kernelFunc:j4};function K4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a,binaryOutput:i}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=Ix(l,u,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(o),c=bS(l,u,a,i);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const X4={kernelName:hh,backendName:"cpu",kernelFunc:K4};function Y4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:a}=s;I(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const i=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*o,d=u*o,p=c/(o*o),f=t.data.get(r.dataId).values,m=new Float32Array(i*h*d*p);let g=0;for(let y=0;y<i;++y)for(let x=0;x<h;++x){const w=Math.floor(x/o),b=x%o;for(let $=0;$<d;++$){const N=Math.floor($/o),T=$%o,A=(b*o+T)*p;for(let k=0;k<p;++k){const S=k+A+c*(N+u*(w+l*y));m[g++]=f[S]}}}return t.makeTensorInfo([i,h,d,p],r.dtype,m)}const Z4={kernelName:dh,backendName:"cpu",kernelFunc:Y4};function vI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=s;le([r,o],"depthwiseConv2DNative");const c=de(r.shape),h=de(o.shape);let d=l;d==null&&(d=[1,1]),I(_t(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=It(r.shape,o.shape,a,d,i,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:x}=p,w=x.left,b=x.top,$=p.outChannels/p.inChannels,N=new ct(p.outShape,r.dtype),T=t.data.get(r.dataId).values,A=t.data.get(o.dataId).values,k=N.values;for(let E=0;E<p.batchSize;++E){const S=E*c[0],D=E*N.strides[0];for(let F=0;F<p.outHeight;++F){const z=D+F*N.strides[1],M=F*p.strideHeight-b;for(let W=0;W<f;++W){const j=M+W*g;if(j<0||j>=p.inHeight)continue;const U=W*h[0],q=S+j*c[1];for(let K=0;K<p.outWidth;++K){const X=z+K*N.strides[2],J=K*p.strideWidth-w;for(let Q=0;Q<m;++Q){const ne=J+Q*y;if(ne<0||ne>=p.inWidth)continue;const te=U+Q*h[1],ae=q+ne*p.inChannels;let pe=X,me=te;for(let fe=0;fe<p.inChannels;++fe){const ve=T[ae+fe];for(let $e=0;$e<$;++$e)k[pe+$e]+=ve*A[me+$e];pe+=$,me+=$}}}}}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const J4={kernelName:tl,backendName:"cpu",kernelFunc:vI};function Q4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=s;le([r,o],"depthwiseConv2dNativeBackpropFilter");const h=It(r.shape,c,a,i,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new ct(h.filterShape,"float32"),y=h.padInfo.left,x=h.padInfo.top,w=h.outChannels/h.inChannels,b=t.data.get(r.dataId).values,$=new ct(r.shape,r.dtype,b),N=t.data.get(o.dataId).values,T=new ct(o.shape,o.dtype,N);for(let A=0;A<f;++A){const k=Math.max(0,Math.ceil((x-A)/d)),E=Math.min(h.outHeight,(h.inHeight+x-A)/d);for(let S=0;S<m;++S){const D=Math.max(0,Math.ceil((y-S)/p)),F=Math.min(h.outWidth,(h.inWidth+y-S)/p);for(let z=0;z<h.outChannels;++z){const M=Math.trunc(z/w),W=z%w;let j=0;for(let U=0;U<h.batchSize;++U)for(let q=k;q<E;++q){const K=A+q*d-x;for(let X=D;X<F;++X){const J=S+X*p-y;j+=$.get(U,K,J,M)*T.get(U,q,X,z)}}g.set(j,A,S,M,W)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const eU={kernelName:ph,backendName:"cpu",kernelFunc:Q4};function tU(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=s;le([r,o],"depthwiseConv2DNativeBackpropInput");const h=de(r.shape),d=de(o.shape),p=It(c,o.shape,a,i,l,u,!0),f=new ct(p.inShape,"float32"),m=f.values,[g,y,x]=f.strides,w=t.data.get(r.dataId).values,[b,$,N]=h,T=t.data.get(o.dataId).values,[A,k,E]=d,{batchSize:S,filterHeight:D,filterWidth:F,inChannels:z,inHeight:M,inWidth:W,outChannels:j,outHeight:U,outWidth:q,strideHeight:K,strideWidth:X}=p,J=D-1-p.padInfo.top,Q=F-1-p.padInfo.left,ne=j/z;for(let te=0;te<S;++te)for(let ae=0;ae<z;++ae)for(let pe=0;pe<M;++pe){const me=pe-J,fe=Math.max(0,Math.ceil(me/K)),ve=Math.min(U,(D+me)/K);for(let $e=0;$e<W;++$e){const Oe=$e-Q,Be=Math.max(0,Math.ceil(Oe/X)),et=Math.min(q,(F+Oe)/X);let Ve=0;for(let Le=fe;Le<ve;++Le){const Ke=Le*K-me;for(let He=Be;He<et;++He){const xs=He*X-Oe,Ct=b*te+$*Le+N*He,Ws=A*(D-1-Ke)+k*(F-1-xs)+E*ae;for(let gn=0;gn<ne;++gn){const Sr=ae*ne+gn,Pn=w[Ct+Sr],bs=T[Ws+gn];Ve+=Pn*bs}}}m[g*te+y*pe+x*$e+ae]=Ve}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const nU={kernelName:fh,backendName:"cpu",kernelFunc:tU};function sU(n){const{inputs:e,backend:t}=n,{x:s}=e,r=G(s.shape),o=t.data.get(s.dataId).values,a=we([r,r],s.dtype),i=a.values;for(let u=0;u<o.length;u++)i[u*r+u]=o[u];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,a.dtype,a.values)}const rU={kernelName:mh,backendName:"cpu",kernelFunc:sU};const oU={kernelName:nl,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:o,pad:a,dilations:i}=t,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:x,padInfo:w,strideHeight:b,strideWidth:$,filterHeight:N,filterWidth:T,dilationHeight:A,dilationWidth:k,outShape:E}=Hl(s.shape,r.shape,o,a,"NHWC",i),S=G(E),D=E.length,F=tt(s.dtype,S);for(let M=0;M<p;++M)for(let W=0;W<y;++W){const j=W*b-w.top;for(let U=0;U<x;++U){const q=U*$-w.left;for(let K=0;K<g;++K){let X=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<N;++Q){const ne=j+Q*A;if(ne>=0&&ne<f)for(let te=0;te<T;++te){const ae=q+te*k;if(ae>=0&&ae<m){const pe=Un([M,ne,ae,K],c,de(s.shape)),me=Un([Q,te,K],d,de(r.shape)),fe=u[pe]+h[me];fe>X&&(X=fe)}}}const J=Un([M,W,U,K],D,de(E));F[J]=X}}}return{dataId:l.write(pr(F,s.dtype),E,s.dtype),shape:E,dtype:s.dtype}}};const aU={kernelName:Ic,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:a,pad:i,dilations:l}=t,u=e,c=Sn(s.shape,u.data.get(s.dataId).values),h=Sn(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:w,strideWidth:b,filterHeight:$,filterWidth:N,dilationHeight:T,dilationWidth:A,outShape:k}=Hl(s.shape,r.shape,a,i,"NHWC",l);I(o.rank===k.length,()=>`Error in ${Ic}, dy must have the same rank as output ${k.length}, but got ${o.rank}`);const E=Sn(k,u.data.get(o.dataId).values),S=Wf(r.shape,r.dtype);for(let F=0;F<d;++F)for(let z=0;z<g;++z){const M=z*w-x.top;for(let W=0;W<y;++W){const j=W*b-x.left;for(let U=0;U<m;++U){let q=Number.MIN_SAFE_INTEGER,K=0,X=0;for(let J=0;J<$;++J){const Q=M+J*T;if(Q>=0&&Q<p)for(let ne=0;ne<N;++ne){const te=j+ne*A;if(te>=0&&te<f){const ae=c[F][Q][te][U]+h[J][ne][U];ae>q&&(q=ae,K=J,X=ne)}}}S[K][X][U]+=E[F][z][W][U]}}}return{dataId:u.write(pr(S,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const iU={kernelName:Sc,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:o}=n,{strides:a,pad:i,dilations:l}=t,u=e,c=Sn(s.shape,u.data.get(s.dataId).values),h=Sn(r.shape,u.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:w,strideWidth:b,filterHeight:$,filterWidth:N,dilationHeight:T,dilationWidth:A,outShape:k}=Hl(s.shape,r.shape,a,i,"NHWC",l);I(o.rank===k.length,()=>`Error in ${Sc}, dy must have the same rank as output ${k.length}, but got ${o.rank}`);const E=Sn(k,u.data.get(o.dataId).values),S=Wf(s.shape,s.dtype);for(let F=0;F<d;++F)for(let z=0;z<g;++z){const M=z*w-x.top;for(let W=0;W<y;++W){const j=W*b-x.left;for(let U=0;U<m;++U){let q=Number.MIN_SAFE_INTEGER,K=M<0?0:M,X=j<0?0:j;for(let J=0;J<$;++J){const Q=M+J*T;if(Q>=0&&Q<p)for(let ne=0;ne<N;++ne){const te=j+ne*A;if(te>=0&&te<f){const ae=c[F][Q][te][U]+h[J][ne][U];ae>q&&(q=ae,K=Q,X=te)}}}S[F][K][X][U]+=E[F][z][W][U]}}}return{dataId:u.write(pr(S,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function lU(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:o,options:a}=s,{contextOptions:i,imageOptions:l}=a||{},u=l?.alpha||1,c=i?.contextType||"2d";if(c!=="2d")throw new Error(`Context type ${i.contextType} is not supported by the CPU backend.`);const h=o.getContext(c,i?.contextAttributes||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=r.shape.slice(0,2),f=r.shape.length===2?1:r.shape[2],m=t.data.get(r.dataId).values,g=r.dtype==="float32"?255:1,y=new Uint8ClampedArray(p*d*4);for(let w=0;w<d*p;++w){const b=[0,0,0,255*u];for(let N=0;N<f;N++){const T=m[w*f+N];if(r.dtype==="float32"){if(T<0||T>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${T}.`)}else if(r.dtype==="int32"&&(T<0||T>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${T}.`);f===1?(b[0]=T*g,b[1]=T*g,b[2]=T*g):b[N]=T*g}const $=w*4;y[$+0]=Math.round(b[0]),y[$+1]=Math.round(b[1]),y[$+2]=Math.round(b[2]),y[$+3]=Math.round(b[3])}o.width=p,o.height=d;const x=new ImageData(y,p,d);return h.putImageData(x,0,0),r}const uU={kernelName:gh,backendName:"cpu",kernelFunc:lU};function $u(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;le(r,"sum");let i;r.dtype==="bool"?i=dr({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):i=ms({inputs:{x:r},backend:t});const l=i.shape.length,u=Ie(o,i.shape),c=Qe(u,l);let h=u,d=i;c!=null&&(d=sn({inputs:{x:i},backend:t,attrs:{perm:c}}),h=rt(h.length,l)),Ft("sum",h,d.shape.length);const[p,f]=Nt(d.shape,h),m=Jt(d.dtype,"int32");let g=Wc(t,p,m);const y=G(f),x=t.data.get(g.dataId).values,w=t.data.get(d.dataId).values;for(let b=0;b<x.length;++b){const $=b*y;let N=0;for(let T=0;T<y;++T)N+=w[$+T];x[b]=N}if(a){const b=st(g.shape,u),$=g;g=Ge({inputs:{x:g},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo($)}return t.disposeIntermediateTensorInfo(i),c!=null&&t.disposeIntermediateTensorInfo(d),g}const cU={kernelName:Fl,backendName:"cpu",kernelFunc:$u};function hU(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:a,summedDims:i,idDims:l}=Fg(r,o.length);Pg(a.length,l,o);const{path:u,steps:c}=zg(i,l),h=c.length;let d=null,p=a.length;const f=[];for(let m=0;m<h;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:x}=Lg(p,l[g]);let w;Mg(y)?w=o[g]:(w=sn({inputs:{x:o[g]},backend:t,attrs:{perm:y}}),f.push(w));const b=w.shape.slice();for(let $=0;$<x.length;++$)b.splice(x[$],0,1);Ce(w.shape,b)||(w=Ge({inputs:{x:w},backend:t,attrs:{shape:b}}),f.push(w)),d===null?d=w:(d=mp({inputs:{a:w,b:d},backend:t}),f.push(d))}m<h-1&&(u[m]>=0&&(d=$u({inputs:{x:d},backend:t,attrs:{axis:u[m]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&t.disposeIntermediateTensorInfo(m);return d}const dU={kernelName:yh,backendName:"cpu",kernelFunc:hU};function pU(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;le([s,r],"eluGrad");const o=new Float32Array(G(r.shape)),a=t.data.get(r.dataId).values,i=t.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const u=a[l];u>=0?o[l]=i[l]:o[l]=i[l]*(u+1)}return t.makeTensorInfo(r.shape,"float32",o)}const fU={kernelName:xh,backendName:"cpu",kernelFunc:pU};const mU=Tg,gU=Eg,yU=Ag,xU=Rg,bU=Dg,wU=Og,vU=Fe(ta,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+mU*t);return e*(1-((((wU*s+bU)*s+xU)*s+yU)*s+gU)*s*Math.exp(-t*t))}),$U={kernelName:ta,backendName:"cpu",kernelFunc:vU};function Hc(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:o}=s,a=r.shape.length,i=r.shape.slice();let l=o;return o<0&&(I(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),i.splice(l,0,1),Ge({inputs:{x:r},backend:t,attrs:{shape:i}})}const SU={kernelName:rl,backendName:"cpu",kernelFunc:Hc};const IU=at((n,e)=>n/e),Ax=yt(Qo,IU),Ef={kernelName:Qo,backendName:"cpu",kernelFunc:Ax};function $I(n,e,t){const s=n.shape,r=s[0],o=s[1],a=t.data.get(n.dataId),i=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[r,o],c=G(u),h=vt("float32",c),d=vt("float32",c);for(let g=0;g<r;g++){const y=eo({inputs:{x:i},backend:t,attrs:{begin:[g,0],size:[1,o]}}),x=eo({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,o]}}),w=un({inputs:{real:y,imag:x},backend:t}),{real:b,imag:$}=NU(w,e,t),N=Rs(b,$);for(let T=0;T<o;T++){const A=_g(N,T);h[g*o+T]=A.real,d[g*o+T]=A.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w)}const p=t.makeTensorInfo(u,"float32",h),f=t.makeTensorInfo(u,"float32",d),m=un({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),m}function NU(n,e,t){const s=G(n.shape),r=t.data.get(n.dataId),o=t.data.get(r.complexTensorInfos.real.dataId).values,a=t.data.get(r.complexTensorInfos.imag.dataId).values;if(CU(s)){const i=Af(o,a,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const u=t.makeTensorInfo(l,"float32",i.real),c=t.makeTensorInfo(l,"float32",i.imag),h=t.makeTensorInfo([],"float32",_s(s,"float32")),d=ms({inputs:{x:h},backend:t}),p=Ef.kernelFunc({inputs:{a:u,b:h},backend:t}),f=Ef.kernelFunc({inputs:{a:c,b:d},backend:t}),m=t.data.get(p.dataId).values,g=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return i}else{const i=Rs(o,a),l=kU(i,s,e);return pv(l)}}function CU(n){return(n&n-1)===0}function Af(n,e,t,s,r){if(t===1)return{real:n,imag:e};const o=Rs(n,e),a=t/2,i=fv(o),l=i.real,u=i.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),p=un({inputs:{real:h,imag:d},backend:r}),f=mv(o),m=f.real,g=f.imag,y=[m.length],x=r.makeTensorInfo(y,"float32",m),w=r.makeTensorInfo(y,"float32",g),b=un({inputs:{real:x,imag:w},backend:r}),$=Af(l,u,a,s,r),N=$.real,T=$.imag,A=[N.length],k=r.makeTensorInfo(A,"float32",N),E=r.makeTensorInfo(A,"float32",T),S=un({inputs:{real:k,imag:E},backend:r}),D=Af(m,g,a,s,r),F=D.real,z=D.imag,M=[F.length],W=r.makeTensorInfo(M,"float32",F),j=r.makeTensorInfo(M,"float32",z),U=un({inputs:{real:W,imag:j},backend:r}),q=yv(t,s),K=[q.real.length],X=r.makeTensorInfo(K,"float32",q.real),J=r.makeTensorInfo(K,"float32",q.imag),Q=un({inputs:{real:X,imag:J},backend:r}),ne=mp({inputs:{a:Q,b:U},backend:r}),te=zo({inputs:{a:S,b:ne},backend:r}),ae=Tx({inputs:{a:S,b:ne},backend:r}),pe=Qr({inputs:{input:te},backend:r}),me=Qr({inputs:{input:ae},backend:r}),fe=Mo({inputs:{input:te},backend:r}),ve=Mo({inputs:{input:ae},backend:r}),$e=Bo({inputs:[pe,me],backend:r,attrs:{axis:0}}),Oe=Bo({inputs:[fe,ve],backend:r,attrs:{axis:0}}),Be=r.data.get($e.dataId).values,et=r.data.get(Oe.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(me),r.disposeIntermediateTensorInfo(ve),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(Oe),{real:Be,imag:et}}function kU(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let o=0,a=0;for(let i=0;i<e;i++){const l=xv(r*i,e,t),u=_g(n,i);o+=u.real*l.real-u.imag*l.imag,a+=u.real*l.imag+u.imag*l.real}t&&(o/=e,a/=e),gv(s,o,a,r)}return s}function TU(n){const{inputs:e,backend:t}=n,{input:s}=e,r=G(s.shape),o=s.shape[s.shape.length-1],a=r/o,i=Ge({inputs:{x:s},backend:t,attrs:{shape:[a,o]}}),l=$I(i,!1,t),u=Ge({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),u}const EU={kernelName:bh,backendName:"cpu",kernelFunc:TU};function Rx(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:o}=t,a=o||oo(r),i=tt(a,G(s));return RU(i,r,a),e.makeTensorInfo(s,a,i)}const AU={kernelName:wh,backendName:"cpu",kernelFunc:Rx};function RU(n,e,t){n.fill(e)}const DU={kernelName:vh,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,o=vt(s.dtype,G(s.shape)),[a,i,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let d=0;d<a;d++){const p=d*l*i*u;for(let f=0;f<i;f++){const m=f*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let x=0;x<u;x++){const w=Math.round(l-g-1),b=p+m+y+x;let $=c[b];if(w>=0&&w<l){const N=w*u,T=p+m+N+x;$=c[T]}o[b]=$}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function OU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=wI({inputs:{x:r,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const g=m;if(c==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const y=Ge({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});m=zo({inputs:{a:m,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else m=zo({inputs:{a:m,b:a},backend:t});t.disposeIntermediateTensorInfo(g)}if(p){const g=m;if(c==="NCHW"&&p==="prelu"&&i.shape.length===1&&i.shape[0]!==1){const y=Ge({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});m=Gc(t,m,p,y,f),t.disposeIntermediateTensorInfo(y)}else m=Gc(t,m,p,i,f);t.disposeIntermediateTensorInfo(g)}return m}const _U={kernelName:$i,backendName:"cpu",kernelFunc:OU};function FU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=vI({inputs:{x:r,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const g=m;m=zo({inputs:{a:m,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=Gc(t,m,p,i,f),t.disposeIntermediateTensorInfo(g)}return m}const LU={kernelName:Si,backendName:"cpu",kernelFunc:FU};function PU(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=G(s.shape),a=r.shape,i=a[a.length-1],[l,u,c,h]=Ud(s,r);if(u===0)return t.makeTensorInfo(l,s.dtype,[]);const d=t.data.get(r.dataId).values,p=t.bufferSync(s),f=AS(d,p,s.dtype,u,i,c,h,s.shape,o);return t.makeTensorInfo(l,s.dtype,f.values)}const zU={kernelName:$h,backendName:"cpu",kernelFunc:PU};function MU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:a,batchDims:i}=s;le([r,o],"gatherV2");const l=Ie(a,r.shape)[0],u=t.data.get(o.dataId).values,c=r.shape[l];for(let b=0;b<u.length;++b){const $=u[b];I($<=c-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${c-1}]`)}let h=i;i==null&&(h=0);const d=G(o.shape),p=Vg(r,o,l,h),f=Ge({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Ge({inputs:{x:o},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=t.bufferSync(m),x=t.bufferSync(f),w=RS(x,y,g);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(p.outputShape,w.dtype,w.values)}const BU={kernelName:al,backendName:"cpu",kernelFunc:MU};function VU(n){const{inputs:e,backend:t}=n,{input:s}=e,r=G(s.shape),o=s.shape[s.shape.length-1],a=r/o,i=Ge({inputs:{x:s},backend:t,attrs:{shape:[a,o]}}),l=$I(i,!0,t),u=Ge({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),u}const WU={kernelName:Sh,backendName:"cpu",kernelFunc:VU};const UU=Fe(la,n=>Number.isFinite(n)?1:0,"bool"),GU={kernelName:la,backendName:"cpu",kernelFunc:UU};const HU=Fe(ua,n=>Math.abs(n)===1/0?1:0,"bool"),jU={kernelName:ua,backendName:"cpu",kernelFunc:HU};const qU=Fe(ca,n=>Number.isNaN(n)?1:0,"bool"),KU={kernelName:ca,backendName:"cpu",kernelFunc:qU};function XU(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,a=LS(s,r,o);return e.makeTensorInfo([a.length],"float32",a)}const YU={kernelName:Nh,backendName:"cpu",kernelFunc:XU};const ZU=Fe(da,n=>Math.log1p(n)),JU={kernelName:da,backendName:"cpu",kernelFunc:ZU};const QU=at((n,e)=>n&&e),eG=yt(hl,QU,null,"bool"),tG={kernelName:hl,backendName:"cpu",kernelFunc:eG};const nG=Fe(dl,n=>n?0:1,"bool"),sG={kernelName:dl,backendName:"cpu",kernelFunc:nG};const rG=at((n,e)=>n||e),oG=yt(pl,rG,null,"bool"),aG={kernelName:pl,backendName:"cpu",kernelFunc:oG};function iG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:a,alpha:i,beta:l}=s;le(r,"LRN");const u=r.shape[3],c=u-1,h=t.data.get(r.dataId).values,d=G(r.shape),p=new Float32Array(d);function f(m){const g=m%u;let y=m-g+Math.max(0,g-o);const x=m-g+Math.min(g+o,c);let w=0;for(;y<=x;y++){const b=h[y];w+=b*b}return w}for(let m=0;m<d;m++){const g=f(m),y=h[m]*Math.pow(a+i*g,-l);p[m]=y}return t.makeTensorInfo(r.shape,r.dtype,p)}const lG={kernelName:fl,backendName:"cpu",kernelFunc:iG};function uG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:a}=e,{depthRadius:i,bias:l,alpha:u,beta:c}=s;le(a,"LRNGrad");const h=G(a.shape),d=a.shape[3],p=t.data.get(a.dataId).values,f=t.data.get(r.dataId).values,m=t.data.get(o.dataId).values,g=new Float32Array(h),y=h;for(let x=0;x<y;x++){const w=x%d,b=x-w+Math.max(0,w-i),$=x-w+Math.min(d,w+i+1);let N=0;for(let T=b;T<$;T++)N+=Math.pow(f[T],2);N=u*N+l;for(let T=b;T<$;T++){let A=-2*u*c*f[T]*m[x]/N;x===T&&(A+=Math.pow(N,-c)),A*=p[x],g[T]+=A}}return t.makeTensorInfo(a.shape,r.dtype,g)}const cG={kernelName:Ch,backendName:"cpu",kernelFunc:uG};function SI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:a}=s,i=t;let l=r.shape;const u=l.length,c=Ie(o,l);let h=c;const d=Qe(h,u);let p=i.data.get(r.dataId).values;if(d!=null){const b=new Array(u);for(let $=0;$<b.length;$++)b[$]=l[d[$]];p=Cx(p,l,r.dtype,d,b),h=rt(h.length,u),l=b}le(r,"max"),Ft("max",h,u);const[f,m]=Nt(l,h),g=G(m),y=zS(p,g,f,r.dtype),x=i.write(y,f,r.dtype);let w=f;return a&&(w=st(f,c)),{dataId:x,shape:w,dtype:r.dtype}}const hG={kernelName:ml,backendName:"cpu",kernelFunc:SI};function dG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;le(r,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;I(_t(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=_n(r.shape,o,a,u,i,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Ce(c.inShape,c.outShape))h=ms({inputs:{x:r},backend:t});else{const d=t.data.get(r.dataId).values,p=de(r.shape),f=Ex(d,r.shape,r.dtype,p,c,"max");h=t.makeTensorInfo(c.outShape,r.dtype,f.values)}return h}const pG={kernelName:gl,backendName:"cpu",kernelFunc:dG};function fG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=s;le(r,"maxPool3d");const c=Fs(r.shape,o,a,1,i,l,u),h=t.data.get(r.dataId).values,d=bI(h,r.shape,r.dtype,de(r.shape),c,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const mG={kernelName:yl,backendName:"cpu",kernelFunc:fG};function gG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,{filterSize:a,strides:i,pad:l,dimRoundingMode:u}=s;le([r,o],"maxPool3DGrad");const c=Fs(o.shape,a,i,1,l,u),h=t.bufferSync(o),d=r4(h,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterDepth,b=c.effectiveFilterHeight,$=c.effectiveFilterWidth,N=w-1-c.padInfo.front,T=$-1-c.padInfo.left,A=b-1-c.padInfo.top,k=we(o.shape,"float32"),E=t.bufferSync(r);for(let S=0;S<c.batchSize;++S)for(let D=0;D<c.inChannels;++D)for(let F=0;F<c.inDepth;++F)for(let z=0;z<c.inHeight;++z)for(let M=0;M<c.inWidth;++M){const W=F-N,j=z-A,U=M-T;let q=0;for(let K=0;K<w;K+=g){const X=(W+K)/p;if(!(X<0||X>=c.outDepth||Math.floor(X)!==X))for(let J=0;J<b;J+=y){const Q=(j+J)/f;if(!(Q<0||Q>=c.outHeight||Math.floor(Q)!==Q))for(let ne=0;ne<$;ne+=x){const te=(U+ne)/m;if(te<0||te>=c.outWidth||Math.floor(te)!==te)continue;const ae=w*b*$-1-d.get(S,X,Q,te,D),pe=K*b*$+J*$+ne,me=ae===pe?1:0;if(me===0)continue;const fe=E.get(S,X,Q,te,D);q+=fe*me}}}k.set(q,S,F,z,M,D)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const yG={kernelName:Th,backendName:"cpu",kernelFunc:gG};function xG(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:a}=e,i=o;le([o,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=_n(i.shape,l,u,1,c,h),p=t.data.get(i.dataId).values,f=we(d.outShape,i.dtype,xI(p,i.shape,i.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,x=d.dilationWidth,w=d.effectiveFilterHeight,b=d.effectiveFilterWidth,$=b-1-d.padInfo.left,N=w-1-d.padInfo.top,T=we(i.shape,"float32"),A=t.data.get(r.dataId).values,k=we(r.shape,"float32",A);for(let E=0;E<d.batchSize;++E)for(let S=0;S<d.inChannels;++S)for(let D=0;D<d.inHeight;++D)for(let F=0;F<d.inWidth;++F){const z=D-N,M=F-$;let W=0;for(let j=0;j<w;j+=y){const U=(z+j)/m;if(!(U<0||U>=d.outHeight||Math.floor(U)!==U))for(let q=0;q<b;q+=x){const K=(M+q)/g;if(K<0||K>=d.outWidth||Math.floor(K)!==K)continue;const X=w*b-1-f.get(E,U,K,S),J=j*b+q,Q=X===J?1:0;if(Q===0)continue;const ne=k.get(E,U,K,S);W+=ne*Q}}T.set(W,E,D,F,S)}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const bG={kernelName:kh,backendName:"cpu",kernelFunc:xG};function wG(n,e,t,s,r){const o=de(e),a=Ex(n,e,t,o,r,"max"),i=xI(n,e,t,r,!0,s);return[a.values,i.values]}const vG={kernelName:Eh,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:a,includeBatchInIndex:i}=e,l=t;le(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=_n(s.shape,r,o,[1,1],a),[h,d]=wG(u,s.shape,s.dtype,i,c),p=l.write(h,c.outShape,s.dtype),f=l.write(d,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function $G(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=Ie(o,r.shape),u=Nt(r.shape,i)[1],c=G(u),h=[],d=t.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);const p=dr({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});h.push(p);const f=Ax({inputs:{a:p,b:d},backend:t});h.push(f);const m=$u({inputs:{x:f},backend:t,attrs:{axis:o,keepDims:a}});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const SG={kernelName:xl,backendName:"cpu",kernelFunc:$G};function IG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;le(r,"min");const i=Ie(o,r.shape);let l=i;const u=Qe(l,r.shape.length);let c=r;u!=null&&(c=sn({inputs:{x:r},backend:t,attrs:{perm:u}}),l=rt(l.length,r.shape.length)),Ft("min",l,c.shape.length);const[h,d]=Nt(c.shape,l),p=G(d),f=Dt(G(h),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const x=y*p;let w=m[x];for(let b=0;b<p;++b){const $=m[x+b];(Number.isNaN($)||$<w)&&(w=$)}f[y]=w}u!=null&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(h,c.dtype,f);if(a){const y=st(h,i),x=Ge({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}const NG={kernelName:bl,backendName:"cpu",kernelFunc:IG};function CG(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,mode:a}=s;le(r,"mirrorPad");const i=o.map((w,b)=>w[0]+r.shape[b]+w[1]),l=o.map(w=>w[0]),u=o.map((w,b)=>w[0]+r.shape[b]),c=a==="reflect"?0:1,h=t.data.get(r.dataId).values,d=r.shape.length,p=de(r.shape),f=G(i),m=i.length,g=de(i),y=vt(r.dtype,f);for(let w=0;w<f;w++){let b=ao(w,m,g);for(let N=0;N<m;N++)b[N]<l[N]?b[N]=l[N]*2-b[N]-c:b[N]>=u[N]&&(b[N]=(u[N]-1)*2-b[N]+c);b=b.map((N,T)=>N-l[T]);const $=Un(b,d,p);y[w]=h[$]}return{dataId:t.write(y,i,r.dtype),shape:i,dtype:r.dtype}}const kG={kernelName:wl,backendName:"cpu",kernelFunc:CG};const TG=at(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),EG=yt(ma,TG),AG={kernelName:ma,backendName:"cpu",kernelFunc:EG};var ic={exports:{}},RG=ic.exports,y0;function DG(){return y0||(y0=1,(function(n){(function(e,t,s){function r(l){var u=this,c=i();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function o(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function a(l,u){var c=new r(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&o(h,c),d.state=function(){return o(c,{})}),d}function i(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=a:this.alea=a})(RG,n)})(ic)),ic.exports}var lc={exports:{}},OG=lc.exports,x0;function _G(){return x0||(x0=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xor128=a})(OG,n)})(lc)),lc.exports}var uc={exports:{}},FG=uc.exports,b0;function LG(){return b0||(b0=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,i===(i|0)?l.x=i:u+=i;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function o(i,l){return l.x=i.x,l.y=i.y,l.z=i.z,l.w=i.w,l.v=i.v,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xorwow=a})(FG,n)})(uc)),uc.exports}var cc={exports:{}},PG=cc.exports,w0;function zG(){return w0||(w0=1,(function(n){(function(e,t,s){function r(i){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,i)}function o(i,l){return l.x=i.x.slice(),l.i=i.i,l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.x&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xorshift7=a})(PG,n)})(cc)),cc.exports}var hc={exports:{}},MG=hc.exports,v0;function BG(){return v0||(v0=1,(function(n){(function(e,t,s){function r(i){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,f;return l.w=c=c+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(c^c>>>16)|0};function u(c,h){var d,p,f,m,g,y=[],x=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,x=Math.max(x,h.length)),f=0,m=-32;m<x;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,d=y[m&127]^=p+g,f=d==0?f+1:0);for(f>=128&&(y[(h&&h.length||0)&127]=-1),f=127,m=512;m>0;--m)p=y[f+34&127],d=y[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,y[f]=p^d;c.w=g,c.X=y,c.i=f}u(l,i)}function o(i,l){return l.i=i.i,l.w=i.w,l.X=i.X.slice(),l}function a(i,l){i==null&&(i=+new Date);var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(c.X&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.xor4096=a})(MG,n)})(hc)),hc.exports}var dc={exports:{}},VG=dc.exports,$0;function WG(){return $0||($0=1,(function(n){(function(e,t,s){function r(i){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,i===Math.floor(i)?(l.a=i/4294967296|0,l.b=i|0):u+=i;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function o(i,l){return l.a=i.a,l.b=i.b,l.c=i.c,l.d=i.d,l}function a(i,l){var u=new r(i),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&o(c,u),h.state=function(){return o(u,{})}),h}t&&t.exports?t.exports=a:this.tychei=a})(VG,n)})(dc)),dc.exports}var pc={exports:{}},UG=pc.exports,S0;function GG(){return S0||(S0=1,(function(n){(function(e,t,s){var r=256,o=6,a=52,i="random",l=s.pow(r,o),u=s.pow(2,a),c=u*2,h=r-1,d;function p(b,$,N){var T=[];$=$==!0?{entropy:!0}:$||{};var A=y(g($.entropy?[b,w(t)]:b??x(),3),T),k=new f(T),E=function(){for(var S=k.g(o),D=l,F=0;S<u;)S=(S+F)*r,D*=r,F=k.g(1);for(;S>=c;)S/=2,D/=2,F>>>=1;return(S+F)/D};return E.int32=function(){return k.g(4)|0},E.quick=function(){return k.g(4)/4294967296},E.double=E,y(w(k.S),t),($.pass||N||function(S,D,F,z){return z&&(z.S&&m(z,k),S.state=function(){return m(k,{})}),F?(s[i]=S,D):S})(E,A,"global"in $?$.global:this==s,$.state)}function f(b){var $,N=b.length,T=this,A=0,k=T.i=T.j=0,E=T.S=[];for(N||(b=[N++]);A<r;)E[A]=A++;for(A=0;A<r;A++)E[A]=E[k=h&k+b[A%N]+($=E[A])],E[k]=$;(T.g=function(S){for(var D,F=0,z=T.i,M=T.j,W=T.S;S--;)D=W[z=h&z+1],F=F*r+W[h&(W[z]=W[M=h&M+D])+(W[M]=D)];return T.i=z,T.j=M,F})(r)}function m(b,$){return $.i=b.i,$.j=b.j,$.S=b.S.slice(),$}function g(b,$){var N=[],T=typeof b,A;if($&&T=="object")for(A in b)try{N.push(g(b[A],$-1))}catch{}return N.length?N:T=="string"?b:b+"\0"}function y(b,$){for(var N=b+"",T,A=0;A<N.length;)$[h&A]=h&(T^=$[h&A]*19)+N.charCodeAt(A++);return w($)}function x(){try{var b;return d&&(b=d.randomBytes)?b=b(r):(b=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(b)),w(b)}catch{var $=e.navigator,N=$&&$.plugins;return[+new Date,e,N,e.screen,w(t)]}}function w(b){return String.fromCharCode.apply(0,b)}if(y(s.random(),t),n.exports){n.exports=p;try{d=Wm}catch{}}else s["seed"+i]=p})(typeof self<"u"?self:UG,[],Math)})(pc)),pc.exports}var Mp,I0;function HG(){if(I0)return Mp;I0=1;var n=DG(),e=_G(),t=LG(),s=zG(),r=BG(),o=WG(),a=GG();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=o,Mp=a,Mp}var jG=HG();function II(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,a=r.shape.length;let i=o;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);const l=Ie([i],r.shape),u=SI({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=st(u.shape,l),h=Ge({inputs:{x:u},backend:t,attrs:{shape:c}}),d=Tx({inputs:{a:r,b:h},backend:t}),p=CS({inputs:{x:d},backend:t}),f=$u({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),m=Ge({inputs:{x:f},backend:t,attrs:{shape:c}}),g=Ax({inputs:{a:p,b:m},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}const qG={kernelName:zl,backendName:"cpu",kernelFunc:II};function KG(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:a,normalized:i}=s;le(r,"multinomial");const l=i?r:II({inputs:{logits:r},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=t.data.get(l.dataId).values,d=[u,o],p=Dt(G(d),"int32");for(let f=0;f<u;++f){const m=f*c,g=new Float32Array(c-1);g[0]=h[m];for(let w=1;w<g.length;++w)g[w]=g[w-1]+h[m+w];const y=jG.alea(a.toString()),x=f*o;for(let w=0;w<o;++w){const b=y();p[x+w]=g.length;for(let $=0;$<g.length;$++)if(b<g[$]){p[x+w]=$;break}}}return i||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",p)}const XG={kernelName:Ah,backendName:"cpu",kernelFunc:KG};const YG=Md;function ZG(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=s;le(r,"NonMaxSuppression");const u=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,{selectedIndices:h}=YG(u,c,a,i,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const JG={kernelName:Rh,backendName:"cpu",kernelFunc:ZG};const QG=Bd;function eH(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=s;le(r,"NonMaxSuppressionPadded");const c=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,{selectedIndices:d,validOutputs:p}=QG(c,h,a,i,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const tH={kernelName:Dh,backendName:"cpu",kernelFunc:eH};const nH=Vd;function sH(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=s;le(r,"NonMaxSuppressionWithScore");const c=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,d=a,p=i,f=l,m=u,{selectedIndices:g,selectedScores:y}=nH(c,h,d,p,f,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const rH={kernelName:Oh,backendName:"cpu",kernelFunc:sH};function oH(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:a,onValue:i,offValue:l}=s;le(r,"oneHot");const u=G(r.shape),c=new Float32Array(u*a);c.fill(l);const h=t.data.get(r.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<a&&(c[d*a+h[d]]=i);return t.makeTensorInfo([...r.shape,a],o,c)}const aH={kernelName:Il,backendName:"cpu",kernelFunc:oH};function jc(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Qr({inputs:{input:s},backend:t}),o=jc({inputs:{x:r},backend:t}),a=Mo({inputs:{input:s},backend:t}),i=jc({inputs:{x:a},backend:t}),l=un({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return Rx({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const iH={kernelName:Wl,backendName:"cpu",kernelFunc:jc};function NI(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Qr({inputs:{input:s},backend:t}),o=NI({inputs:{x:r},backend:t}),a=Mo({inputs:{input:s},backend:t}),i=jc({inputs:{x:a},backend:t}),l=un({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return Rx({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const lH={kernelName:Sl,backendName:"cpu",kernelFunc:NI};function CI(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Hc({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,a=e[0].dtype;e.forEach(c=>{Ot(o,c.shape,"All tensors passed to stack must have matching shapes"),I(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],l=e.map(c=>{const h=Hc({inputs:{input:c},backend:t,attrs:{dim:r}});return i.push(h),h}),u=Bo({inputs:l,backend:t,attrs:{axis:r}});return i.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const uH={kernelName:Nl,backendName:"cpu",kernelFunc:CI};function cH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:a}=s;le(r,"pad");const i=o.map((x,w)=>x[0]+r.shape[w]+x[1]),l=o.map(x=>x[0]),u=t.data.get(r.dataId).values,c=G(r.shape),h=r.shape.length,d=de(r.shape),p=G(i),f=i.length,m=de(i),g=vt(r.dtype,p);a!==0&&g.fill(a);for(let x=0;x<c;x++){const b=ao(x,h,d).map((N,T)=>N+l[T]),$=Un(b,f,m);g[$]=u[x]}return{dataId:t.write(g,i,r.dtype),shape:i,dtype:r.dtype}}const kI={kernelName:Cl,backendName:"cpu",kernelFunc:cH};const hH=at((n,e)=>Math.pow(n,e)),dH=yt(ya,hH),pH={kernelName:ya,backendName:"cpu",kernelFunc:dH};function fH(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:a}=e,{outputRaggedRank:i}=s,l=r.map(y=>t.data.get(y.dataId).values),u=r.map(y=>y.shape),c=t.data.get(o.dataId).values,h=t.data.get(a.dataId).values,[d,p,f]=GS(l,u,c,o.shape,o.dtype,h,a.shape),m=d.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(f,o.dtype,p);return m.concat([g])}const mH={kernelName:_h,backendName:"cpu",kernelFunc:fH};function gH(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,a=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=HS(a,s.shape,s.dtype,i,r.shape,l,o.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const yH={kernelName:Fh,backendName:"cpu",kernelFunc:gH};function xH(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=s,u=t.data.get(r.dataId).values,c=t.data.get(o.dataId).values,h=t.data.get(a.dataId).values,d=i.map(g=>t.data.get(g.dataId).values),p=i.map(g=>g.shape),[f,m]=jS(u,r.shape,c,o.shape,o.dtype,h,a.shape,d,p,l);return t.makeTensorInfo(f,o.dtype,m)}const bH={kernelName:Lh,backendName:"cpu",kernelFunc:xH};function wH(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:o,step:a}=t,i=qS(s,r,a,o);return e.makeTensorInfo([i.length],o,i)}const vH={kernelName:Ph,backendName:"cpu",kernelFunc:wH};const $H=Fe(xa,n=>1/n),SH={kernelName:xa,backendName:"cpu",kernelFunc:$H};function IH(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s;le(r,"resizeBilinear");const l=de(r.shape),[u,c]=i,[h,d,p,f]=r.shape,m=t.data.get(r.dataId).values,g=new Float32Array(G([h,u,c,f])),y=[o&&u>1?d-1:d,o&&c>1?p-1:p],x=[o&&u>1?u-1:u,o&&c>1?c-1:c];let w=0;const b=y[0]/x[0],$=y[1]/x[1];for(let N=0;N<h;N++)for(let T=0;T<u;T++){let A;a?A=b*(T+.5)-.5:A=b*T;const k=Math.max(0,Math.floor(A)),E=A-k,S=Math.min(d-1,Math.ceil(A)),D=N*l[0]+k*l[1],F=N*l[0]+S*l[1];for(let z=0;z<c;z++){let M;a?M=$*(z+.5)-.5:M=$*z;const W=Math.max(0,Math.floor(M)),j=M-W,U=Math.min(p-1,Math.ceil(M)),q=D+W*l[2],K=F+W*l[2],X=D+U*l[2],J=F+U*l[2];for(let Q=0;Q<f;Q++){const ne=m[q+Q],te=m[K+Q],ae=m[X+Q],pe=m[J+Q],me=ne+(ae-ne)*j,fe=te+(pe-te)*j,ve=me+(fe-me)*E;g[w++]=ve}}}return t.makeTensorInfo([h,u,c,f],"float32",g)}const NH={kernelName:Rl,backendName:"cpu",kernelFunc:IH};function CH(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s;le([o,r],"resizeBilinearGrad");const i=de(r.shape),[l,u,c,h]=r.shape,[,d,p]=o.shape,f=new Float32Array(l*u*c*h),m=[a&&d>1?u-1:u,a&&p>1?c-1:c],g=[a&&d>1?d-1:d,a&&p>1?p-1:p],y=m[0]/g[0],x=m[1]/g[1],w=t.data.get(o.dataId).values;let b=0;for(let $=0;$<l;$++){const N=$*i[0];for(let T=0;T<d;T++){const A=T*y,k=Math.floor(A),E=Math.min(Math.ceil(A),u-1),S=N+k*i[1],D=N+E*i[1],F=A-k,z=1-F;for(let M=0;M<p;M++){const W=M*x,j=Math.floor(W),U=Math.min(Math.ceil(W),c-1),q=W-j,K=1-q,X=S+j*i[2],J=S+U*i[2],Q=D+j*i[2],ne=D+U*i[2],te=z*K,ae=z*q,pe=F*K,me=F*q;for(let fe=0;fe<h;fe++){const ve=w[b++];f[X+fe]+=ve*te,f[J+fe]+=ve*ae,f[Q+fe]+=ve*pe,f[ne+fe]+=ve*me}}}}return t.makeTensorInfo([l,c,u,h],"float32",f)}const kH={kernelName:Bh,backendName:"cpu",kernelFunc:CH};function TH(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s;le(r,"resizeNearestNeighbor");const l=de(r.shape),[u,c]=i,[h,d,p,f]=r.shape,m=t.data.get(r.dataId).values,g=new Float32Array(h*u*c*f),y=[o&&u>1?d-1:d,o&&c>1?p-1:p],x=[o&&u>1?u-1:u,o&&c>1?c-1:c],w=y[0]/x[0],b=y[1]/x[1];let $=0;for(let N=0;N<h;N++){const T=N*l[0];for(let A=0;A<u;A++){const k=a?w*(A+.5):w*A;let E=Math.min(d-1,o?Math.round(k):Math.floor(k));a&&(E=Math.max(0,E));const S=T+E*l[1];for(let D=0;D<c;D++){const F=a?b*(D+.5):b*D;let z=Math.min(p-1,o?Math.round(F):Math.floor(F));a&&(z=Math.max(0,z));const M=S+z*l[2];for(let W=0;W<f;W++){const j=m[M+W];g[$++]=j}}}}return t.makeTensorInfo([h,u,c,f],r.dtype,g)}const EH={kernelName:Al,backendName:"cpu",kernelFunc:TH};function AH(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s;le([o,r],"resizeNearestNeighborGrad");const i=de(r.shape),l=de(o.shape),[u,c,h,d]=r.shape,[,p,f]=o.shape,m=new Float32Array(u*c*h*d),g=t.data.get(o.dataId).values,y=[a&&p>1?c-1:c,a&&f>1?h-1:h],x=[a&&p>1?p-1:p,a&&f>1?f-1:f],w=y[0]/x[0],b=y[1]/x[1],$=1/w,N=1/b,T=Math.ceil($)*2+2,A=Math.ceil(N)*2+2;for(let k=0;k<u;k++){const E=k*i[0];for(let S=0;S<c;S++){const D=E+S*i[1],F=Math.floor(S*$),z=Math.floor(F-T/2);for(let M=0;M<h;M++){const W=D+M*i[2],j=Math.floor(M*N),U=Math.floor(j-A/2);for(let q=0;q<d;q++){let K=0;for(let X=0;X<T;X++){const J=X+z;if(J<0||J>=p)continue;const Q=E+J*l[1],ne=J*w,te=Math.min(c-1,a?Math.round(ne):Math.floor(ne));if(S===te)for(let ae=0;ae<A;ae++){const pe=ae+U;if(pe<0||pe>=f)continue;const me=Q+pe*l[2],fe=pe*b,ve=Math.min(h-1,a?Math.round(fe):Math.floor(fe));M===ve&&(K+=g[me+q])}}m[W+q]=K}}}}return t.makeTensorInfo(r.shape,r.dtype,m)}const RH={kernelName:Mh,backendName:"cpu",kernelFunc:AH};function DH(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s;le(r,"reverse");const a=r.shape.length,i=Ie(o,r.shape);if(a===0)return ms({inputs:{x:r},backend:t});const l=new ct(r.shape,r.dtype),u=t.bufferSync(r);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),d=h.slice();i.forEach(p=>d[p]=r.shape[p]-1-d[p]),l.set(u.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const OH={kernelName:Dl,backendName:"cpu",kernelFunc:DH};const _H={kernelName:sd,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:a}=e,i=t,l=vt(s.dtype,G(s.shape)),[u,c,h,d]=s.shape,[p,f]=Ng(a,c,h),m=255,g=Math.sin(r),y=Math.cos(r),x=i.data.get(s.dataId).values;for(let b=0;b<u;b++){const $=b*h*c*d;for(let N=0;N<c;N++){const T=N*(h*d);for(let A=0;A<h;A++){const k=A*d;for(let E=0;E<d;E++){const S=[u,N,A,E],D=S[2],F=S[1];let z=(D-p)*y-(F-f)*g,M=(D-p)*g+(F-f)*y;z=Math.round(z+p),M=Math.round(M+f);let W=o;if(typeof o!="number"&&(E===3?W=m:W=o[E]),z>=0&&z<h&&M>=0&&M<c){const U=M*(h*d),q=z*d,K=$+U+q+E;W=x[K]}const j=$+T+k+E;l[j]=W}}}}return{dataId:i.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const FH=Fe(va,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),LH={kernelName:va,backendName:"cpu",kernelFunc:FH};function PH(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:a}=s,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=wr(o,r,a),d=!0,p=t.bufferSync(r),f=t.bufferSync(o),m=_r(p,f,a,h,u,l,i,c,0,d);return t.makeTensorInfo(a,m.dtype,m.values)}const zH={kernelName:Vh,backendName:"cpu",kernelFunc:PH};function MH(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function BH(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function VH(n,e,t,s,r,o){const a=tt("int32",t*r);for(let i=0;i<t;++i){const l=n.slice(i*s,(i+1)*s),u=i*r;for(let c=0;c<r;++c)a[u+c]=o==="left"?MH(l,e[c+u]):BH(l,e[c+u])}return a}function WH(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:a}=s,i=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,u=VH(i,l,r.shape[0],r.shape[1],o.shape[1],a);return t.makeTensorInfo(o.shape,"int32",u)}const UH={kernelName:Uh,backendName:"cpu",kernelFunc:WH};function GH(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e;le([s,r,o],"select");const a=s.shape.length,i=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=Jt(r.dtype,o.dtype),h=Dt(G(r.shape),c);let d=0;const p=a===0||a>1||r.shape.length===1?1:G(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let m=0;m<p;m++)i[f]===1?h[d++]=l[f]:h[d++]=u[f];return t.makeTensorInfo(r.shape,c,h)}const HH={kernelName:Ol,backendName:"cpu",kernelFunc:GH};const jH=jd,qH=qd,KH=Fe(Sa,n=>n>=0?qH*n:jH*(Math.exp(n)-1)),XH={kernelName:Sa,backendName:"cpu",kernelFunc:KH};const YH=Fe(Ca,n=>n<0?-1:n>0?1:0),ZH={kernelName:Ca,backendName:"cpu",kernelFunc:YH};const JH=Fe(Ia,n=>Math.sin(n)),QH={kernelName:Ia,backendName:"cpu",kernelFunc:JH};const ej=Fe(Na,n=>Math.sinh(n)),tj={kernelName:Na,backendName:"cpu",kernelFunc:ej};const nj=11920928955078125e-23,N0=Math.log(nj)+2,sj=Fe(Ta,n=>{const e=n>-N0,t=n<N0,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),rj={kernelName:Ta,backendName:"cpu",kernelFunc:sj};function oj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:a}=s;le([r],"spaceToBatchND");const i=G(o),l=[[0,0]];l.push(...a);for(let N=1+o.length;N<r.shape.length;++N)l.push([0,0]);const u=kI.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),c=uu(u.shape,o,i,!1),h=cu(c.length,o.length,!1),d=hu(u.shape,o,i,!1),m=Ge({inputs:{x:u},backend:t,attrs:{shape:c}}),x=sn({inputs:{x:m},backend:t,attrs:{perm:h}}),$=Ge({inputs:{x},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),$}const aj={kernelName:Ll,backendName:"cpu",kernelFunc:oj};function ij(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,c=t.data.get(a.dataId).values[0],[h,d,p,f,m]=ZS(i,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const lj={kernelName:Gh,backendName:"cpu",kernelFunc:ij};function uj(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(t.data.get(r.dataId).values),i=t.data.get(s.dataId).values,l=Array.from(t.data.get(o.dataId).values),[u,c,h]=JS(i,s.shape,s.dtype,a,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const cj={kernelName:Hh,backendName:"cpu",kernelFunc:uj};function hj(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=kx(a,s.shape,s.dtype,i,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const dj={kernelName:jh,backendName:"cpu",kernelFunc:hj};function pj(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,[u,c]=kx(a,s.shape,s.dtype,i,l);return t.makeTensorInfo(c,s.dtype,u)}const fj={kernelName:qh,backendName:"cpu",kernelFunc:pj};function mj(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:a}=e,{outputShape:i}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=wr(o,r,i),p=!1,f=t.bufferSync(r);let m;switch(o.dtype){case"bool":{const g=t.bufferSync(o),y=!!t.data.get(a.dataId).values[0];m=_r(f,g,i,d,c,u,l,h,y,p);break}case"float32":{const g=t.bufferSync(o),y=t.data.get(a.dataId).values[0];m=_r(f,g,i,d,c,u,l,h,y,p);break}case"int32":{const g=t.bufferSync(o),y=t.data.get(a.dataId).values[0];m=_r(f,g,i,d,c,u,l,h,y,p);break}case"string":{const g=t.bufferSync(o),y=ks(t.data.get(a.dataId).values[0]);m=_r(f,g,i,d,c,u,l,h,y,p);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return t.makeTensorInfo(i,m.dtype,m.values)}const gj={kernelName:Kh,backendName:"cpu",kernelFunc:mj};function yj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:a}=s,i=Ie(a,r.shape)[0],l=Bg(r,o,i),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{const d=[...c];d[i]=h;const p=eo({inputs:{x:r},backend:t,attrs:{begin:u,size:d}});return u[i]+=h,p})}const xj={kernelName:Pl,backendName:"cpu",kernelFunc:yj};const bj={kernelName:Xh,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;le(t,"square");const r=s.data.get(t.dataId).values,o=new Float32Array(r.length);for(let i=0;i<r.length;++i){const l=r[i];o[i]=l*l}return{dataId:s.write(o,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const wj=Fe(Fa,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),vj={kernelName:Fa,backendName:"cpu",kernelFunc:wj};function $j(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;le(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:b}=vg(r.shape,o,a,i,l,u,c,h,d);let $;if(m)$=Ge({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||y){I(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const N=xg(x,w,b),T=eo({inputs:{x:r},backend:t,attrs:{begin:x,size:N}});$=Ge({inputs:{x:T},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(T)}else{const N=t.bufferSync(r),T=tI(p,N,b,x);$=t.makeTensorInfo(f,T.dtype,T.values)}return $}const Sj={kernelName:Yh,backendName:"cpu",kernelFunc:$j};function Ij(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=t.data.get(c.dataId).values,p=t.data.get(h.dataId).values,[f,m]=nI(d,p,r,o,a,i,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",m)]}const Nj={kernelName:Zh,backendName:"cpu",kernelFunc:Ij};function Cj(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=t.data.get(o.dataId).values,l=t.data.get(a.dataId).values[0],[u,c,h]=sI(i,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const kj={kernelName:Jh,backendName:"cpu",kernelFunc:Cj};function Tj(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(o.dataId).values,i=rI(a,r);return t.makeTensorInfo(o.shape,"int32",i)}const Ej={kernelName:Qh,backendName:"cpu",kernelFunc:Tj};const Aj=Fe(Da,n=>Math.tan(n)),Rj={kernelName:Da,backendName:"cpu",kernelFunc:Aj};const Dj=Fe(Oa,n=>Math.tanh(n)),Oj={kernelName:Oa,backendName:"cpu",kernelFunc:Dj};function _j(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:o}=e,{sliceRank:a,numUpdates:i,sliceSize:l,strides:u,outputSize:c}=wr(o,r,s.shape),h=!1,d=t.bufferSync(r),p=t.bufferSync(o),f=t.bufferSync(s),m=_r(d,p,s.shape,c,l,i,a,u,f,h);return t.makeTensorInfo(s.shape,m.dtype,m.values)}const Fj={kernelName:Wh,backendName:"cpu",kernelFunc:_j};function Lj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;le(r,"tile");const a=aI(t.bufferSync(r),o);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const Pj={kernelName:_a,backendName:"cpu",kernelFunc:Lj};function zj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:a}=s;le(r,"topk");const i=t.data.get(r.dataId).values,[l,u]=lI(i,r.shape,r.dtype,o,a);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const Mj={kernelName:ed,backendName:"cpu",kernelFunc:zj};function Bj(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=t,[c,h,d,p]=r.shape,[f,m]=u??[h,d],g=[c,f,m,p],y=de(r.shape),x=y[0],w=y[1],b=y[2],$=de(g),N=$[0],T=$[1],A=$[2],k=vt(r.dtype,G(g));k.fill(l);const E=s.data.get(r.dataId).values,S=s.data.get(o.dataId).values;for(let F=0;F<c;++F){const z=o.shape[0]===1?S:S.subarray(F*8,F*8+8);for(let M=0;M<f;++M)for(let W=0;W<m;++W)for(let j=0;j<p;++j){let U;const q=z[6]*W+z[7]*M+1;if(q===0)continue;const K=(z[0]*W+z[1]*M+z[2])/q,X=(z[3]*W+z[4]*M+z[5])/q,J=C0(K,d,i),Q=C0(X,h,i);switch(a){case"nearest":U=jj(E,h,d,x,w,b,F,Q,J,j,l);break;case"bilinear":U=qj(E,h,d,x,w,b,F,Q,J,j,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const ne=F*N+M*T+W*A+j;k[ne]=U}return s.makeTensorInfo(g,r.dtype,k)}return{dataId:s.write(k,g,r.dtype),shape:r.shape,dtype:r.dtype}}const Vj={kernelName:td,backendName:"cpu",kernelFunc:Bj};function C0(n,e,t){switch(t){case"reflect":return Wj(n,e);case"wrap":return Uj(n,e);case"nearest":return Hj(n,e);default:return Gj(n)}}function Wj(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return nr(0,t,e-1)}function Uj(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return nr(0,t,e-1)}function Gj(n,e){return n}function Hj(n,e){return nr(0,n,e-1)}function fi(n,e,t,s,r,o,a,i,l,u,c){const h=a*s+i*r+l*o+u;return 0<=i&&i<e&&0<=l&&l<t?n[h]:c}function jj(n,e,t,s,r,o,a,i,l,u,c){const h=Math.round(i),d=Math.round(l);return fi(n,e,t,s,r,o,a,h,d,u,c)}function qj(n,e,t,s,r,o,a,i,l,u,c){const h=Math.floor(i),d=Math.floor(l),p=h+1,f=d+1,m=(f-l)*fi(n,e,t,s,r,o,a,h,d,u,c)+(l-d)*fi(n,e,t,s,r,o,a,h,f,u,c),g=(f-l)*fi(n,e,t,s,r,o,a,p,d,u,c)+(l-d)*fi(n,e,t,s,r,o,a,p,f,u,c);return(p-i)*m+(i-h)*g}function Kj(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;le(o,"unique");const a=s.data.get(o.dataId).values,{outputValues:i,outputShape:l,indices:u}=uI(a,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,i),s.makeTensorInfo([u.length],"int32",u)]}const Xj={kernelName:nd,backendName:"cpu",kernelFunc:Kj};function Yj(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const a=r.shape.length,i=r.shape[o],l=new Array(a-1);let u=0;for(let p=0;p<a;p++)p!==o&&(l[u++]=r.shape[p]);const c=new Array(a).fill(0),h=r.shape.slice();h[o]=1;const d=new Array(i);for(let p=0;p<d.length;p++){c[o]=p;const f=eo({inputs:{x:r},backend:t,attrs:{begin:c,size:h}});d[p]=Ge({inputs:{x:f},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(f)}return d}const Zj={kernelName:Bl,backendName:"cpu",kernelFunc:Yj};function Jj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:a}=s;le(r,"unsortedSegmentSum");const i=r.shape.length,l=o.shape.length,u=[],c=[],h=i-l;let d=o;for(let f=0;f<h;++f){const m=Hc({inputs:{input:d},backend:t,attrs:{dim:f+1}});d=m,c.push(m)}for(let f=0;f<a;++f){const m=_s(f,"int32"),g=t.makeTensorInfo([],"int32",m),y=IS({inputs:{a:g,b:d},backend:t}),x=dr({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),w=mp({inputs:{a:x,b:r},backend:t}),b=$u({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});u.push(b),c.push(g),c.push(y),c.push(x),c.push(w),c.push(b)}const p=CI({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const Qj={kernelName:Vl,backendName:"cpu",kernelFunc:Jj};const eq=[DW,pV,_W,LW,bV,zW,BW,WW,GW,jW,KW,YW,JW,t4,s4,a4,l4,c4,d4,AW,f4,g4,x4,vV,w4,yV,SV,$4,fV,I4,C4,k4,E4,R4,O4,F4,P4,M4,V4,U4,H4,q4,X4,Z4,J4,eU,nU,rU,oU,aU,iU,uU,dU,SW,fU,IV,$U,NV,SU,kV,EU,AU,DU,EV,RV,_U,LU,zU,BU,OV,FV,mV,WU,N4,GU,jU,KU,IW,PV,MV,YU,VV,JU,tG,sG,aG,lG,cG,hG,UV,pG,mG,yG,bG,vG,SG,NG,HV,kG,AG,XG,qV,XV,JG,tH,rH,ZV,aH,lH,uH,kI,pH,CW,eW,mH,yH,bH,vH,gV,Ef,SH,kW,TW,EW,NH,kH,EH,RH,OH,_H,LH,lW,zH,UH,HH,XH,cW,ZH,QH,tj,hW,qG,rj,aj,lj,cj,dj,fj,gj,xj,fW,bj,gW,xW,vj,Sj,Nj,kj,Ej,$W,cU,Rj,Oj,Fj,Pj,Mj,Vj,JV,Xj,Zj,Qj,iH];for(const n of eq)rd(n);const Dr={},Mu={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function TI(n,e){Dr[n]=e}function Yn(n,e){if(!(n in Dr)||e!=null){const s=nq(n,e);if(s!==null)Dr[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Dr[n];return t==null||t.isContextLost()?(delete Dr[n],Yn(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Dr[n])}function tq(n){if(!V().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function nq(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??tq(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Dr[n]},!1),V().getBool("SOFTWARE_WEBGL_ENABLED")&&(Mu.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Mu)||t.getContext("experimental-webgl",Mu):t.getContext("webgl2",Mu)}var Fi;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Fi||(Fi={}));var vn;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(vn||(vn={}));var At;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(At||(At={}));function Su(n,e){return[e,n]}function sq(n,e){return n*e}function Bu(n){const e=G(n),t=Math.ceil(e/4);return wc(t)}function Xa(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function rq(n,e){const[t,s]=Xa(n,e);return t*s*4}function Dx(n,e){const t=n;let s,r,o,a,i,l,u,c,h,d;return V().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,o=t.RGBA16F,a=t.RGBA32F,i=t.RED,u=4,c=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,o=n.RGBA,a=t.RGBA,i=n.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function re(n,e){const t=e();return V().getBool("DEBUG")&&oq(n),t}function oq(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+AI(n,e))}const aq=596e-10,iq=65504;function EI(n){return!!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||aq<Math.abs(n)&&Math.abs(n)<iq)}function AI(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function mi(n,e){return Vs(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function RI(n,e){const t=Vs(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(re(n,()=>n.shaderSource(t,e)),re(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function DI(n,e){const t=Vs(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(re(n,()=>n.shaderSource(t,e)),re(n,()=>n.compileShader(t)),V().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw Ox(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const lq=/ERROR: [0-9]+:([0-9]+):/g;function Ox(n,e){const t=lq.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),o=r.length.toString().length+2,a=r.map((h,d)=>Fr((d+1).toString(),o)+h);let i=0;for(let h=0;h<a.length;h++)i=Math.max(a[h].length,i);const l=a.slice(0,s-1),u=a.slice(s-1,s),c=a.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Fr(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function OI(n){return Vs(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function _I(n,e){if(re(n,()=>n.linkProgram(e)),!V().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function fc(n,e){if(re(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function FI(n,e){const t=Vs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),re(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function LI(n,e){const t=Vs(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return re(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),re(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function uq(){return V().getNumber("WEBGL_VERSION")===2?1:4}function PI(n){return Vs(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function zI(n,e){const t=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function MI(n){return Vs(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Rf(n,e,t,s,r,o,a){const i=n.getAttribLocation(e,t);return i===-1?!1:(re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),re(n,()=>n.vertexAttribPointer(i,r,n.FLOAT,!1,o,a)),re(n,()=>n.enableVertexAttribArray(i)),!0)}function BI(n,e,t){HI(n,t),re(n,()=>n.activeTexture(n.TEXTURE0+t)),re(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function cq(n,e){HI(n,e),re(n,()=>n.activeTexture(n.TEXTURE0+e)),re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function VI(n,e,t){return Vs(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function WI(n,e,t){return n.getUniformLocation(e,t)}function UI(n,e,t,s){re(n,()=>BI(n,e,s)),re(n,()=>n.uniform1i(t,s))}function hq(n){re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),re(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),re(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function mc(n,e,t){re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Df(n,e){re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function gi(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+GI(n,e))}function GI(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Vs(n,e,t){const s=re(n,()=>e());if(s==null)throw new Error(t);return s}function HI(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function to(n,e=2){return G(n.slice(0,n.length-e))}function no(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function yi(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[to(n),...no(n)]),e}function jI(n,e=!1){let t=V().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=V().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&V().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((i,l)=>l>=n.length-2?Zc(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Os(n).newShape);let r=G(n),o=null;n.length<=1&&r<=t?o=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?o=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?o=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?o=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?o=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(o=[n[0],n[1]*n[2]*n[3]]);const a=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||a)if(e){const i=to(n);let l=2,u=2;n.length&&([l,u]=no(n)),r=i*(l/2)*(u/2),o=wc(r).map(c=>c*2)}else o=wc(r);return o}function Vu(n){return n%2===0}function Li(n,e){if(n=n.slice(-2),e=e.slice(-2),Ce(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Vu(t)&&Vu(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Vu(n[0])&&Vu(e[0])}let gc,yc;function qI(n){if(gc==null){const e=Yn(n);gc=e.getParameter(e.MAX_TEXTURE_SIZE)}return gc}function dq(){gc=null}function pq(){yc=null}function KI(n){if(yc==null){const e=Yn(n);yc=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,yc)}function XI(n){if(n===0)return 0;let e;const t=Yn(n);return $n(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:$n(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function $n(n,e){return n.getExtension(e)!=null}function Of(n){try{if(Yn(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function YI(n){if(n===0)return!1;const e=Yn(n);if(n===1){if(!$n(e,"OES_texture_float"))return!1}else if(!$n(e,"EXT_color_buffer_float"))return!1;return _f(e)}function ZI(n){if(n===0)return!1;const e=Yn(n);if(n===1){if(!$n(e,"OES_texture_float")||!$n(e,"WEBGL_color_buffer_float"))return!1}else{if($n(e,"EXT_color_buffer_float"))return _f(e);const s="EXT_color_buffer_half_float";if($n(e,s)){const r=e.getExtension(s);return fq(e,r)}return!1}return _f(e)}function _f(n){const e=Dx(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),a}function fq(n,e){const t=Dx(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),i}function JI(n){return n!==2?!1:Yn(n).fenceSync!=null}function Ya(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&I(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const mq=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:Ya,bindCanvasToFramebuffer:hq,bindColorTextureToFramebuffer:mc,bindTextureToProgramUniformSampler:UI,bindTextureUnit:BI,bindVertexBufferToProgramAttribute:Rf,callAndCheck:re,canBeRepresented:EI,createFragmentShader:DI,createFramebuffer:MI,createProgram:OI,createStaticIndexBuffer:LI,createStaticVertexBuffer:FI,createTexture:PI,createVertexShader:RI,getBatchDim:to,getExtensionOrThrow:mi,getFramebufferErrorMessage:GI,getMaxTexturesInShader:KI,getNumChannels:uq,getProgramUniformLocation:WI,getProgramUniformLocationOrThrow:VI,getRowsCols:no,getShapeAs3D:yi,getTextureShapeFromLogicalShape:jI,getWebGLDisjointQueryTimerVersion:XI,getWebGLErrorMessage:AI,getWebGLMaxTextureSize:qI,hasExtension:$n,isCapableOfRenderingToFloatTexture:YI,isDownloadFloatTextureEnabled:ZI,isReshapeFree:Li,isWebGLFenceEnabled:JI,isWebGLVersionEnabled:Of,linkProgram:_I,logShaderSourceAndInfoLog:Ox,resetMaxTextureSize:dq,resetMaxTexturesInShader:pq,unbindColorTextureFromFramebuffer:Df,unbindTextureUnit:cq,validateFramebuffer:gi,validateProgram:fc,validateTextureSize:zI},Symbol.toStringTag,{value:"Module"}));const ce=V();ce.registerFlag("HAS_WEBGL",()=>ce.getNumber("WEBGL_VERSION")>0);ce.registerFlag("WEBGL_VERSION",()=>Of(2)?2:Of(1)?1:0);ce.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ce.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ce.get("WEBGL_VERSION")===2);ce.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ce.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ce.registerFlag("WEBGL_PACK",()=>ce.getBool("HAS_WEBGL"));ce.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_CLIP",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_REDUCE",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_LAZILY_UNPACK",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_CONV_IM2COL",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>qI(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>KI(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=ce.getNumber("WEBGL_VERSION");return n===0?0:XI(n)});ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ce.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!jf());ce.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>YI(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ce.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ce.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ce.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ZI(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_FENCE_API_ENABLED",()=>JI(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ce.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ce.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});ce.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>jf()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});ce.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ce.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ce.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ce.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ce.registerFlag("WEBGL_EXP_CONV",()=>!1);ce.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ce.getBool("IS_TEST"));ce.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ce.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ce.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ce.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Kt(){let n,e,t,s,r,o,a,i,l,u;return V().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",o="outputColor",a="out vec4 outputColor;",i=V().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",o="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:o,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function go(n,e,t="index"){const s=de(e);return s.map((r,o)=>{const a=`int ${n[o]} = ${t} / ${r}`,i=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r}`:`index -= ${n[o]} * ${r}`;return`${a}; ${i};`}).join("")}function gp(n,e,t="index"){const s=de(e);return s.map((r,o)=>{const a=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,i=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${a}; ${i};`}).join("")}function gq(n,e){const t=n.length,s=n.map(o=>`${e}[${o}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function yq(n,e,t="index"){const s=n.map((o,a)=>a),r=gq(s,e);return r.map((o,a)=>{const i=`int ${n[a]} = ${t} / ${r[a]}`,l=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${i}; ${l};`}).join("")}function _x(n){const e=de(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Fx(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const QI=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:eN}=Ov;function xq(n,e,t){const s=[];if(n.forEach(p=>{const f=G(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:m}=Lx(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),o=n.map(p=>bq(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,i=Kt(),l=$q(i);let u,c,h=Nq(i);return e.isPacked?(u=wq(e.logicalShape,a,t.enableShapeUniforms),c=Iq(i)):(u=vq(e.logicalShape,a,t.enableShapeUniforms),c=Sq(i)),t.packedInputs&&(h+=Eq),[h,l,c,r,u,o,t.userCode].join(`
`)}function Za(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Vq(n,e);case 1:return Uq(n,e);case 2:return Hq(n,e);case 3:return qq(n,e);case 4:return Xq(n,e);case 5:return Yq(n);case 6:return Zq(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function tN(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Bq(n);case 1:return Wq(n,e);case 2:return Gq(n,e);case 3:return jq(n,e);default:return Kq(n,e)}}function bq(n,e,t=!1,s){let r="";t?r+=tN(n,s):r+=Za(n,s);const o=n.shapeInfo.logicalShape,a=e.logicalShape;return o.length<=a.length&&(t?r+=Jq(n,e):r+=Qq(n,e)),r}function wq(n,e,t){switch(n.length){case 0:return nN();case 1:return Aq(n,e,t);case 2:return zq(n,e,t);case 3:return Dq(n,e,t);default:return _q(n,e,t)}}function vq(n,e,t){switch(n.length){case 0:return nN();case 1:return Rq(n,e,t);case 2:return Mq(n,e,t);case 3:return Oq(n,e,t);case 4:return Fq(n,e,t);case 5:return Lq(n,e);case 6:return Pq(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function $q(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Sq(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Iq(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function Nq(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Cq}
    ${kq}
    ${Tq}
  `}const Cq=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,kq=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Tq=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Eq=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function nN(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Aq(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function Rq(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function Dq(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),o=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Oq(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${gp(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=go(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function _q(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),o=r*Math.ceil(n[n.length-2]/2);let a=o,i="",l="b, r, c";for(let u=2;u<n.length-1;u++)a*=n[n.length-u-1],i=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+i,l=`b${u}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${i}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function Fq(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${gp(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=go(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function Lq(n,e){const t=go(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Pq(n,e){const t=go(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function zq(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Ce(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function Mq(n,e,t){return Ce(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function yo(n){return`offset${n}`}function Bq(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Kt();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function Vq(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,o]=n.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=yo(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[i,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${i}, ${l}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function Wq(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,o=Kt();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function Uq(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Ja(n)}
      }
    `;const r=n.shapeInfo.texShape,o=r[0],a=r[1];if(a===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=yo(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${a}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Gq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,a=o[0],i=o[1],l=Kt();if(o!=null&&Ce(t,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Hq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape;if(o!=null&&Ce(t,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=o[0],p=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:i}=Os(t),l=a;if(l.length<t.length){const d=Qa(n,l),p=["row","col"];return`
      ${Za(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${ei(p,i)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Ja(n)}
      }
    `;const u=o[0],c=o[1],h=yo(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function jq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=Qa(n,d),m=["b","row","col"];return`
        ${tN(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${ei(m,p)});
        }
      `}const i=Kt();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `;const l=a[0],u=a[1],c=Math.ceil(t[2]/2),h=c*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `}function qq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[1]*t[2],a=t[2],{newShape:i,keptDims:l}=Os(t),u=i;if(u.length<t.length){const m=Qa(n,u),g=["row","col","depth"];return`
        ${Za(m,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${ei(g,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${a}, 1)));
        ${Ja(n)}
      }
    `;const c=n.shapeInfo.texShape,h=c[0],d=c[1],p=n.shapeInfo.flatOffset;if(d===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===a&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=yo(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Kq(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Kt();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,a=o.length,i=n.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=l[0],c=l[1],h=Math.ceil(o[a-1]/2);let d=h*Math.ceil(o[a-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<a-1;m++)p=`int b${m}, `+p,d*=o[a-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${t}, uv);
    }
  `}function Xq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t[3],a=t[2]*o,i=t[1]*a,{newShape:l,keptDims:u}=Os(t);if(l.length<t.length){const x=Qa(n,l),w=["row","col","depth","depth2"];return`
      ${Za(x,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${ei(w,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${o}, 1)));
        ${Ja(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${s}Shape[3];`,m=`int stride1 = ${s}Shape[2] * stride2;`,g=`int stride0 = ${s}Shape[1] * stride1;`;if(p===i&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===o&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const y=yo(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});
      return sampleTexture(${s}, uv);
    }
  `}function Yq(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],o=e[3]*r,a=e[2]*o,i=e[1]*a,{newShape:l,keptDims:u}=Os(e);if(l.length<e.length){const m=Qa(n,l),g=["row","col","depth","depth2","depth3"];return`
      ${Za(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${ei(g,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${o}, ${r})) +
          depth3;
        ${Ja(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=yo(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${o} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Zq(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:o}=Os(e);if(r.length<e.length){const g=Qa(n,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Za(g)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${ei(y,o)});
      }
    `}const a=e[5],i=e[4]*a,l=e[3]*i,u=e[2]*l,c=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Ja(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===a&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=yo(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Ja(n){const e=n.name,t=G(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Jq(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=eN(n.shapeInfo.logicalShape,e.logicalShape),l=ze(a),u=a-o;let c;const h=["x","y","z","w","u","v"];o===0?c="":a<2&&i.length>=1?c="coords = 0;":c=i.map(x=>`coords.${h[x+u]} = 0;`).join(`
`);let d="";a<2&&o>0?d="coords":d=n.shapeInfo.logicalShape.map((x,w)=>`coords.${h[w+u]}`).join(", ");let p="return outputValue;";const m=G(n.shapeInfo.logicalShape)===1,y=G(e.logicalShape)===1;if(o===1&&!m&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)a===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(i.length){const x=o-2,w=o-1;i.indexOf(x)>-1&&i.indexOf(w)>-1?p="return vec4(outputValue.x);":i.indexOf(x)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(w)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function Qq(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,a=n.shapeInfo.texShape,i=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&i===l&&n.shapeInfo.flatOffset==null&&Ce(a,o))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=ze(l),c=eN(n.shapeInfo.logicalShape,e.logicalShape),h=l-i;let d;const p=["x","y","z","w","u","v"];i===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function ze(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Lx(n,e,t){const{newShape:s,keptDims:r}=Os(e),o=e.length,a=n&&o===3&&e[0]===1,i=a?e.slice(1):s,l=!n&&o>1&&!Ce(e,t)&&s.length<o||a;return{useSqueezeShape:l,uniformShape:l?i:e,keptDims:r}}function Qa(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function ei(n,e){return e.map(t=>n[t]).join(", ")}function e6(n,e,t,s){const r=t.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),o=r.map(c=>c.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},i=xq(r,a,e),l=DI(n.gl,i),u=n.createProgram(l);return V().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:o,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:e,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:o,outShapeInfo:a},sN(n,e,u)))}function sN(n,e,t){const s=[],r=[];let o,a,i,l=null,u=null;u=n.getUniformLocation(t,"NAN",!1),V().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const d={name:h,uniform:n.getUniformLocation(t,h,c),offset:n.getUniformLocation(t,`offset${h}`,c)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${h}Shape`,c),d.texShape=n.getUniformLocation(t,`${h}TexShape`,c)),s.push(d)}if(e.enableShapeUniforms&&(o=n.getUniformLocation(t,"outShape",c),i=n.getUniformLocation(t,"outShapeStrides",c),a=n.getUniformLocation(t,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)r.push(n.getUniformLocation(t,h.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:a}}function k0(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,o=e[s],a=o.shape;if(!Ce(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&o.isUniform)return;const i=t.texShape,l=o.isUniform?null:o.texData.texShape;if(!Ce(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function t6(n,e,t,s,r){e.program.enableShapeUniforms||(k0(e.inShapeInfos,t),k0([e.outShapeInfo],[s]));const o=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,a[0],a[1]):n.setOutputMatrixTexture(o.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),V().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const u=t[l],{uniform:c,offset:h,shape:d,texShape:p}=e.variablesLocations[l];if(d){const{uniformShape:f}=Lx(e.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(d,new Int32Array(f));break;case 2:n.gl.uniform2iv(d,new Int32Array(f));break;case 3:n.gl.uniform3iv(d,new Int32Array(f));break;case 4:n.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&n.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(G(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const i=e.outShapeLocation;if(i)switch(s.shape.length){case 1:n.gl.uniform1iv(i,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(i,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(i,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(i,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=de(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],h=r[l];if(u.type==="float")n.gl.uniform1fv(c,h);else if(u.type==="vec2")n.gl.uniform2fv(c,h);else if(u.type==="vec3")n.gl.uniform3fv(c,h);else if(u.type==="vec4")n.gl.uniform4fv(c,h);else if(u.type==="int")n.gl.uniform1iv(c,h);else if(u.type==="ivec2")n.gl.uniform2iv(c,h);else if(u.type==="ivec3")n.gl.uniform3iv(c,h);else if(u.type==="ivec4")n.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function n6(n,e,t){let s="";e.concat(t).forEach(a=>{const i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=Lx(n.packedInputs,a.shape,l);let d="",p="",f="";if(c.length===1&&n.packedInputs){const $=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${$[0]>1}_${$[1]>1}`}else if(c.length===2&&!n.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const $=de(c);f=`${$[0]===l[1]}_${$[$.length-1]===l[1]}`}const m=a.shape.length,g=c.length===2&&Ce(a.shape,l),y=G(a.shape)===1,x=jr(a.shape,t.shape),w=!n.packedInputs&&m===t.shape.length&&Ce(l,t.texData.texShape),b=n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${m}_${w}_${u?h:""}_${c.length}_${y}_${x}_${g}_${d}_${p}_${f}_${b}_${i}`}else{const l=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${l}_${i}`}});const r=n.userCode;let o=n.constructor.name;return o+="_"+s+"_"+r+`${V().getNumber("WEBGL_VERSION")}`,o}function Mt(n){return V().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class s6{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Fi.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Kt();this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?gp(["r","c","d"],e):go(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class r6{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Fi.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Kt();this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?gp(["r","c","d"],e):go(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class o6{constructor(e){this.variableNames=["A"],this.outTexUsage=vn.DOWNLOAD;const t=Kt();this.outputShape=e,this.userCode=`
      ${QI}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class a6{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=vn.DOWNLOAD;const t=Kt();this.outputShape=e,this.userCode=`
      ${QI}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const i6={R:0,G:1,B:2,A:3};class T0{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Kt();this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)");let a="";for(let i=0;i<s.length;i++){const l=s[i];a+=`
          if(offset == ${i}) {
            result = values[${i6[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Fx():_x(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}class l6{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Kt();this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length);let r="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){const l=a*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Fx():_x(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}function rN(n){const e=Kt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return RI(n,t)}function oN(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return FI(n,e)}function aN(n){const e=new Uint16Array([0,1,2,2,1,3]);return LI(n,e)}function Iu(n,e,t,s,r,o){zI(e,t);const a=PI(n),i=n.TEXTURE_2D;return re(n,()=>n.bindTexture(i,a)),re(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),re(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),re(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),re(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),V().getNumber("WEBGL_VERSION")===1?re(n,()=>n.texImage2D(i,0,s,e,t,0,r,o,null)):re(n,()=>n.texStorage2D(i,1,s,e,t)),re(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function Px(n){return n.internalFormatFloat}function iN(n,e,t,s){const[r,o]=Su(e,t);return Iu(n,r,o,Px(s),s.textureFormatFloat,n.FLOAT)}function zx(n){return n.internalFormatHalfFloat}function lN(n,e,t,s){const[r,o]=Su(e,t);return Iu(n,r,o,zx(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function Mx(n){return n.downloadTextureFormat}function uN(n,e,t,s){const[r,o]=Su(e,t);return Iu(n,r,o,Mx(s),n.RGBA,n.UNSIGNED_BYTE)}function Bx(n){return n.internalFormatPackedFloat}function cN(n,e,t,s){const[r,o]=Xa(e,t);return Iu(n,r,o,Bx(s),n.RGBA,n.FLOAT)}function Vx(n){return n.internalFormatPackedHalfFloat}function hN(n,e,t,s){const[r,o]=Xa(e,t);return Iu(n,r,o,Vx(s),n.RGBA,s.textureTypeHalfFloat)}function dN(n,e,t){return re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Rf(n,e,"clipSpacePos",t,3,20,0)&&Rf(n,e,"uv",t,2,20,12)}function pN(n,e,t,s,r,o){re(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,i,l;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),i=n.UNSIGNED_BYTE,l=n.RGBA):(a=new Float32Array(t*s*4),i=n.FLOAT,l=o.internalFormatPackedFloat),a.set(r),V().getNumber("WEBGL_VERSION")===2?re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,i,a)):re(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,i,a)),re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function fN(n,e,t){re(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?V().getNumber("WEBGL_VERSION")===2?re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):V().getNumber("WEBGL_VERSION")===2?re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function mN(n,e,t,s){const r=n.createBuffer();re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const i=4*4*e*t;return re(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function gN(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function yN(n,e,t,s){const[r,o]=Su(e,t),a=4,i=new Uint8Array(sq(e*t,a));return re(n,()=>n.readPixels(0,0,r,o,s.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function xN(n,e,t,s,r,o,a,i){const l=n,u=new Float32Array(rq(o,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function bN(n,e,t){const s=new Float32Array(e*t*4);return re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}const u6=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:dN,createBufferFromOutputTexture:mN,createFloat16MatrixTexture:lN,createFloat16PackedMatrixTexture:hN,createFloat32MatrixTexture:iN,createIndexBuffer:aN,createPackedMatrixTexture:cN,createUnsignedBytesMatrixTexture:uN,createVertexBuffer:oN,createVertexShader:rN,downloadByteEncodedFloatMatrixFromOutputTexture:yN,downloadFloat32MatrixFromBuffer:gN,downloadMatrixFromPackedOutputTexture:bN,downloadPackedMatrixFromBuffer:xN,getInternalFormatForFloat16MatrixTexture:zx,getInternalFormatForFloat16PackedMatrixTexture:Vx,getInternalFormatForFloat32MatrixTexture:Px,getInternalFormatForPackedMatrixTexture:Bx,getInternalFormatForUnsignedBytesMatrixTexture:Mx,uploadDenseMatrixToTexture:pN,uploadPixelDataToTexture:fN},Symbol.toStringTag,{value:"Module"}));class xc{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=V().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,TI(t,e)):this.gl=Yn(t),e=this.gl,V().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>re(o,()=>o.createVertexArray()),this.bindVertexArray=a=>re(o,()=>o.bindVertexArray(a)),this.deleteVertexArray=a=>re(o,()=>o.deleteVertexArray(a)),this.getVertexArray=()=>re(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>re(e,()=>o.createVertexArrayOES()),this.bindVertexArray=a=>re(e,()=>o.bindVertexArrayOES(a)),this.deleteVertexArray=a=>re(e,()=>o.deleteVertexArrayOES(a)),this.getVertexArray=()=>re(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),V().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=mi(this.gl,o),$n(this.gl,a))this.textureHalfFloatExtension=mi(this.gl,a);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),$n(this.gl,r))this.colorBufferHalfFloatExtension=mi(this.gl,r);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",$n(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if($n(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=oN(this.gl),this.indexBuffer=aN(this.gl),this.framebuffer=MI(this.gl),this.textureConfig=Dx(this.gl,this.textureHalfFloatExtension)}get debug(){return V().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;re(e,()=>e.finish()),re(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),re(e,()=>e.deleteFramebuffer(this.framebuffer)),re(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),re(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),re(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),iN(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),lN(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),uN(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),fN(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),pN(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),hN(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),cN(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Df(this.gl,this.framebuffer),this.outputTexture=null),re(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>yN(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,o,a){return xN(this.gl,e,t,s,r,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return gN(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=mN(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(V().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(o,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=o}else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>bN(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=rN(t));const s=OI(t);re(t,()=>t.attachShader(s,this.vertexShader)),re(t,()=>t.attachShader(s,e)),_I(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&fc(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;re(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),dN(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(re(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&fc(this.gl,this.program),re(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?VI(this.gl,e,t):WI(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),re(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),UI(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,o]=Xa(t,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&fc(this.gl,this.program),gi(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}re(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),re(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=mi(this.gl,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Vp(()=>this.disposed||this.isQueryAvailable(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=c6(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in V().platform&&(s=V().platform.setTimeoutCustom.bind(V().platform)),Vp(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),mc(this.gl,e,this.framebuffer),this.debug&&gi(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(mc(this.gl,this.outputTexture,this.framebuffer),this.debug&&gi(this.gl)):Df(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;mc(r,e,this.framebuffer),this.debug&&gi(r),this.outputTexture=e,re(r,()=>r.viewport(0,0,t,s)),re(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),re(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function c6(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:h6,bincountImpl:wN,bincountReduceImpl:d6,bitwiseAndImpl:p6,castImpl:f6,ceilImpl:m6,concatImpl:g6,equalImpl:y6,expImpl:x6,expm1Impl:b6,floorImpl:w6,gatherNdImpl:v6,gatherV2Impl:$6,greaterImpl:S6,greaterEqualImpl:I6,lessImpl:N6,lessEqualImpl:C6,linSpaceImpl:k6,logImpl:T6,maxImpl:E6,maximumImpl:A6,minimumImpl:R6,multiplyImpl:D6,negImpl:O6,notEqualImpl:_6,prodImpl:F6,raggedGatherImpl:L6,raggedRangeImpl:P6,raggedTensorToTensorImpl:z6,rangeImpl:M6,rsqrtImpl:B6,scatterImpl:V6,sigmoidImpl:W6,simpleAbsImpl:vN,sliceImpl:U6,sparseFillEmptyRowsImpl:G6,sparseReshapeImpl:H6,sparseSegmentReductionImpl:$N,sqrtImpl:j6,staticRegexReplaceImpl:q6,stridedSliceImpl:K6,stringNGramsImpl:X6,stringSplitImpl:Y6,stringToHashBucketFastImpl:Z6,subImpl:J6,tileImpl:Q6,topKImpl:eK,transposeImpl:Wx,uniqueImpl:tK}=cI;function SN(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Ut(n,e){return e===1?[n]:SN(n,e)}function nK(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class sK{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Mt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Ut("rc",this.rank),s=ze(this.rank),r=this.getOutOfBoundsCondition(t),o=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)o=`${e[e.length-1-a]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class IN{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${rK(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Fx():_x(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function rK(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?yq(["r","c","d"],"inputShape"):go(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class oK{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=A0(t,s),o=R0(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const a=E0(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let i;return r===At.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===At.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===At.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===At.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===At.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const o=A0(s,r),a=R0(t,o,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=E0(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=V().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[a],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function aK(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function E0(n,e,t,s,r){const o=iK(e,s);let a;if(r){const[l,u]=Xa(n[0],n[1]);a=l*u}else{const[l,u]=Su(n[0],n[1]);a=l*u}const i=aK(t,o);return a*i}function iK(n,e){switch(n){case At.PACKED_2X2_FLOAT32:return Bx(e);case At.PACKED_2X2_FLOAT16:return Vx(e);case At.UNPACKED_FLOAT32:return Px(e);case At.UNPACKED_FLOAT16:return zx(e);case At.PACKED_4X1_UNSIGNED_BYTE:return Mx(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function lK(n){return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?At.PACKED_2X2_FLOAT32:At.UNPACKED_FLOAT32:n?At.PACKED_2X2_FLOAT16:At.UNPACKED_FLOAT16}function A0(n,e){if(n===vn.UPLOAD)return At.PACKED_2X2_FLOAT32;if(n===vn.RENDER||n==null)return lK(e);if(n===vn.DOWNLOAD||n===vn.PIXELS)return At.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function R0(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class os{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ln="if (isnan(x)) return x;",uK="return x;",D0="return abs(x);",cK="return (x >= 0.0) ? x : (exp(x) - 1.0);",hK=Ln+`
  return (x < 0.0) ? 0.0 : x;
`,dK=Ln+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,qs="return x;",pK="return 1.0 / (1.0 + exp(-1.0 * x));";const fK="return x;",mK=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,gK=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yK=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xK="return 1.0 / (1.0 + exp(-1.0 * x));";class Zs{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class bK{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length);const t=e.length,s=Ut("rc",t),r=ze(t),o=nK(t,s),a=s.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}const wK=Od,vK=1e-7,$K=1e-4,Wu={};function SK(n){return n in Wu||(Wu[n]={}),Wu[n]}const IK=V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),NK=600;function CK(){return V().global.screen==null?1024:V().global.screen.height*V().global.screen.width*window.devicePixelRatio*NK/1024/1024}class Nu extends Yc{nextDataId(){return Nu.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!V().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof xc)t=e;else{const s=Yn(V().getNumber("WEBGL_VERSION"),e);t=new xc(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Yn(V().getNumber("WEBGL_VERSION"));t=new xc(s),this.binaryCache=SK(V().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new oK(this.gpgpu),this.numMBBeforeWarning=CK(),this.texData=new zf(this,Bn())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,o,a){const i=this.makeTensorInfo(t,s),l=this.texData.get(i.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,o]},l.texShape=[r,o];const u=yi(t),c=new T0(u,!1,a),h=this.runWebGLProgram(c,[i],s,[[r,o]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(i),h.dataId}write(e,t,s){if((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||V().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:vn.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,o){if(V().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:vn.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:a,shape:i,isPacked:l}=t;if(a!=null){let d;l?d=new Zs(i,qs):d=new os(i,qs);const p=this.runWebGLProgram(d,[{dataId:e,shape:i,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const u=this.activeTimers!=null;let c;u&&(c=kt());let h;if(r==="complex64"){const d=this.readSync(o.real.dataId),p=this.readSync(o.imag.dataId);h=Rs(d,p)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=kt()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(m=>f.push(m))}const t=this.texData.get(e),{values:s,shape:r,slice:o,dtype:a,complexTensorInfos:i,isPacked:l}=t;if(o!=null){let f;l?f=new Zs(r,qs):f=new os(r,qs);const m=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:a}],a),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(V().getBool("DEBUG")&&!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&V().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&V().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...Bu(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(a==="complex64"){const f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),m=f[0],g=f[1];h=Rs(m,g)}else if(u==null)h=this.getValuesFromTexture(e);else{const f=G(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const f=this.gpgpu.gl;re(f,()=>f.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Bn().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:o,slice:a,dtype:i,isPacked:l,texture:u}=s;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let p;l?p=new Zs(o,qs):p=new os(o,qs);const f=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:i}],i),m=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),m}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),h=Bn().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>ks(r));return we(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return we(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!EI(s))throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),o=G(t);if(V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Bu(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(d),f}const a=V().getBool("WEBGL_PACK")&&r===!0,i=a?yi(t):t,l=a?new a6(i):new o6(i),u=this.runWebGLProgram(l,[{shape:i,dtype:s,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=hs(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=hs(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(o);i.kernelMs=Z0(l),i.getExtraProfileInfo=()=>l.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:kt(),endMs:null}}endTimer(e){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=kt(),e)}async getQueryTime(e){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:o,isPacked:a,slice:i}=this.texData.get(e),l=i&&i.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,o,a)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=IK){return V().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&G(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){xn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return wK(e.shape,t)}packedUnaryOp(e,t,s){const r=new Zs(e.shape,t),o=this.compileAndRun(r,[e],s);return Bn().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=vN(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(V().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,D0,e.dtype);const t=new os(e.shape,D0),s=this.compileAndRun(t,[e]);return Bn().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&rs(s[0])){const o=s.map(a=>as(a));r=this.write(o,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Bn().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new bK(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new sK(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[to(e.shape),...no(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[to(t),...no(t)],a=new IN(o,s),i=!0,l=[s],u=this.runWebGLProgram(a,[r],e.dtype,l,i);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:a}=s;if(t!=null){const d=G(o),p=t[0]*t[1]*4;I(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=yi(o);let l;r?l=new r6(i):l=new s6(i);const u=!0,c=[t??Bu(i)],h=this.runWebGLProgram(l,[{shape:i,dtype:a,dataId:e}],a,c,u,t);return{dtype:a,shape:o,dataId:h.dataId}}runWebGLProgram(e,t,s,r,o=!1,a){const i=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(i.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Fi.DENSE){const y=a??Bu(e.outputShape);l.texShape=y.map(x=>x*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),G(i.shape)===0)return l.values=vt(i.dtype,0),i;const u=[],c=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(y.dataId);if(x.texture==null){if(!e.packedInputs&&G(y.shape)<=V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!x.isPacked!=!!e.packedInputs)y=x.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),x=this.texData.get(y.dataId);else if(x.isPacked&&!Li(x.shape,y.shape)){const w=y,b=y.shape;y.shape=x.shape,y=this.packedReshape(y,b),u.push(y),x=this.texData.get(y.dataId),w.shape=b}return{shape:y.shape,texData:x,isUniform:!1}});this.uploadToGPU(i.dataId);const h={shape:i.shape,texData:l,isUniform:!1},d=n6(e,c,h),p=this.getAndSaveBinary(d,()=>e6(this.gpgpu,e,c,h)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),V().get("ENGINE_COMPILE_ONLY")||t6(this.gpgpu,p,c,h,r),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=V().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=kt();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!V().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){const y=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),y}return i}compileAndRun(e,t,s,r,o=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(V().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!V().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=V().getBool("DEBUG");V().set("DEBUG",!1);const t=this.abs(he(1e-8)).dataSync()[0];if(V().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?vK:$K}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:o,texture:a,usage:i,isPacked:l}=t;if(a!=null)return;const u=this.activeTimers!=null;let c;u&&(c=kt());let h=t.texShape;if(h==null&&(h=jI(s,l),t.texShape=h),o!=null){const d=yi(s);let p,f=h[1],m=h[0];const g=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(l||!g)&&([f,m]=Xa(h[0],h[1])),l?p=new l6(d,g):p=new T0(d,g);const y=g?[m,f]:h,x=this.makeTensorInfo(y,r),w=this.texData.get(x.dataId);g?w.usage=vn.PIXELS:w.usage=vn.UPLOAD,w.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),f,m,o);const b=[[m,f]],N=this.runWebGLProgram(p,[x],r,b,!0),T=this.texData.get(N.dataId);t.texShape=T.texShape,t.isPacked=T.isPacked,t.usage=T.usage,V().get("ENGINE_COMPILE_ONLY")?this.disposeData(N.dataId):(t.texture=T.texture,t.values=null,this.texData.delete(N.dataId)),this.disposeIntermediateTensorInfo(x),u&&(this.uploadWaitMs+=kt()-c)}else{const d=this.acquireTexture(h,i,r,l);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=kK(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*wi(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await $g(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Ox(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:o,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:l}=sN(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:o,width:a,channels:i}=e,l=Bn().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,t,s,o,a,i);return Bn().makeTensorFromDataId(u,t,s,l)}}Nu.nextDataId=0;function kK(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}const NN="4.22.0";function CN(){V().set("WEBGL_FORCE_F16_TEXTURES",!0)}qf()&&Xf("webgl",()=>new Nu,2);const TK={forceHalfFloat:CN};const Ux=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class so{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=xe(t,s),this.enableShapeUniforms=Mt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const xo=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ti{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=xe(t,s);const o=this.outputShape.length;this.enableShapeUniforms=Mt(o);let a="";if(r)if(o===0||G(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${ze(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Ut("coords",o);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}function fn(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const EK={kernelName:ia,backendName:"webgl",kernelFunc:fn};function $r(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,o=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(o.dataId),i=fn({inputs:{x:s},backend:t}),l=fn({inputs:{x:r},backend:t});return a.complexTensorInfos={real:i,imag:l},o}const AK={kernelName:oh,backendName:"webgl",kernelFunc:$r};const kN="return (a < 0.) ? b * a : a;",TN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function RK(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:o}=s,a=t.makeTensorInfo([],"float32",_s(o,"float32")),i=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ti(TN,r.shape,a.shape):new so(kN,r.shape,a.shape),l=t.runWebGLProgram(i,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),l}const DK={kernelName:ll,backendName:"webgl",kernelFunc:RK};const EN="return (a < 0.) ? b * a : a;",AN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function OK(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,o=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ti(AN,s.shape,r.shape):new so(EN,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],"float32")}const _K={kernelName:kl,backendName:"webgl",kernelFunc:OK};const ni="if (isnan(x)) return x;";function Re({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:o})=>{const{x:a}=r,i=o,l=s||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){const h=i.texData.get(a.dataId),d=t(h.values,l);return i.makeTensorInfo(a.shape,l,d)}const u=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new Zs(a.shape,e):c=new os(a.shape,n),i.runWebGLProgram(c,[a],l)}}function Pt({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:a,backend:i})=>{const{a:l,b:u}=a,c=i;if(s&&l.dtype==="complex64"){const f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(w=>{const[b,$]=w,N={dataId:b.dataId,dtype:b.dtype,shape:l.shape},T={dataId:$.dataId,dtype:$.dtype,shape:u.shape},A=new so(n,l.shape,u.shape);return c.runWebGLProgram(A,[N,T],Jt(b.dtype,$.dtype))}),x=$r({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),x}const h=o||Jt(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?Ds(f):f,y=l.dtype==="string"?Ds(m):m,[x,w]=r(l.shape,u.shape,g,y,h),b=c.makeTensorInfo(w,h),$=c.texData.get(b.dataId);return $.values=x,b}const d=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new ti(e,l.shape,u.shape,t):p=new so(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function Pi(n,e=!1){if(n==="linear")return e?fK:uK;if(n==="relu")return e?gK:hK;if(n==="elu")return e?mK:cK;if(n==="relu6")return e?yK:dK;if(n==="prelu")return e?AN:EN;if(n==="leakyrelu")return e?TN:kN;if(n==="sigmoid")return e?xK:pK;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class RN{constructor(e,t,s,r=!1,o=!1,a=!1,i=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Mt(this.outputShape.length);const c=r?e[1]:e[2],h=Math.ceil(c/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=o?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";i&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");const x=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let w="rc.x",b="rc.x";e[0]<t[0]?w=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(b=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${w};
        int batchB = ${b};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}}const O0={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class _0{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=xe(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const F0="return a * b;";function Gx(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=Jt(s.dtype,r.dtype);if(s.dtype==="complex64"){const i=t.texData.get(s.dataId),l=t.texData.get(r.dataId),u=new _0(O0.REAL,s.shape,r.shape),c=new _0(O0.IMAG,s.shape,r.shape),h=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:s.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=$r({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,r])){const i=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[u,c]=D6(s.shape,r.shape,i.values,l.values,o),h=t.makeTensorInfo(c,o),d=t.texData.get(h.dataId);return d.values=u,h}let a;return V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new ti(F0,s.shape,r.shape):a=new so(F0,s.shape,r.shape),t.runWebGLProgram(a,[s,r],o)}const FK={kernelName:ga,backendName:"webgl",kernelFunc:Gx};function LK(n,e,t){const s=[to(n.shape),...no(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},o=[to(e),...no(e)],a=new IN(o,s),i=!0,l=[s],u=t.runWebGLProgram(a,[r],n.dtype,l,i);return{dataId:u.dataId,shape:e,dtype:u.dtype}}function se(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:o}=s,a=t,i=G(r.shape),l=Bf(o,i),u=G(l);I(i===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const c=a.texData.get(r.dataId);return c.isPacked&&!Li(r.shape,l)&&!(c.texture!==null&&Li(c.shape,l))?LK(r,l,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const PK={kernelName:El,backendName:"webgl",kernelFunc:se};class L0{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];const i=Math.floor(s/4)*4,l=s%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${Br(h)?h.toPrecision(2):h}, ones);`}let c="";o%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}class zK{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:a}=e;this.outputShape=[r,a];let i="0.0",l="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",l="min"):t==="max"&&(i="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const c=Math.floor(s/4)*4,h=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}function MK(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=Hd(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function bo(n,e,t,s){const r=MK(n.shape);let o=n;for(let a=0;a<r.length;a++){const{inSize:i,windowSize:l,outSize:u}=r[a];let c,h;t==="mean"?c=a===0?new L0({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:u},i):new L0({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:u}):c=new zK({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:u},t),h=o,o=s.runWebGLProgram(c,[o],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return o}class BK{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=ze(this.rank),o=VK(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function VK(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}class WK{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[t[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=ze(this.rank),o=SN("rc",this.rank),a=new Array(this.rank);for(let c=0;c<t.length;c++)a[t[c]]=o[c];const i=`vec2(${a.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}function yp(n,e,t){const s=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WK(n.shape,e):new BK(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function UK(n,e,t,s){const r=e,o=n.shape.length,a=Ie(r,n.shape);let i=a;const l=Qe(i,o),u=l!=null;let c=n;u&&(c=yp(n,l,s),i=rt(i.length,o)),Ft("sum",i,o);const[h,d]=Nt(c.shape,i);let p=h;t&&(p=st(h,a));const f=G(d),g=G(n.shape)/f,y=se({inputs:{x:c},attrs:{shape:[g,f]},backend:s}),x=od(n.dtype),w=bo(y,x,"sum",s),b=se({inputs:{x:w},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(w),u&&s.disposeIntermediateTensorInfo(c),b}function xp(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s;return UK(r,o,a,t)}const GK={kernelName:Fl,backendName:"webgl",kernelFunc:xp};function Ht(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:o}=s,a=t,i=r.shape.length,l=new Array(i);for(let c=0;c<l.length;c++)l[c]=r.shape[o[c]];let u;if(a.shouldExecuteOnCPU([r])){const h=a.texData.get(r.dataId).values,d=Wx(h,r.shape,r.dtype,o,l);u=a.makeTensorInfo(l,r.dtype);const p=a.texData.get(u.dataId);p.values=d}else u=yp(r,o,a);return u}const HK={kernelName:Lr,backendName:"webgl",kernelFunc:Ht};const DN=1e3;function qc({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:l=null}){const u=n.shape.length,c=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],d=s?e.shape[c-1]:e.shape[c-2],p=t?n.shape[u-1]:n.shape[u-2],f=s?e.shape[c-2]:e.shape[c-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=G(m),x=G(g),b=xe(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);I(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const $=t?[y,h,p]:[y,p,h],N=s?[x,f,d]:[x,d,f],T=se({inputs:{x:n},backend:r,attrs:{shape:$}}),A=se({inputs:{x:e},backend:r,attrs:{shape:N}}),k=[T,A],E=Math.max(y,x),S=t?T.shape[1]:T.shape[2],D=o!=null,F=a!=null,z=l==="leakyrelu",M=l!=null?Pi(l,!0):null,W=D||F||z||M!=null;let j;if((p===1||f===1)&&S>DN&&W===!1){let q=T,K=A;t&&(q=Ht({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),k.push(q)),s&&(K=Ht({inputs:{x:A},backend:r,attrs:{perm:[0,2,1]}}),k.push(K));const X=f!==1,J=f===1;let Q=q;X&&(Q=se({inputs:{x:q},backend:r,attrs:{shape:[E,S,1]}}),k.push(Q));const ne=f===1?2:1;let te=K;J&&(te=se({inputs:{x:K},backend:r,attrs:{shape:[E,1,S]}}),k.push(te));const ae=Gx({inputs:{a:Q,b:te},backend:r});j=xp({inputs:{x:ae},backend:r,attrs:{axis:ne,keepDims:!0}}),k.push(ae)}else{const q=Jt(n.dtype,e.dtype),K=new RN($,N,[E,p,f],t,s,D,M,F,z),X=[T,A];if(o!=null&&X.push(o),F&&X.push(a),z){const J=r.makeTensorInfo([],"float32",_s(i,"float32"));X.push(J),k.push(J)}j=r.runWebGLProgram(K,X,q)}const U=se({inputs:{x:j},backend:r,attrs:{shape:b}});k.push(j);for(const q of k)r.disposeIntermediateTensorInfo(q);return U}function jK(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o,bias:a,preluActivationWeights:i}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return qc({a:r,b:o,transposeA:l,transposeB:u,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:h,activation:c})}const qK={kernelName:vi,backendName:"webgl",kernelFunc:jK};const P0="return abs(x);";function KK(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=t.texData.get(s.dataId),a=vN(o.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Zs(s.shape,P0):r=new os(s.shape,P0),t.runWebGLProgram(r,[s],s.dtype)}const XK={kernelName:Bi,backendName:"webgl",kernelFunc:KK};const YK=Ln+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,ZK=Re({opSnippet:YK}),JK={kernelName:Vo,backendName:"webgl",kernelFunc:ZK};const QK=Ln+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,eX=Re({opSnippet:QK}),tX={kernelName:Wo,backendName:"webgl",kernelFunc:eX};const z0="return a + b;",nX=Pt({opSnippet:z0,packedOpSnippet:z0,supportsComplex:!0,cpuKernelImpl:h6}),sX={kernelName:io,backendName:"webgl",kernelFunc:nX};class rX{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class oX{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,a)=>`T${a}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function bc(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return fn({inputs:{x:s[0]},backend:t});if(s.length>V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=bc({inputs:s.slice(0,l),backend:t}),c=bc({inputs:s.slice(l),backend:t});return bc({inputs:[u,c],backend:t})}const r=s.map(l=>l.dtype).reduce((l,u)=>Jt(l,u)),o=s.map(l=>l.shape),i=V().getBool("WEBGL_PACK")?new oX(s[0].shape,o):new rX(s[0].shape,o);return t.runWebGLProgram(i,s,r)}const aX={kernelName:Vi,backendName:"webgl",kernelFunc:bc};function iX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=Ie(o,r.shape);let u=l;const c=Qe(u,i);let h=r;c!=null&&(h=Ht({inputs:{x:r},backend:t,attrs:{perm:c}}),u=rt(u.length,i)),Ft("all",u,i);const[d,p]=Nt(h.shape,u),f=G(p),m=se({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),g=bo(m,m.dtype,"all",t);let y;if(a){const x=st(d,l);y=se({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=se({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(h),y}const lX={kernelName:Qc,backendName:"webgl",kernelFunc:iX};function uX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=Ie(o,r.shape);let u=l;const c=Qe(u,i);let h=r;c!=null&&(h=Ht({inputs:{x:r},backend:t,attrs:{perm:c}}),u=rt(u.length,i)),Ft("any",u,i);const[d,p]=Nt(h.shape,u),f=G(p),m=se({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),g=bo(m,m.dtype,"any",t);let y;if(a){const x=st(d,l);y=se({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=se({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(h),y}const cX={kernelName:eh,backendName:"webgl",kernelFunc:uX};class hX{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];const i=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class dX{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,I(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],a=Math.ceil(o/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,l=i.length,u=ze(l),c=Ut("coords",l);let h,d;if(a===1){d=l+1;const A=ze(d);h=`
        ${A} sourceLocR = ${A}(${c.join()}, 0);
        ++${c[l-1]};
        ${A} sourceLocG = ${A}(${c.join()}, 0);
        ++${c[l-2]};
        ${A} sourceLocA = ${A}(${c.join()}, 0);
        --${c[l-1]};
        ${A} sourceLocB = ${A}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map(A=>"int "+A),g=Ut("sourceLocR",d-1).concat("inIdx.r"),y=Ut("sourceLocG",d-1).concat("inIdx.g"),x=Ut("sourceLocB",d-1).concat("inIdx.b"),w=Ut("sourceLocA",d-1).concat("inIdx.a"),b=s==="max"?"greaterThan":"lessThan",$=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()})));`,N=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,T=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${i[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${i[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${$}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function ON(n,e,t,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const a=Hd(o),i={windowSize:a,inSize:o,batchSize:r,outSize:Math.ceil(o/a)},l=new hX(i,t,s==null),u=[e];s!=null&&u.push(s);const c=n.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=ON(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}function _N(n,e,t,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],a=Hd(o),i=new dX(r,a,t,s==null),l=s==null?[e]:[e,s],u=n.runWebGLProgram(i,l,"int32");if(u.shape.length===e.shape.length){const c=_N(n,e,t,u);return n.disposeIntermediateTensorInfo(u),c}return u}function FN(n,e,t,s){const r=[t];if(Ft("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!V().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],a=n.texData.get(e.dataId),i=a!==null&&a.isPacked;let l=e;i&&(l=n.unpackTensor(e),o.push(l));const[u,c]=Nt(l.shape,r),h=G(c),d=se({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});o.push(d);const p=ON(n,d,s);o.push(p);const f=se({inputs:{x:p},backend:n,attrs:{shape:u}});return o.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}return _N(n,e,s)}function pX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let a=Ie(o,r.shape);const i=Qe(a,r.shape.length);let l=r;const u=[];i!=null&&(l=Ht({inputs:{x:r},backend:t,attrs:{perm:i}}),u.push(l),a=rt(a.length,l.shape.length)),Ft("argMax",[a[0]],l.shape.length);const c=FN(t,l,a[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const fX={kernelName:Wi,backendName:"webgl",kernelFunc:pX};function mX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o}=s;let a=Ie(o,r.shape);const i=Qe(a,r.shape.length);let l=r;const u=[];i!=null&&(l=Ht({inputs:{x:r},backend:t,attrs:{perm:i}}),u.push(l),a=rt(a.length,l.shape.length)),Ft("argMin",[a[0]],l.shape.length);const c=FN(t,l,a[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const gX={kernelName:Ui,backendName:"webgl",kernelFunc:mX};const yX=Ln+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,xX=Re({opSnippet:yX}),bX={kernelName:Uo,backendName:"webgl",kernelFunc:xX};const wX=Ln+"return log(x + sqrt(x * x + 1.0));",vX=Re({opSnippet:wX}),$X={kernelName:Go,backendName:"webgl",kernelFunc:vX};const SX=Ln+`
  return atan(x);
`,IX=Re({opSnippet:SX}),NX={kernelName:Ho,backendName:"webgl",kernelFunc:IX};const CX=Ux+`
  return atan(a, b);
`,kX=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xo+`
  return result;
`,TX=Pt({opSnippet:CX,packedOpSnippet:kX}),EX={kernelName:qo,backendName:"webgl",kernelFunc:TX};const AX=Ln+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,RX=Re({opSnippet:AX}),DX={kernelName:jo,backendName:"webgl",kernelFunc:RX};class zi{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(m||(x="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${i}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(b="avgValue / max(count, 1.0)");const $=Math.floor(a/4)*4,N=a%4,T=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${$}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${T}
          }

          int xC = xCCorner + ${$};
          if (${N===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${N===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${N===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${T}
          }
        }
        setOutput(${b});
      }
    `}}class Hx{constructor(e,t,s,r=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const w=t==="avg";let b="0.0";if(w||(b="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let N=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(N="avgValue / max(count, 1.0)");const T=Math.floor(a/4)*4,A=a%4,k=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${y}, ${x});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${T}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${k}
            }

            int xC = xCCorner + ${T};
            if (${A===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${A===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${A===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${k}
            }
          }
        }
        setOutput(${N});
      }
    `}}function OX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Ya(r,"avgPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;I(_t(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=_n(r.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&Ce(c.inShape,c.outShape))return fn({inputs:{x:r},backend:t});const h=new zi(c,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const _X={kernelName:Gi,backendName:"webgl",kernelFunc:OX};function FX(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:i,dimRoundingMode:l,dataFormat:u}=s,c=[1,1,1],h=Fs(r.shape,o,a,c,i,l,u),d=new Hx(h,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const LX={kernelName:Hi,backendName:"webgl",kernelFunc:FX};class PX{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,h=u-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class zX{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,m=d-1-e.padInfo.top,g=p-1-e.padInfo.left,y=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function MX(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Fs(a.shape,i,l,h,u,c),p=new zX(d);return t.runWebGLProgram(p,[r],a.dtype)}const BX={kernelName:nh,backendName:"webgl",kernelFunc:MX};function VX(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o;Ya([r,o],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=s,c=_n(a.shape,i,l,1,u),h=new PX(c);return t.runWebGLProgram(h,[r],a.dtype)}const WX={kernelName:th,backendName:"webgl",kernelFunc:VX};function UX(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:o}=e,{transposeA:a,transposeB:i}=s;return qc({a:r,b:o,transposeA:a,transposeB:i,backend:t})}const GX={kernelName:ji,backendName:"webgl",kernelFunc:UX};class HX{constructor(e,t,s,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],xe(e,t),xe(e,s);let i="0.0";r!=null&&(xe(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="1.0";o!=null&&(xe(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class jX{constructor(e,t,s,r,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],xe(e,t),xe(e,s);let i="vec4(0.0)";r!=null&&(xe(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="vec4(1.0)";o!=null&&(xe(e,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const qX=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:o,offset:a,scale:i}=n;I(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const u=[s,r,o];let c=null;a!=null&&(c=a.shape,u.push(a));let h=null;i!=null&&(h=i.shape,u.push(i));const d=V().getBool("WEBGL_PACK_NORMALIZATION")?new jX(s.shape,r.shape,o.shape,c,h,l):new HX(s.shape,r.shape,o.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)},KX={kernelName:ol,backendName:"webgl",kernelFunc:qX};class XX{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=ze(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=YX(this.rank);let r;const o=e.map((a,i)=>`sourceLoc.${Ff[i]} = start[${i}] + coords.${Ff[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Ff=["x","y","z","w","u","v"];function YX(n){if(n===1)return"sourceLoc";if(n<=6)return Ff.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class ZX{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=ze(this.rank),s=Ut("coords",this.rank),r=Ut("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${o})`,i=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${l}
        setOutput(result);
      }
    `}}function JX(n,e,t,s){const r=s.texData.get(n.dataId),o=s.makeTensorInfo(t,n.dtype),a=s.texData.get(o.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let i=wg(e,de(n.shape));r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),o}function si(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,size:a}=s,[i,l]=Gd(r,o,a);if(yg(r,i,l),G(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),d=U6(h.values,i,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const{isPacked:u}=t.texData.get(r.dataId),c=bg(r.shape,i,l);if(u||!c){const h=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZX(l):new XX(l),d=[i];return t.runWebGLProgram(h,[r],r.dtype,d)}return t.uploadToGPU(r.dataId),JX(r,i,l,t)}const QX={kernelName:_l,backendName:"webgl",kernelFunc:si};const e5=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,crops:a}=s;I(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((x,w)=>x*w),l=uu(r.shape,o,i),u=cu(l.length,o.length),c=hu(r.shape,o,i),h=Cg(a,o.length),d=kg(c,a,o.length),p=[],f=se({inputs:{x:r},backend:t,attrs:{shape:l}}),m=Ht({inputs:{x:f},backend:t,attrs:{perm:u}}),g=se({inputs:{x:m},backend:t,attrs:{shape:c}}),y=si({inputs:{x:g},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(x=>t.disposeIntermediateTensorInfo(x)),y},t5={kernelName:qi,backendName:"webgl",kernelFunc:e5};function n5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a}=s,i=t.readSync(r.dataId),l=t.readSync(o.dataId),u=wN(i,l,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,u)}const s5={kernelName:sh,backendName:"webgl",kernelFunc:n5};const r5=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,o5=`
  return float(int(a.r) & int(b.r));
`;function a5(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,o=V().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=V().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const l=t.texData.get(s.dataId).values,u=t.texData.get(r.dataId).values,[c,h]=p6(s.shape,r.shape,l,u,s.dtype),d=t.makeTensorInfo(h,s.dtype),p=t.texData.get(d.dataId);return p.values=c,d}let i;return o?i=new ti(r5,s.shape,r.shape,!1):i=new so(o5,s.shape,r.shape),t.runWebGLProgram(i,[s,r],s.dtype)}const i5={kernelName:Ki,backendName:"webgl",kernelFunc:a5};function l5(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,o=t.readSync(s.dataId),a=t.readSync(r.dataId),i=xe(Array.from(o),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const u5={kernelName:rh,backendName:"webgl",kernelFunc:l5};const c5="return float(a != b);",LN=Pt({opSnippet:c5,cpuKernelImpl:_6,dtype:"bool"}),h5={kernelName:$l,backendName:"webgl",kernelFunc:LN};function Cu(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return fn({inputs:{x:r.complexTensorInfos.real},backend:t})}const d5={kernelName:zh,backendName:"webgl",kernelFunc:Cu};const p5="return float(int(x));";function f5(n,e){const t=new os(n.shape,p5),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function Lf(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return fn({inputs:{x:r},backend:t});const a=lt(r.shape),i=Lf({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=$r({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),l}if(r.dtype==="complex64"){const a=Cu({inputs:{input:r},backend:t}),i=Lf({inputs:{x:a},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(a),i}if(!Vf(r.dtype,o)){const a=fn({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[i,l,u]=f6(a,r.shape,r.dtype,o);return t.makeTensorInfo(i,l,u)}if(o==="int32")return f5(r,t);if(o==="bool"){const a=t.makeTensorInfo([],"bool",vt("bool",1)),l=LN({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const m5={kernelName:Ko,backendName:"webgl",kernelFunc:Lf};const M0="return ceil(x);",g5=Re({opSnippet:M0,packedOpSnippet:M0,cpuKernelImpl:m6}),y5={kernelName:Xo,backendName:"webgl",kernelFunc:g5};class x5{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class b5{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function w5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:o,clipValueMax:a}=s;let i;V().getBool("WEBGL_PACK_CLIP")?i=new b5(r.shape):i=new x5(r.shape);const l=[[o],[a]];return t.runWebGLProgram(i,[r],r.dtype,l)}const v5={kernelName:Yo,backendName:"webgl",kernelFunc:w5};class $5{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function B0(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function S5(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),o=new $5(s.shape),a=[B0(s,r.complexTensorInfos.real),B0(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,a,a[0].dtype)}const I5={kernelName:Xi,backendName:"webgl",kernelFunc:S5};class N5{constructor(e){this.outputShape=[],this.outputShape=ls(e,1),this.variableNames=e.map((a,i)=>`T${i}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const i=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}const r=t.length,o=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class C5{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ls(e,t);const s=this.outputShape,r=s.length,o=ze(r),a=Ut("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,g)=>`T${g}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const u=i[t],c=i.slice(-2),h=i.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];d+=`
        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Uu(i,u,g)}),
            vec2(${Uu(c,u,g)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${Uu(i,u,f)}),
          vec2(${Uu(c,u,f)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Uu(n,e,t){const s=n.indexOf(e);return n.map((o,a)=>a===s?`${o} - ${t}`:o).join()}function bp(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return fn({inputs:{x:r.complexTensorInfos.imag},backend:t})}const k5={kernelName:Ih,backendName:"webgl",kernelFunc:bp};function xi(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(x=>Cu({inputs:{input:x},backend:t})),f=n.map(x=>bp({inputs:{input:x},backend:t})),m=xi(p,e,t),g=xi(f,e,t),y=$r({inputs:{real:m,imag:g},backend:t});return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),f.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),y}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const p=n.map(b=>{const N=[-1,G(b.shape.slice(e))];return se({inputs:{x:b},backend:t,attrs:{shape:N}})}),f=p.map(b=>({vals:t.readSync(b.dataId),shape:b.shape})),m=ls(p.map(b=>b.shape),1),g=p[0].shape[0]===1,y=g6(f,m,s,g),x=ls(n.map(b=>b.shape),e),w=t.makeTensorInfo(x,s,y);return p.forEach(b=>t.disposeIntermediateTensorInfo(b)),w}const o=n.filter(p=>G(p.shape)>0),a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const p=a?new os(n[0].shape,qs):new Zs(n[0].shape,qs);return t.runWebGLProgram(p,n,s)}const i=V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>i){const p=[];for(let m=0;m<o.length;m+=i){const g=o.slice(m,m+i);p.push(xi(g,e,t))}const f=xi(p,e,t);for(const m of p)t.disposeIntermediateTensorInfo(m);return f}if(a){const p=new C5(o.map(f=>f.shape),e);return t.runWebGLProgram(p,o,s)}const{tensors2D:l,outShape:u}=T5(o,e,t),c=new N5(l.map(p=>p.shape)),h=t.runWebGLProgram(c,l,s);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=se({inputs:{x:h},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(h),d}function T5(n,e,t){const s=ls(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>se({inputs:{x:o},attrs:{shape:[-1,G(o.shape.slice(e))]},backend:t})),outShape:s}}function PN(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,o=Ie(r,e[0].shape)[0],a=e.map(u=>u.shape);Sg(a,o);const i=ls(e.map(u=>u.shape),o);if(G(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);const l=e.filter(u=>G(u.shape)>0);return l.length===1?fn({inputs:{x:l[0]},backend:t}):xi(l,o,t)}const E5={kernelName:Yi,backendName:"webgl",kernelFunc:PN};class zN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,x=g?2:3,w=g?3:1;let b="",$="";s&&(r?b=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?b=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`
          float activation(float x) {
            ${s}
          }
        `,$="result = activation(result);");const N=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${$}
        setOutput(result);
      }
    `}}class A5{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class MN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Mt(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(d+=`
           xC = xCCorner + ${y*l};
           `,i===1){if(y<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){const x=a%2===0?Zc(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):x===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}class R5{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Mt(this.outputShape.length);const{dataFormat:s}=t,r=Kt(),o=s==="channelsLast",a=o?1:2,i=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}function Kc(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function BN({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const l=n.shape,u=s.texData.get(n.dataId),c=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(o!=null){const b=Kc(o.shape,p);b!=null&&(o=se({inputs:{x:o},backend:s,attrs:{shape:b}}),y.push(o))}if(r!=null){const b=Kc(r.shape,p);b!=null&&(r=se({inputs:{x:r},backend:s,attrs:{shape:b}}),y.push(r))}if(!((h===1||d===1)&&c>DN)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&Ce(u.shape.slice(-3),l.slice(-3))){const b=l[0]*l[1]*(l[2]+1),$={dataId:n.dataId,shape:[1,b,t.inChannels],dtype:n.dtype},N=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,I(Li(u.shape,$.shape),()=>`packed reshape ${u.shape} to ${$.shape} isn't free`);const T=se({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(T);const A=qc({a:$,b:T,backend:s,transposeA:f,transposeB:m,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a}),k=s.texData.get(A.dataId);I(k.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=N,k.shape=t.outShape,g=fn({inputs:{x:A},backend:s}),g.shape=t.outShape,y.push(A)}else{const b=t.outHeight*t.outWidth,$=se({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,b,t.inChannels]:[t.batchSize,t.inChannels,b]}}),N=se({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),T=qc({a:p?$:N,b:p?N:$,transposeA:!p,transposeB:m,backend:s,bias:r,activation:i,preluActivationWeights:o,leakyreluAlpha:a});g=se({inputs:{x:T},backend:s,attrs:{shape:t.outShape}}),y.push($),y.push(N),y.push(T)}for(const b of y)s.disposeIntermediateTensorInfo(b);return g}function VN({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:i=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",m=l*u*c,g=d*h,y=[t.batchSize,m,g],x=!0,w=!1,b=[];if(o!=null){const U=Kc(o.shape,f);U!=null&&(o=se({inputs:{x:o},backend:s,attrs:{shape:U}}),b.push(o))}if(r!=null){const U=Kc(r.shape,f);U!=null&&(r=se({inputs:{x:r},backend:s,attrs:{shape:U}}),b.push(r))}const $=se({inputs:{x:e},backend:s,attrs:{shape:[1,m,G(e.shape)/m]}});b.push($);const N=new R5(y,t),T=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=s.runWebGLProgram(N,[n],"float32",T),k=se({inputs:{x:A},backend:s,attrs:{shape:y}});b.push(A),b.push(k);const E=r!=null,S=o!=null,D=i==="leakyrelu",F=i?Pi(i,!0):null,z=new RN(f?k.shape:$.shape,f?$.shape:k.shape,f?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],x,w,E,F,S,D),M=f?[k,$]:[$,k];if(r&&M.push(r),S&&M.push(o),D){const U=s.makeTensorInfo([],"float32",_s(a,"float32"));M.push(U),b.push(U)}const W=s.runWebGLProgram(z,M,"float32"),j=se({inputs:{x:W},backend:s,attrs:{shape:t.outShape}});b.push(W);for(const U of b)s.disposeIntermediateTensorInfo(U);return j}function D5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=Ls(l),d=It(r.shape,o.shape,a,u,i,c,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=BN({x:r,filter:o,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&V().getBool("WEBGL_EXP_CONV")){const m=new MN(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(m,[r,o],"float32",g)}else if(V().getBool("WEBGL_CONV_IM2COL"))p=VN({x:r,filter:o,convInfo:d,backend:t});else{const m=new zN(d);p=t.runWebGLProgram(m,[r,o],"float32")}const f=se({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const O5={kernelName:Zi,backendName:"webgl",kernelFunc:D5};class _5{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class F5{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,l=s-1-e.padInfo.left,u=a?1:2,c=a?2:3,h=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class L5{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class P5{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,a=e.strideHeight,i=e.strideWidth,l=t-1-e.padInfo.front,u=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function z5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=Ls(l),d=It(r.shape,c,a,1,i,u,!1,h),p=new _5(d);return t.runWebGLProgram(p,[r,o],"float32")}const M5={kernelName:ah,backendName:"webgl",kernelFunc:z5};class B5{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Mt(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function V5(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{inputShape:a,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=Ls(u),d=It(a,o.shape,i,1,l,c,!1,h);if(V().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],f=new B5(d);return t.runWebGLProgram(f,[r,o],"float32",p)}else{const p=new F5(d);return t.runWebGLProgram(p,[r,o],"float32")}}const W5={kernelName:Ji,backendName:"webgl",kernelFunc:V5};function U5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l}=s,u=mr(r.shape,o.shape,a,l,i),c=new A5(u);return t.runWebGLProgram(c,[r,o],"float32")}const G5={kernelName:Qi,backendName:"webgl",kernelFunc:U5};function H5(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,pad:i,filterShape:l}=s,u=mr(r.shape,l,a,1,i),c=new L5(u);return t.runWebGLProgram(c,[r,o],"float32")}const j5={kernelName:ih,backendName:"webgl",kernelFunc:H5};function q5(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{pad:a,strides:i,inputShape:l}=s,u=mr(l,o.shape,i,1,a),c=new P5(u);return t.runWebGLProgram(c,[r,o],"float32")}const K5={kernelName:lh,backendName:"webgl",kernelFunc:q5};const X5=ni+`
  return cos(x);
`,Y5=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${xo}
  return result;
`,Z5=Re({opSnippet:X5,packedOpSnippet:Y5}),J5={kernelName:Zo,backendName:"webgl",kernelFunc:Z5};const Q5=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,e8=Re({opSnippet:Q5}),t8={kernelName:Jo,backendName:"webgl",kernelFunc:e8};class n8{constructor(e,t,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,l,u]=e,[c]=t,[h,d]=s;this.outputShape=[c,h,d,u];const p=r==="bilinear"?1:0,[f,m]=[`${i-1}.0`,`${l-1}.0`],[g,y,x]=h>1?[`${(i-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[w,b,$]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${b};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${$};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const s8=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:o,boxInd:a}=e,{cropSize:i,method:l,extrapolationValue:u}=s,c=new n8(r.shape,o.shape,i,l,u);return t.runWebGLProgram(c,[r,o,a],"float32")},r8={kernelName:ch,backendName:"webgl",kernelFunc:s8};var Mi;(function(n){n.Prod="*",n.Sum="+"})(Mi||(Mi={}));class V0{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=this.op===Mi.Prod?"1.0":"0.0",i=s?a:`getX(${W0(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ze(o)} coords = getOutputCoords();
        int end = ${U0(o,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${U0(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${W0(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function W0(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function U0(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function WN(n,e,t,s,r,o){const a=e.shape.length,i=Qe([s],a);let l=e;i!=null&&(l=Ht({inputs:{x:e},backend:t,attrs:{perm:i}}));const u=rt(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=fn({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const p=new V0(n,l.shape,!1,o),f=[[d]],m=h;h=t.runWebGLProgram(p,[h],h.dtype,f),t.disposeIntermediateTensorInfo(m)}if(r){const d=new V0(n,l.shape,r,o),p=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(i!=null){const d=gr(i),p=Ht({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}function o8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;return WN(Mi.Prod,r,t,o,a,i)}const a8={kernelName:uh,backendName:"webgl",kernelFunc:o8};function i8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,exclusive:a,reverse:i}=s;return WN(Mi.Sum,r,t,o,a,i)}const l8={kernelName:el,backendName:"webgl",kernelFunc:i8};function u8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:o}=e,{size:a,binaryOutput:i}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),u=t.readSync(o.dataId),c=wN(l,u,o.dtype,o.shape,a);return t.makeTensorInfo([a],o.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(o),c=d6(l,u,a,i);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const c8={kernelName:hh,backendName:"webgl",kernelFunc:u8};class h8{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function d8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:o,dataFormat:a}=s,i=r.shape[0],l=a==="NHWC"?r.shape[1]:r.shape[2],u=a==="NHWC"?r.shape[2]:r.shape[3],c=a==="NHWC"?r.shape[3]:r.shape[1],h=l*o,d=u*o,p=c/(o*o),f=a==="NHWC"?[i,h,d,p]:[i,p,h,d],m=new h8(f,o,a);return t.runWebGLProgram(m,[r],r.dtype)}const p8={kernelName:dh,backendName:"webgl",kernelFunc:d8};class UN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Mt(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";s&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:u=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}class GN{constructor(e,t=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Mt(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<h;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){const x=y*2;if(p+=`
          xC = xCCorner + ${x*u};
          `,l===1){if(x<h&&(i%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,u===1&&x>0?p+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<h)){const w=i%2===0?Zc(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:p+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):w===1?p+=`
                    xC${x+1} = xTexelC${x};
                    `:p+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<h&&(i%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<h&&(p+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<h&&(p+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<h&&(p+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}function f8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l,dimRoundingMode:u}=s;let c=l;c==null&&(c=[1,1]),I(_t(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=It(r.shape,o.shape,a,c,i,u,!0);let d;V().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new GN(h):d=new UN(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[r,o],"float32",p)}const m8={kernelName:tl,backendName:"webgl",kernelFunc:f8};class g8{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class y8{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,a=t-1-e.padInfo.top,i=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function x8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=s,h=It(r.shape,c,a,i,l,u,!0),d=new g8(h);return t.runWebGLProgram(d,[r,o],"float32")}const b8={kernelName:ph,backendName:"webgl",kernelFunc:x8};function w8(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:o}=e,{strides:a,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=s,h=It(c,o.shape,a,i,l,u,!0),d=new y8(h);return t.runWebGLProgram(d,[r,o],"float32")}const v8={kernelName:fh,backendName:"webgl",kernelFunc:w8};class $8{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function S8(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],o=G(s.shape),a=se({inputs:{x:s},backend:t,attrs:{shape:[o]}}),i=new $8(o),l=t.runWebGLProgram(i,[a],a.dtype),u=se({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const I8={kernelName:mh,backendName:"webgl",kernelFunc:S8};class N8{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:o,strideWidth:a,filterHeight:i,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function C8(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o}=e,{strides:a,pad:i,dilations:l}=s,u=Hl(r.shape,o.shape,a,i,"NHWC",l);let c;const h=new N8(u);c=t.runWebGLProgram(h,[r,o],"float32");const d=se({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),d}const k8={kernelName:nl,backendName:"webgl",kernelFunc:C8};function T8(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,o=e,{allDims:a,summedDims:i,idDims:l}=Fg(r,o.length);Pg(a.length,l,o);const{path:u,steps:c}=zg(i,l),h=c.length;let d=null,p=a.length;const f=[];for(let m=0;m<h;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:x}=Lg(p,l[g]);let w;Mg(y)?w=o[g]:(w=Ht({inputs:{x:o[g]},backend:t,attrs:{perm:y}}),f.push(w));const b=w.shape.slice();for(let $=0;$<x.length;++$)b.splice(x[$],0,1);Ce(w.shape,b)||(w=se({inputs:{x:w},backend:t,attrs:{shape:b}}),f.push(w)),d===null?d=w:(d=Gx({inputs:{a:w,b:d},backend:t}),f.push(d))}m<h-1&&(u[m]>=0&&(d=xp({inputs:{x:d},backend:t,attrs:{axis:u[m]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&t.disposeIntermediateTensorInfo(m);return d}const E8={kernelName:yh,backendName:"webgl",kernelFunc:T8};const A8="return (x >= 0.0) ? x : (exp(x) - 1.0);",R8=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,D8=Re({opSnippet:A8,packedOpSnippet:R8}),O8={kernelName:ea,backendName:"webgl",kernelFunc:D8};const _8="return (b >= 0.0) ? a : a * (b + 1.0);",F8=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,L8=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,o=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ti(F8,s.shape,r.shape):new so(_8,s.shape,r.shape);return t.runWebGLProgram(o,[s,r],s.dtype)},P8={kernelName:xh,backendName:"webgl",kernelFunc:L8};const z8=`
  return vec4(equal(a, b));
`,M8="return float(a == b);",B8=Pt({opSnippet:M8,packedOpSnippet:z8,dtype:"bool",cpuKernelImpl:y6}),V8={kernelName:sl,backendName:"webgl",kernelFunc:B8};const W8=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Tg};
  float a1 = ${Eg};
  float a2 = ${Ag};
  float a3 = ${Rg};
  float a4 = ${Dg};
  float a5 = ${Og};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,U8=Re({opSnippet:W8}),G8={kernelName:ta,backendName:"webgl",kernelFunc:U8};const H8=ni+`
  return exp(x);
`,j8=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HN=Re({opSnippet:H8,packedOpSnippet:j8,cpuKernelImpl:x6,dtype:"float32"}),q8={kernelName:na,backendName:"webgl",kernelFunc:HN};function Pf(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:o}=e,a=o.shape.length,i=o.shape.slice();let l=r;return r<0&&(I(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),i.splice(l,0,1),se({inputs:{x:o},backend:s,attrs:{shape:i}})}const K8={kernelName:rl,backendName:"webgl",kernelFunc:Pf};const G0="return exp(x) - 1.0;",X8=Re({opSnippet:G0,packedOpSnippet:G0,cpuKernelImpl:b6}),Y8={kernelName:sa,backendName:"webgl",kernelFunc:X8};class H0{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function jN(n,e,t){const s=t.texData.get(n.dataId),r=G(n.shape),o=n.shape[n.shape.length-1],a=r/o,i=se({inputs:{x:n},backend:t,attrs:{shape:[a,o]}}),l=i.shape,u=new H0("real",l,e),c=new H0("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),f=$r({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const m=se({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),m}function Z8(n){const{inputs:e,backend:t}=n,{input:s}=e;return jN(s,!1,t)}const J8={kernelName:bh,backendName:"webgl",kernelFunc:Z8};class Q8{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function ku(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:o}=t;if(o=o||oo(r),o==="string"){const a=tt(o,G(s));return a.fill(r),e.makeTensorInfo(s,o,a)}else{const a=new Q8(s,r),i=[[r]];return e.runWebGLProgram(a,[],o,i)}}const e7={kernelName:wh,backendName:"webgl",kernelFunc:ku};class t7{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const n7={kernelName:vh,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new t7(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};const j0="return floor(x);",s7=Re({opSnippet:j0,packedOpSnippet:j0,cpuKernelImpl:w6}),r7={kernelName:ra,backendName:"webgl",kernelFunc:s7};const o7=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,a7=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,i7=Pt({opSnippet:o7,packedOpSnippet:a7,dtype:"int32"}),l7={kernelName:oa,backendName:"webgl",kernelFunc:i7};class u7{constructor(e){this.variableNames=["A"];const t=Kt(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class c7{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Kt(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const h7={kernelName:Nc,backendName:"webgl",kernelFunc:d7};let vo,Bp=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function d7(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:o}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,o];if(i||a){const m=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(vo==null||m!==Bp)&&(Bp=m,vo=document.createElement("canvas").getContext("2d",{willReadFrequently:Bp})),vo.canvas.width=l,vo.canvas.height=u,vo.drawImage(r,0,0,l,u),r=vo.canvas}const d=t.makeTensorInfo(c,"int32");t.texData.get(d.dataId).usage=vn.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),r);const p=V().getBool("WEBGL_PACK")?new c7(h):new u7(h),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}function p7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=Ls(c),g=It(r.shape,o.shape,l,h,u,d,!1,m);let y;const x=[],w=a!=null,b=i!=null,$=p==="leakyrelu",N=()=>{const A=[r,o],k=(E,S)=>{if(S==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){const D=se({inputs:{x:E},backend:t,attrs:{shape:[E.shape[0],1,1]}});return x.push(D),D}return E};if(w&&A.push(k(a,c)),b&&A.push(k(i,c)),$){const E=t.makeTensorInfo([],"float32",_s(f,"float32"));A.push(E),x.push(E)}return A};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=BN({x:r,filter:o,convInfo:g,backend:t,bias:a,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&V().getBool("WEBGL_EXP_CONV")){const A=p?Pi(p,!0):null,k=new MN(g,w,A,b,$),E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],S=N();y=t.runWebGLProgram(k,S,"float32",E)}else if(V().getBool("WEBGL_CONV_IM2COL"))y=VN({x:r,filter:o,convInfo:g,backend:t,bias:a,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const A=p?Pi(p,!1):null,k=new zN(g,w,A,b,$),E=N();y=t.runWebGLProgram(k,E,"float32")}const T=se({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return x.push(y),x.forEach(A=>t.disposeIntermediateTensorInfo(A)),T}const f7={kernelName:$i,backendName:"webgl",kernelFunc:p7};function m7(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:o,bias:a,preluActivationWeights:i}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let m=c;m==null&&(m=[1,1]),I(_t(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=It(r.shape,o.shape,l,m,u,h,!0),y=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,x=d?Pi(d,y):null,w=[r,o],b=a!=null,$=i!=null,N=d==="leakyrelu";if(b&&w.push(a),$&&w.push(i),N){const E=t.makeTensorInfo([],"float32",_s(p,"float32"));w.push(E),f.push(E)}let T;y?T=new GN(g,b,x,$,N):T=new UN(g,b,x,$,N);const A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],k=t.runWebGLProgram(T,w,"float32",A);return f.forEach(E=>t.disposeIntermediateTensorInfo(E)),k}const g7={kernelName:Si,backendName:"webgl",kernelFunc:m7};class y7{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=ze(s.length);let a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function x7(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,o=r.shape,a=o[o.length-1],i=G(s.shape),[l,u,c,h]=Ud(s,r),d=se({inputs:{x:r},backend:t,attrs:{shape:[u,a]}}),p=se({inputs:{x:s},backend:t,attrs:{shape:[G(s.shape)/c,c]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const y=t.readSync(r.dataId),x=t.bufferSync(s),w=v6(y,x,s.dtype,u,a,c,h,s.shape,i);return t.makeTensorInfo(l,s.dtype,w.values)}const f=new y7(a,h,[u,c],s.shape),m=t.runWebGLProgram(f,[p,d],p.dtype),g=se({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const b7={kernelName:$h,backendName:"webgl",kernelFunc:x7};class w7{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=ze(this.rank),r=v7(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function v7(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}function qN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:o}=e,{axis:a,batchDims:i}=s,l=Ie(a,r.shape)[0];if(V().get("DEBUG")){const x=t.readSync(o.dataId),w=r.shape[l];for(let b=0;b<x.length;++b){const $=x[b];I($<=w-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${w-1}]`)}}const u=Vg(r,o,l,i),c=G(o.shape),h=[],d=se({inputs:{x:r},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=se({inputs:{x:o},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const x=t.bufferSync(p),w=t.bufferSync(d),b=$6(w,x,f);return h.forEach($=>t.disposeIntermediateTensorInfo($)),t.makeTensorInfo(u.outputShape,b.dtype,b.values)}const m=new w7(d.shape,f),g=t.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=se({inputs:{x:g},backend:t,attrs:{shape:u.outputShape}});return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}const $7={kernelName:al,backendName:"webgl",kernelFunc:qN};const S7="return float(a > b);",I7=`
  return vec4(greaterThan(a, b));
`,N7=Pt({opSnippet:S7,packedOpSnippet:I7,cpuKernelImpl:S6,dtype:"bool"}),C7={kernelName:il,backendName:"webgl",kernelFunc:N7};const k7="return float(a >= b);",T7=`
  return vec4(greaterThanEqual(a, b));
`,E7=Pt({opSnippet:k7,packedOpSnippet:T7,dtype:"bool",cpuKernelImpl:I6}),A7={kernelName:aa,backendName:"webgl",kernelFunc:E7};function R7(n){const{inputs:e,backend:t}=n,{input:s}=e;return jN(s,!0,t)}const D7={kernelName:Sh,backendName:"webgl",kernelFunc:R7};const O7="return float(!isnan(x) && !isinf(x));",_7=Re({opSnippet:O7,dtype:"bool"}),F7={kernelName:la,backendName:"webgl",kernelFunc:_7};const L7="return float(isinf(x));",P7=Re({opSnippet:L7,dtype:"bool"}),z7={kernelName:ua,backendName:"webgl",kernelFunc:P7};const M7="return float(isnan(x));",B7=Re({opSnippet:M7,dtype:"bool"}),V7={kernelName:ca,backendName:"webgl",kernelFunc:B7};const W7="return float(a < b);",U7=`
  return vec4(lessThan(a, b));
`,G7=Pt({opSnippet:W7,packedOpSnippet:U7,cpuKernelImpl:N6,dtype:"bool"}),H7={kernelName:ul,backendName:"webgl",kernelFunc:G7};const j7="return float(a <= b);",q7=`
  return vec4(lessThanEqual(a, b));
`,K7=Pt({opSnippet:j7,packedOpSnippet:q7,cpuKernelImpl:C6,dtype:"bool"}),X7={kernelName:cl,backendName:"webgl",kernelFunc:K7};function Y7(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:o}=t,a=k6(s,r,o);return e.makeTensorInfo([a.length],"float32",a)}const Z7={kernelName:Nh,backendName:"webgl",kernelFunc:Y7};const J7=ni+`
  return x < 0.0 ? 0./0. : log(x);
`,Q7=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,eY=Re({opSnippet:J7,packedOpSnippet:Q7,cpuKernelImpl:T6}),tY={kernelName:ha,backendName:"webgl",kernelFunc:eY};const nY=ni+`
  return log(1.0 + x);
`,sY=Re({opSnippet:nY}),rY={kernelName:da,backendName:"webgl",kernelFunc:sY};const oY="return float(a >= 1.0 && b >= 1.0);",aY=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,iY=Pt({opSnippet:oY,packedOpSnippet:aY,dtype:"bool"}),lY={kernelName:hl,backendName:"webgl",kernelFunc:iY};const uY="return float(!(x >= 1.0));",cY=Re({opSnippet:uY}),hY={kernelName:dl,backendName:"webgl",kernelFunc:cY};const dY="return float(a >= 1.0 || b >= 1.0);",pY=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,fY=Pt({opSnippet:dY,packedOpSnippet:pY,dtype:"bool"}),mY={kernelName:pl,backendName:"webgl",kernelFunc:fY};class gY{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class yY{constructor(e,t,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;o===.5?l=`inversesqrt(${u})`:o===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const xY=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:o,bias:a,alpha:i,beta:l}=s,u=V().getBool("WEBGL_PACK_NORMALIZATION")?new yY(r.shape,o,a,i,l):new gY(r.shape,o,a,i,l);return t.runWebGLProgram(u,[r],r.dtype)},bY={kernelName:fl,backendName:"webgl",kernelFunc:xY};class wY{constructor(e,t,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const vY=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:o,dy:a}=e,{depthRadius:i,bias:l,alpha:u,beta:c}=s,h=new wY(r.shape,i,l,u,c);return t.runWebGLProgram(h,[r,o,a],r.dtype)},$Y={kernelName:Ch,backendName:"webgl",kernelFunc:vY};function SY(n,e,t,s){const r=G(e),a=G(n.shape)/r,i=se({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=bo(i,n.dtype,"max",s),u=se({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),u}function KN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:o,keepDims:a}=s,i=r.shape.length,l=Ie(o,r.shape);let u=l;const c=Qe(u,i),h=c!=null,d=t.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const w=t.texData.get(p.dataId).values,b=new Array(i);for(let T=0;T<b.length;T++)b[T]=r.shape[c[T]];const $=Wx(w,r.shape,r.dtype,c,b);p=t.makeTensorInfo(b,r.dtype);const N=t.texData.get(p.dataId);N.values=$}else p=yp(r,c,t);u=rt(u.length,i)}Ft("max",u,i);const[f,m]=Nt(p.shape,u);let g=f;a&&(g=st(f,l));let y;if(d){const w=t.texData.get(p.dataId).values,b=E6(w,G(m),g,r.dtype);y=t.makeTensorInfo(g,r.dtype);const $=t.texData.get(y.dataId);$.values=b}else y=SY(p,m,g,t);return h&&t.disposeIntermediateTensorInfo(p),y}const IY={kernelName:ml,backendName:"webgl",kernelFunc:KN};const NY=Ux+`
  return max(a, b);
`,CY=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xo+`
  return result;
`,kY=Pt({opSnippet:NY,packedOpSnippet:CY,cpuKernelImpl:A6}),TY={kernelName:pa,backendName:"webgl",kernelFunc:kY};function EY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Ya(r,"maxPool");const{filterSize:o,strides:a,pad:i,dimRoundingMode:l}=s,u=1;I(_t(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=_n(r.shape,o,a,u,i,l);if(c.filterWidth===1&&c.filterHeight===1&&Ce(c.inShape,c.outShape))return fn({inputs:{x:r},backend:t});const h=new zi(c,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const AY={kernelName:gl,backendName:"webgl",kernelFunc:EY};function RY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:o,strides:a,pad:i,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=Fs(r.shape,o,a,c,i,u,l),d=new Hx(h,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const DY={kernelName:yl,backendName:"webgl",kernelFunc:RY};class OY{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=o-1-e.padInfo.top,l=a-1-e.padInfo.left,u=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class _Y{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=u-1-e.padInfo.top,p=c-1-e.padInfo.left,f=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function FY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o}=e,a=o,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],d=Fs(a.shape,i,l,h,u,c),p=new Hx(d,"max",!0),f=t.runWebGLProgram(p,[a],a.dtype),m=new _Y(d),g=t.runWebGLProgram(m,[r,f],a.dtype);return t.disposeIntermediateTensorInfo(f),g}const LY={kernelName:Th,backendName:"webgl",kernelFunc:FY};function PY(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:o,output:a}=e,i=o;Ya([o,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=_n(i.shape,l,u,1,c,h),p=!0,f=new zi(d,"max",p),m=t.runWebGLProgram(f,[i],i.dtype),g=new OY(d),y=t.runWebGLProgram(g,[r,m],i.dtype);return t.disposeIntermediateTensorInfo(m),y}const zY={kernelName:kh,backendName:"webgl",kernelFunc:PY};function MY(n,e,t,s){let r=new zi(t,"max",!1);const o=s.runWebGLProgram(r,[n],"float32");r=new zi(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[o,a]}const BY={kernelName:Eh,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:o,pad:a,includeBatchInIndex:i}=e,l=t;I(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];I(_t(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=_n(s.shape,r,o,u,a),[h,d]=MY(s,i,c,l);return[h,d]}};function VY(n,e,t,s){const r=G(e),a=G(n.shape)/r,i=se({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=bo(i,"float32","mean",s),u=se({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),u}const WY={kernelName:xl,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:o}=e,a=t,i=s.shape.length,l=Ie(o,s.shape);let u=l;const c=Qe(u,i),h=c!=null,d=a.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const b=a.texData.get(f.dataId).values,$=new Array(i);for(let A=0;A<$.length;A++)$[A]=s.shape[c[A]];const N=Wx(b,s.shape,s.dtype,c,$);f=a.makeTensorInfo($,s.dtype);const T=a.texData.get(f.dataId);T.values=N}else f=yp(s,c,a);p.push(f),u=rt(u.length,i)}Ft("sum",u,i);const[m,g]=Nt(f.shape,u);let y=m;r&&(y=st(m,l));const x=VY(f,g,y,a);for(const w of p)a.disposeIntermediateTensorInfo(w);return x}};function UY(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=Ie(o,r.shape);let u=l;const c=Qe(u,i);let h=r;c!=null&&(h=Ht({inputs:{x:r},backend:t,attrs:{perm:c}}),u=rt(u.length,r.shape.length)),Ft("min",u,i);const[d,p]=Nt(h.shape,u),f=G(p),m=se({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),g=bo(m,m.dtype,"min",t);let y;if(a){const x=st(d,l);y=se({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=se({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(h),y}const GY={kernelName:bl,backendName:"webgl",kernelFunc:UY};const HY=Ux+`
  return min(a, b);
`,jY=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+xo+`
  return result;
`,qY=Pt({opSnippet:HY,packedOpSnippet:jY,cpuKernelImpl:R6}),KY={kernelName:fa,backendName:"webgl",kernelFunc:qY};class XY{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,o=ze(r),a=t.map(c=>c[0]).join(","),i=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class YY{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);const r=e.length,o=ze(r),a=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),l=Ut("rc",r),u=Ut("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[r-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}const ZY=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:o}=t,a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YY(s.shape,r,o):new XY(s.shape,r,o);return e.runWebGLProgram(a,[s],s.dtype)},JY={kernelName:wl,backendName:"webgl",kernelFunc:ZY};const QY=`if (b == 0.0) return NAN;
  return mod(a, b);`,e9=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+xo+`
  return result;
`,t9=Pt({opSnippet:QY,packedOpSnippet:e9}),n9={kernelName:ma,backendName:"webgl",kernelFunc:t9};class s9{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const r9=`
if (a == b) {
  return 1.0;
};
return a / b;`,o9=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,XN=Pt({opSnippet:r9,packedOpSnippet:o9,checkOutOfBounds:!0}),a9={kernelName:Qo,backendName:"webgl",kernelFunc:XN};const q0="return a - b;",YN=Pt({opSnippet:q0,packedOpSnippet:q0,supportsComplex:!0,cpuKernelImpl:J6}),i9={kernelName:Ra,backendName:"webgl",kernelFunc:YN};function ZN(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:o}=s,a=Ie([o],r.shape),i=KN({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),l=st(i.shape,a),u=se({inputs:{x:i},backend:t,attrs:{shape:l}}),c=YN({inputs:{a:r,b:u},backend:t}),h=HN({inputs:{x:c},backend:t}),d=xp({inputs:{x:h},backend:t,attrs:{axis:a,keepDims:!1}}),p=se({inputs:{x:d},backend:t,attrs:{shape:l}}),f=XN({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const l9={kernelName:zl,backendName:"webgl",kernelFunc:ZN};function u9(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:o,seed:a,normalized:i}=s,l=i?r:ZN({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new s9(u,c,o),d=[[a]],p=t.runWebGLProgram(h,[l],"int32",d);return i||t.disposeIntermediateTensorInfo(l),p}const c9={kernelName:Ah,backendName:"webgl",kernelFunc:u9};const h9=Ln+`
  return -x;
`,d9=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function p9(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId),[a,i]=O6(o.values,s.shape,s.dtype);return t.makeTensorInfo(i,s.dtype,a)}let r;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Zs(s.shape,d9):r=new os(s.shape,h9),t.runWebGLProgram(r,[s],s.dtype)}const f9={kernelName:vl,backendName:"webgl",kernelFunc:p9};const m9=Md;function g9(n){xn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l}=s,u=t.readSync(r.dataId),c=t.readSync(o.dataId),{selectedIndices:h}=m9(u,c,a,i,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const y9={kernelName:Rh,backendName:"webgl",kernelFunc:g9};const x9=Bd;function b9(n){xn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=s,c=t.readSync(r.dataId),h=t.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=x9(c,h,a,i,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const w9={kernelName:Dh,backendName:"webgl",kernelFunc:b9};const v9=Vd;function $9(n){xn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:o}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=s,c=t.readSync(r.dataId),h=t.readSync(o.dataId),d=a,p=i,f=l,m=u,{selectedIndices:g,selectedScores:y}=v9(c,h,d,p,f,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const S9={kernelName:Oh,backendName:"webgl",kernelFunc:$9};class I9{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const N9=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:o,depth:a,onValue:i,offValue:l}=s,u=G(r.shape),c=new I9(u,a,i,l),h=se({inputs:{x:r},backend:t,attrs:{shape:[u]}}),d=t.runWebGLProgram(c,[h],o);t.disposeIntermediateTensorInfo(h);const p=[...r.shape,a],f=se({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),f},C9={kernelName:Il,backendName:"webgl",kernelFunc:N9};function Xc(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=Cu({inputs:{input:s},backend:t}),o=Xc({inputs:{x:r},backend:t}),a=bp({inputs:{input:s},backend:t}),i=Xc({inputs:{x:a},backend:t}),l=$r({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return ku({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const k9={kernelName:Wl,backendName:"webgl",kernelFunc:Xc};function JN(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=Cu({inputs:{input:s},backend:t}),o=JN({inputs:{x:r},backend:t}),a=bp({inputs:{input:s},backend:t}),i=Xc({inputs:{x:a},backend:t}),l=$r({inputs:{real:o,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),l}else return ku({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const T9={kernelName:Sl,backendName:"webgl",kernelFunc:JN};function E9(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Pf({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const o=e[0].shape,a=e[0].dtype;e.forEach(c=>{Ot(o,c.shape,"All tensors passed to stack must have matching shapes"),I(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],l=e.map(c=>{const h=Pf({inputs:{input:c},backend:t,attrs:{dim:r}});return i.push(h),h}),u=PN({inputs:l,backend:t,attrs:{axis:r}});return i.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const A9={kernelName:Nl,backendName:"webgl",kernelFunc:E9};class R9{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);const r=e.length,o=ze(r),a=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${i});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class D9{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const r=e.length,o=ze(r),a=t.map(m=>m[0]).join(","),i=t.map((m,g)=>m[0]+e[g]).join(","),l=Ut("rc",r),u=Ut("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${o} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=r===1?2:4;m<g;m++)f+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${m}] = getChannel(getX(${u.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${i});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}const QN=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:o,constantValue:a}=s;if(G(r.shape)===0){const u=o.map((c,h)=>c[0]+r.shape[h]+c[1]);return ku({backend:t,attrs:{shape:u,value:a,dtype:r.dtype}})}const i=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new D9(r.shape,o,a):new R9(r.shape,o,a),l=[[a]];return t.runWebGLProgram(i,[r],r.dtype,l)},O9={kernelName:Cl,backendName:"webgl",kernelFunc:QN};const _9=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,F9=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+xo+`
  return result;
`,L9=Pt({opSnippet:_9,packedOpSnippet:F9}),P9={kernelName:ya,backendName:"webgl",kernelFunc:L9};function z9(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:o,keepDims:a}=s,i=r.shape.length,l=[],u=Ie(o,r.shape);let c=u;const h=Qe(c,i);let d=r;h!=null&&(d=Ht({inputs:{x:r},backend:t,attrs:{perm:h}}),c=rt(c.length,i),l.push(d)),Ft("prod",c,i);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=F6(d.shape,d.dtype,f,c);p=t.makeTensorInfo(g,y,m)}else{const[f,m]=Nt(d.shape,c),g=G(m),y=se({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),x=od(r.dtype),w=bo(y,x,"prod",t);p=se({inputs:{x:w},backend:t,attrs:{shape:f}}),l.push(y),l.push(w)}if(a){l.push(p);const f=st(p.shape,u);p=se({inputs:{x:p},backend:t,attrs:{shape:f}})}return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const M9={kernelName:Tl,backendName:"webgl",kernelFunc:z9};function B9(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:o,indices:a}=e,{outputRaggedRank:i}=s,l=r.map(y=>t.readSync(y.dataId)),u=r.map(y=>y.shape),c=t.readSync(o.dataId),h=t.readSync(a.dataId),[d,p,f]=L6(l,u,c,o.shape,o.dtype,h,a.shape,i),m=d.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(f,o.dtype,p);return m.concat([g])}const V9={kernelName:_h,backendName:"webgl",kernelFunc:B9};function W9(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:o}=e,a=t.readSync(s.dataId),i=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=P6(a,s.shape,s.dtype,i,r.shape,l,o.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const U9={kernelName:Fh,backendName:"webgl",kernelFunc:W9};function G9(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:o,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:l}=s,u=t.readSync(r.dataId),c=t.readSync(o.dataId),h=t.readSync(a.dataId),d=i.map(g=>t.readSync(g.dataId)),p=i.map(g=>g.shape),[f,m]=z6(u,r.shape,c,o.shape,o.dtype,h,a.shape,d,p,l);return t.makeTensorInfo(f,o.dtype,m)}const H9={kernelName:Lh,backendName:"webgl",kernelFunc:G9};const eC=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:o,dtype:a}=t,i=M6(s,r,o,a);return e.makeTensorInfo([i.length],a,i)},j9={kernelName:Ph,backendName:"webgl",kernelFunc:eC};const q9="return 1.0 / x;",K9=Re({opSnippet:q9}),X9={kernelName:xa,backendName:"webgl",kernelFunc:K9};const Y9=Ln+`
  return (x < 0.0) ? 0.0 : x;
`,Z9=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,J9=Re({opSnippet:Y9,packedOpSnippet:Z9}),Q9={kernelName:ba,backendName:"webgl",kernelFunc:J9};const eZ=Ln+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,tZ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nZ=Re({opSnippet:eZ,packedOpSnippet:tZ}),sZ={kernelName:wa,backendName:"webgl",kernelFunc:nZ};class rZ{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,t,s,u];const c=[r&&t>1?i-1:i,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;o?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class oZ{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,t,s,u];const c=[r&&t>1?i-1:i,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;o?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function aZ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s,[l,u]=i,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new oZ(r.shape,l,u,o,a):new rZ(r.shape,l,u,o,a);return t.runWebGLProgram(c,[r],"float32")}const iZ={kernelName:Rl,backendName:"webgl",kernelFunc:aZ};class lZ{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,a,i]=e,l=[s&&a>1?r-1:r,s&&i>1?o-1:o],u=[s&&a>1?a-1:a,s&&i>1?i-1:i],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function uZ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s,i=new lZ(o.shape,r.shape,a);return t.runWebGLProgram(i,[o],o.dtype)}const cZ={kernelName:Bh,backendName:"webgl",kernelFunc:uZ};class hZ{constructor(e,t,s,r,o){this.variableNames=["A"],this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,t,s,u];const c=[r&&t>1?i-1:i,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;o?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class dZ{constructor(e,t,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,l,u]=e;this.outputShape=[a,t,s,u];const c=[r&&t>1?i-1:i,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;o?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function pZ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:o,halfPixelCenters:a,size:i}=s,[l,u]=i,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dZ(r.shape,l,u,o,a):new hZ(r.shape,l,u,o,a);return t.runWebGLProgram(c,[r],r.dtype)}const fZ={kernelName:Al,backendName:"webgl",kernelFunc:pZ};class mZ{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,a,i]=e,l=[s&&a>1?r-1:r,s&&i>1?o-1:o],u=[s&&a>1?a-1:a,s&&i>1?i-1:i],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function gZ(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:o}=e,{alignCorners:a}=s,i=new mZ(o.shape,r.shape,a);return t.runWebGLProgram(i,[o],o.dtype)}const yZ={kernelName:Mh,backendName:"webgl",kernelFunc:gZ};class xZ{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,o=e.map((i,l)=>r(l)).join(","),a=ze(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}class bZ{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Ut("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,i=ze(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${o}){
            result.g = ${u(r.slice())};
          }
          if(${a}) {
            result.b = ${c(r.slice())};
            if(${o}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function u(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function c(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function h(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const m=e.map((x,w)=>p(w,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${m[f]} - 1`:`${m[f]}`}}}function wZ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:o}=s,a=r.shape.length,i=Ie(o,r.shape);if(a===0)return fn({inputs:{x:r},backend:t});const l=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bZ(r.shape,i):new xZ(r.shape,i);return t.runWebGLProgram(l,[r],r.dtype)}const vZ={kernelName:Dl,backendName:"webgl",kernelFunc:wZ};class $Z{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const SZ={kernelName:sd,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:o,center:a}=e,i=t,l=new $Z(s.shape,o),[u,c]=Ng(a,s.shape[1],s.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return i.runWebGLProgram(l,[s],s.dtype,h)}};const IZ=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,NZ=Re({opSnippet:IZ}),CZ={kernelName:va,backendName:"webgl",kernelFunc:NZ};const kZ="return inversesqrt(x);",TZ=Re({opSnippet:kZ,cpuKernelImpl:B6}),EZ={kernelName:$a,backendName:"webgl",kernelFunc:TZ};class jx{constructor(e,t,s,r,o,a,i=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=ze(o.length),c=ze(a.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}class AZ{constructor(e,t,s,r,o,a,i=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const u=ze(o.length),c=ze(a.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",x=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}function RZ(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:o}=e,{shape:a}=s,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=wr(o,r,a),d=[h/u,u];if(h===0)return t.makeTensorInfo(a,r.dtype);const p=se({inputs:{x:r},backend:t,attrs:{shape:[l,i]}}),f=se({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0]));let g;V().getBool("WEBGL_PACK")?g=new AZ(l,i,p.shape.length,f.shape.length,c,d):g=new jx(l,i,p.shape.length,f.shape.length,c,d);const y=t.runWebGLProgram(g,[f,p,m],f.dtype),x=se({inputs:{x:y},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),x}const DZ={kernelName:Vh,backendName:"webgl",kernelFunc:RZ};class OZ{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=V().getNumber("WEBGL_VERSION")===2?o:a,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function _Z(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:o}=e,{side:a}=s,i=new OZ(r.shape[0],r.shape[1],o.shape[1],a),l=[[r.shape[1]]];return t.runWebGLProgram(i,[r,o],"int32",l)}const FZ={kernelName:Uh,backendName:"webgl",kernelFunc:_Z};class LZ{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${i[c]}`),c<e&&l.push(`${i[c]}`);r=l.join(),o=u.join()}const a=ze(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}function PZ(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:o}=e,a=new LZ(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,o],Jt(r.dtype,o.dtype))}const zZ={kernelName:Ol,backendName:"webgl",kernelFunc:PZ};const MZ=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${jd};
  float scale = ${qd};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,BZ=Re({opSnippet:MZ}),VZ={kernelName:Sa,backendName:"webgl",kernelFunc:BZ};const WZ=ni+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,UZ=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,GZ=Re({opSnippet:WZ,packedOpSnippet:UZ,cpuKernelImpl:W6}),HZ={kernelName:ka,backendName:"webgl",kernelFunc:GZ};const jZ=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,qZ=Re({opSnippet:jZ}),KZ={kernelName:Ca,backendName:"webgl",kernelFunc:qZ};const XZ=ni+`
  return sin(x);
`,YZ=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${xo}
  return result;
`,ZZ=Re({opSnippet:XZ,packedOpSnippet:YZ}),JZ={kernelName:Ia,backendName:"webgl",kernelFunc:ZZ};const QZ=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,eJ=Re({opSnippet:QZ}),tJ={kernelName:Na,backendName:"webgl",kernelFunc:eJ};const nJ=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,sJ=Re({opSnippet:nJ}),rJ={kernelName:Ta,backendName:"webgl",kernelFunc:sJ};const oJ=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:o,paddings:a}=s;I(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=o.reduce((y,x)=>y*x),l=[[0,0]];l.push(...a);for(let y=1+o.length;y<r.shape.length;++y)l.push([0,0]);const u=[],c=QN({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=uu(c.shape,o,i,!1),d=cu(h.length,o.length,!1),p=hu(c.shape,o,i,!1),f=se({inputs:{x:c},backend:t,attrs:{shape:h}}),m=Ht({inputs:{x:f},backend:t,attrs:{perm:d}}),g=se({inputs:{x:m},backend:t,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},aJ={kernelName:Ll,backendName:"webgl",kernelFunc:oJ};function iJ(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:o,defaultValue:a}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const i=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(o.dataId),c=t.readSync(a.dataId)[0],[h,d,p,f,m]=G6(i,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const lJ={kernelName:Gh,backendName:"webgl",kernelFunc:iJ};function uJ(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const a=Array.from(t.readSync(r.dataId)),i=t.readSync(s.dataId),l=Array.from(t.readSync(o.dataId)),[u,c,h]=H6(i,s.shape,s.dtype,a,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const cJ={kernelName:Hh,backendName:"webgl",kernelFunc:uJ};function hJ(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const a=t.readSync(s.dataId),i=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=$N(a,s.shape,s.dtype,i,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const dJ={kernelName:jh,backendName:"webgl",kernelFunc:hJ};function pJ(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const a=t.readSync(s.dataId),i=t.readSync(r.dataId),l=t.readSync(o.dataId),[u,c]=$N(a,s.shape,s.dtype,i,l);return t.makeTensorInfo(c,s.dtype,u)}const fJ={kernelName:qh,backendName:"webgl",kernelFunc:pJ};function mJ(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:o,defaultValue:a}=e,{outputShape:i}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=wr(o,r,i),p=!1;if(o.dtype==="string"){const y=t.bufferSync(r),x=t.bufferSync(o),w=ks(t.readSync(a.dataId)[0]),b=V6(y,x,i,d,c,u,l,h,w,p);return t.makeTensorInfo(i,b.dtype,b.values)}const f=new jx(u,l,r.shape.length,o.shape.length,h,[d,1],p),m=t.runWebGLProgram(f,[o,r,a],o.dtype),g=se({inputs:{x:m},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(m),g}const gJ={kernelName:Kh,backendName:"webgl",kernelFunc:mJ};function yJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:o,axis:a}=s,i=Ie(a,r.shape)[0],l=Bg(r,o,i),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(d=>{const p=[...h];p[i]=d;const f=si({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[i]+=d,f})}const xJ={kernelName:Pl,backendName:"webgl",kernelFunc:yJ};const K0="return sqrt(x);",bJ=Re({opSnippet:K0,packedOpSnippet:K0,cpuKernelImpl:j6}),wJ={kernelName:Ea,backendName:"webgl",kernelFunc:bJ};const vJ="return x * x;",$J=Re({opSnippet:vJ}),SJ={kernelName:Xh,backendName:"webgl",kernelFunc:$J};const X0="return (a - b) * (a - b);",IJ=Pt({opSnippet:X0,packedOpSnippet:X0}),NJ={kernelName:Aa,backendName:"webgl",kernelFunc:IJ};function CJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const o=t.readSync(r.dataId),a=Ds(o),i=q6(a,"string",s);return t.makeTensorInfo(r.shape,"string",i)}const kJ={kernelName:Ml,backendName:"webgl",kernelFunc:CJ};function TJ({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Ln+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new os(s.shape,r);return t.runWebGLProgram(o,[s],s.dtype)}const EJ={kernelName:Fa,backendName:"webgl",kernelFunc:TJ};class AJ{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=ze(s.length),a=ze(s.length);let i="";if(r===1)i="coords * strides + begin";else{let l=0;i=s.map((u,c)=>(l++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}function RJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:o,end:a,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:b}=vg(r.shape,o,a,i,l,u,c,h,d);let $;if(m)$=se({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||y){I(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const T=xg(x,w,b),A=si({inputs:{x:r},backend:t,attrs:{begin:x,size:T}});$=se({inputs:{x:A},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(A)}else if(t.shouldExecuteOnCPU([r])){const A=t.readSync(r.dataId),k=we(r.shape,r.dtype,A),E=K6(p,k,b,x);$=t.makeTensorInfo(f,r.dtype,E.values)}else{const A=new AJ(x,b,p);$=t.runWebGLProgram(A,[r],r.dtype)}const N=se({inputs:{x:$},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo($),N}const DJ={kernelName:Yh,backendName:"webgl",kernelFunc:RJ};function OJ(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:o,leftPad:a,rightPad:i,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,d=t.readSync(c.dataId),p=t.readSync(h.dataId),[f,m]=X6(d,p,r,o,a,i,l,u);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",m)]}const _J={kernelName:Zh,backendName:"webgl",kernelFunc:OJ};function FJ(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:o,delimiter:a}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const i=t.readSync(o.dataId),l=t.readSync(a.dataId)[0],[u,c,h]=Y6(i,l,r),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const LJ={kernelName:Jh,backendName:"webgl",kernelFunc:FJ};function PJ(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(o.dataId),i=Z6(a,r);return t.makeTensorInfo(o.shape,"int32",i)}const zJ={kernelName:Qh,backendName:"webgl",kernelFunc:PJ};const MJ="return tan(x);",BJ=Re({opSnippet:MJ}),VJ={kernelName:Da,backendName:"webgl",kernelFunc:BJ};const WJ=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,UJ=Re({opSnippet:WJ}),GJ={kernelName:Oa,backendName:"webgl",kernelFunc:UJ};function HJ(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:o,updates:a}=e,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=wr(a,o,r.shape),d=[h/u,u];if(h===0)return t.makeTensorInfo(r.shape,o.dtype);const p=se({inputs:{x:o},backend:t,attrs:{shape:[l,i]}}),f=se({inputs:{x:a},backend:t,attrs:{shape:[l,u]}}),m=se({inputs:{x:r},backend:t,attrs:{shape:d}}),g=new jx(l,i,p.shape.length,f.shape.length,c,d,!1,!0),y=t.runWebGLProgram(g,[f,p,m],m.dtype),x=se({inputs:{x:y},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),x}const jJ={kernelName:Wh,backendName:"webgl",kernelFunc:HJ};class qJ{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=ze(this.rank),o=KJ(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function KJ(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}function tC(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),u=r.dtype==="string"?l.map(d=>ks(d)):l,c=we(r.shape,r.dtype,u),h=Q6(c,o);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const a=new qJ(r.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const XJ={kernelName:_a,backendName:"webgl",kernelFunc:tC};class YJ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class ZJ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Nr(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Y0(n){let e=1;for(;e<n;)e*=2;return e}function JJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:o,sorted:a}=s,i=V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([r])||c<i||o>l){const E=t.readSync(r.dataId),[S,D]=eK(E,u,r.dtype,o,a);return[t.makeTensorInfo(S.shape,S.dtype,S.values),t.makeTensorInfo(D.shape,D.dtype,D.values)]}if(o===0)return u[u.length-1]=0,[t.makeTensorInfo(u,r.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[r,ku({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(r):r,m=G(u)/c,g=se({inputs:{x:p},attrs:{shape:[m,c]},backend:t});d&&Nr(t,p);const y=Y0(o),x=Y0(c);let w=null;const b=()=>w===null?[g,g]:[g,w],$=(E,S,D)=>{const F=b(),z=new YJ(D),W=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[E],[S]],j=w;w=t.runWebGLProgram(z,F,"int32",W),Nr(t,j)};for(let E=1;E<y;E*=2){const S=E*2;for(let D=E;D>=1;D/=2)$(S,D,[m,x])}for(let E=x;E>y;E/=2){const S=b(),D=new ZJ([m,E/2]),z=[[c],[w===null?1:0],[y]],M=w;w=t.runWebGLProgram(D,S,"int32",z),Nr(t,M);const W=y/2,j=W*2;for(let U=W;U>=1;U/=2)$(j,U,w.shape)}let N=w;w=si({inputs:{x:w},backend:t,attrs:{begin:0,size:[m,o]}}),Nr(t,N);let T=qN({inputs:{x:g,indices:w},backend:t,attrs:{axis:1,batchDims:1}});Nr(t,g);const A=u.slice(0,-1);A.push(o),N=w,w=se({inputs:{x:w},attrs:{shape:A},backend:t}),Nr(t,N);const k=T;return T=se({inputs:{x:T},attrs:{shape:A},backend:t}),Nr(t,k),[T,w]}const QJ={kernelName:ed,backendName:"webgl",kernelFunc:JJ};class eQ{constructor(e,t,s,r,o,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function tQ(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:o}=e,{interpolation:a,fillMode:i,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,m]=u??[h,d],g=[c,f,m,p],y=new eQ(h,d,a,i,l,g);return t.runWebGLProgram(y,[r,o],"float32")}const nQ={kernelName:td,backendName:"webgl",kernelFunc:tQ};function sQ(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:o}=e;Ya(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(o.dataId),{outputValues:i,outputShape:l,indices:u}=tK(a,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,i),s.makeTensorInfo([u.length],"int32",u)]}const rQ={kernelName:nd,backendName:"webgl",kernelFunc:sQ};function oQ(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const a=r,i=a.shape.length,l=r.shape[o],u=new Array(i-1);let c=0;for(let m=0;m<i;m++)m!==o&&(u[c++]=a.shape[m]);const h=[],d=new Array(i).fill(0),p=a.shape.slice();p[o]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[o]=m;const g=si({inputs:{x:a},backend:t,attrs:{begin:d,size:p}}),y=se({inputs:{x:g},backend:t,attrs:{shape:u}});f[m]=y,h.push(g)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const aQ={kernelName:Bl,backendName:"webgl",kernelFunc:oQ};class iQ{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,a=e.numSegments,i=a*Math.ceil(o/s);this.outputShape=[r,i];const l="0.0",u="sumValue",c=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";o%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}function lQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:o}=e,{numSegments:a}=s,i=r.shape.length,l=[];let u=0;const c=Qe([u],i);let h=r;c!=null&&(h=Ht({inputs:{x:r},backend:t,attrs:{perm:c}}),l.push(h),u=rt(1,i)[0]);const d=Rv(h.shape,u,a),p=G([h.shape[u]]),f=se({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const m=od(r.dtype),g=(b,$,N,T,A)=>{const k=b.shape[0],E=b.shape[1],S=Av(E,A),D={windowSize:S,inSize:E,batchSize:k,numSegments:A},F=new iQ(D,$),z=t.compileAndRun(F,[b,N],T);if(l.push(z),z.shape[1]===A)return z;const M=eC({backend:t,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),W=tC({inputs:{x:M},backend:t,attrs:{reps:[E/S]}});return l.push(M),l.push(W),g(z,$,W,T,A)},y=g(f,"unsortedSegmentSum",o,m,a),x=se({inputs:{x:y},backend:t,attrs:{shape:d}});let w=x;if(c!=null){l.push(x);const b=gr(c);w=Ht({inputs:{x:w},backend:t,attrs:{perm:b}})}return l.forEach(b=>t.disposeIntermediateTensorInfo(b)),w}const uQ={kernelName:Vl,backendName:"webgl",kernelFunc:lQ};const cQ=[qK,XK,JK,tX,sX,aX,lX,cX,fX,gX,bX,$X,NX,EX,DX,_X,LX,BX,WX,GX,KX,t5,s5,i5,u5,m5,y5,v5,AK,I5,E5,O5,M5,W5,G5,j5,K5,J5,t8,r8,a8,l8,c8,p8,m8,b8,v8,I8,k8,E8,O8,P8,V8,G8,q8,K8,Y8,J8,e7,n7,r7,l7,h7,f7,g7,b7,$7,C7,A7,EK,D7,k5,F7,z7,V7,DK,H7,X7,Z7,tY,rY,lY,hY,mY,bY,$Y,IY,TY,AY,DY,LY,zY,BY,WY,GY,KY,JY,n9,c9,FK,f9,y9,w9,S9,h5,C9,T9,A9,O9,P9,_K,M9,V9,U9,H9,j9,d5,a9,X9,Q9,sZ,PK,iZ,cZ,fZ,yZ,vZ,SZ,CZ,EZ,DZ,FZ,zZ,VZ,HZ,KZ,JZ,tJ,QX,l9,rJ,aJ,lJ,cJ,dJ,fJ,gJ,xJ,wJ,SJ,NJ,kJ,EJ,DJ,_J,LJ,zJ,i9,GK,VJ,GJ,jJ,XJ,QJ,nQ,HK,rQ,aQ,uQ,k9];for(const n of cQ)rd(n);const hQ="4.22.0";const dQ={"tfjs-core":iv,"tfjs-backend-cpu":hI,"tfjs-backend-webgl":NN,"tfjs-data":mS,"tfjs-layers":ap,"tfjs-converter":J$,tfjs:hQ},bQ=Object.freeze(Object.defineProperty({__proto__:null,Abs:Bi,Acos:Vo,Acosh:Wo,AdadeltaOptimizer:lg,AdagradOptimizer:ug,AdamOptimizer:cg,AdamaxOptimizer:hg,Add:io,AddN:Vi,All:Qc,Any:eh,ArgMax:Wi,ArgMin:Ui,Asin:Uo,Asinh:Go,Atan:Ho,Atan2:qo,Atanh:jo,AvgPool:Gi,AvgPool3D:Hi,AvgPool3DGrad:nh,AvgPoolGrad:th,BatchMatMul:ji,BatchToSpaceND:qi,Bincount:sh,BitwiseAnd:Ki,BroadcastArgs:rh,BroadcastTo:iw,Callback:q$,CallbackList:Yv,Cast:Ko,Ceil:Xo,ClipByValue:Yo,Complex:oh,ComplexAbs:Xi,Concat:Yi,Conv2D:Zi,Conv2DBackpropFilter:ah,Conv2DBackpropInput:Ji,Conv3D:Qi,Conv3DBackpropFilterV2:ih,Conv3DBackpropInputV2:lh,Cos:Zo,Cosh:Jo,CropAndResize:ch,Cumprod:uh,Cumsum:el,CustomCallback:Jv,DataStorage:zf,DenseBincount:hh,DepthToSpace:dh,DepthwiseConv2dNative:tl,DepthwiseConv2dNativeBackpropFilter:ph,DepthwiseConv2dNativeBackpropInput:fh,Diag:mh,Dilation2D:nl,Dilation2DBackpropFilter:Ic,Dilation2DBackpropInput:Sc,Draw:gh,get ENV(){return Uf},EarlyStopping:K$,Einsum:yh,Elu:ea,EluGrad:xh,Environment:ow,Equal:sl,Erf:ta,Exp:na,ExpandDims:rl,Expm1:sa,FFT:bh,Fill:wh,FlipLeftRight:vh,Floor:ra,FloorDiv:oa,FromPixels:Nc,FusedBatchNorm:ol,FusedConv2D:$i,FusedDepthwiseConv2D:Si,GPGPUContext:xc,GatherNd:$h,GatherV2:al,GraphModel:xx,Greater:il,GreaterEqual:aa,History:Zv,IFFT:Sh,Identity:ia,Imag:Ih,InputSpec:ut,IsFinite:la,IsInf:ua,IsNan:ca,KernelBackend:Yc,LRN:fl,LRNGrad:Ch,LayerVariable:jv,LayersModel:Ns,LeakyRelu:ll,Less:ul,LessEqual:cl,LinSpace:Nh,Log:ha,Log1p:da,LogSoftmax:lw,LogicalAnd:hl,LogicalNot:dl,LogicalOr:pl,LogicalXor:vC,LowerBound:$C,MathBackendCPU:vu,MathBackendWebGL:Nu,MatrixBandPart:SC,Max:ml,MaxPool:gl,MaxPool3D:yl,MaxPool3DGrad:Th,MaxPoolGrad:kh,MaxPoolWithArgmax:Eh,Maximum:pa,Mean:xl,Min:bl,Minimum:fa,MirrorPad:wl,Mod:ma,MomentumOptimizer:dg,Multinomial:Ah,Multiply:ga,Neg:vl,NonMaxSuppressionV3:Rh,NonMaxSuppressionV4:Dh,NonMaxSuppressionV5:Oh,NotEqual:$l,OP_SCOPE_SUFFIX:Kf,OneHot:Il,OnesLike:Sl,Optimizer:Bs,OptimizerConstructors:lv,Pack:Nl,PadV2:Cl,Pool:IC,Pow:ya,Prelu:kl,Prod:Tl,RMSPropOptimizer:pg,RNN:es,RaggedGather:_h,RaggedRange:Fh,RaggedTensorToTensor:Lh,Range:Ph,get Rank(){return Gp},Real:zh,RealDiv:Qo,Reciprocal:xa,get Reduction(){return Wt},Relu:ba,Relu6:wa,Reshape:El,ResizeBilinear:Rl,ResizeBilinearGrad:Bh,ResizeNearestNeighbor:Al,ResizeNearestNeighborGrad:Mh,Reverse:Dl,RotateWithOffset:sd,Round:va,Rsqrt:$a,SGDOptimizer:Wd,ScatterNd:Vh,SearchSorted:Uh,Select:Ol,Selu:Sa,Sequential:Zr,Sigmoid:ka,Sign:Ca,Sin:Ia,Sinh:Na,Slice:_l,Softmax:zl,Softplus:Ta,SpaceToBatchND:Ll,SparseFillEmptyRows:Gh,SparseReshape:Hh,SparseSegmentMean:jh,SparseSegmentSum:qh,SparseToDense:Kh,SplitV:Pl,Sqrt:Ea,Square:Xh,SquaredDifference:Aa,StaticRegexReplace:Ml,Step:Fa,StridedSlice:Yh,StringNGrams:Zh,StringSplit:Jh,StringToHashBucketFast:Qh,Sub:Ra,Sum:Fl,SymbolicTensor:Xn,Tan:Da,Tanh:Oa,Tensor:Ae,TensorBuffer:ct,TensorScatterUpdate:Wh,Tile:_a,TopK:ed,Transform:td,Transpose:Lr,Unique:nd,Unpack:Bl,UnsortedSegmentSum:Vl,UpperBound:NC,Variable:Ci,ZerosLike:Wl,_FusedMatMul:vi,abs:it,acos:nm,acosh:sm,add:Y,addN:zw,all:ld,any:Ti,argMax:Gr,argMin:rm,asin:om,asinh:am,atan:im,atan2:lm,atanh:um,avgPool:jl,avgPool3d:hm,backend:Yf,backend_util:Ov,basicLSTMCell:Mw,batchNorm:La,batchNorm2d:dm,batchNorm3d:pm,batchNorm4d:fm,batchToSpaceND:ql,bincount:mm,bitwiseAnd:Bw,booleanMaskAsync:I1,broadcastArgs:Vw,broadcastTo:Pr,broadcast_util:n2,browser:bO,buffer:we,callbacks:Lz,cast:ee,ceil:gm,clipByValue:en,clone:is,complex:Es,concat:nt,concat1d:ym,concat2d:xm,concat3d:bm,concat4d:wm,constraints:vL,conv1d:ud,conv2d:As,conv2dTranspose:cd,conv3d:$m,conv3dTranspose:Sm,copyRegisteredKernels:EC,cos:Kl,cosh:hd,cosineWindow:_d,cumprod:Ri,cumsum:dd,customGrad:fs,data:cV,denseBincount:Tc,deprecationWarn:ak,depthToSpace:Im,depthwiseConv2d:Pa,deregisterOp:Mz,device_util:ek,diag:Uw,dilation2d:Nm,disableDeprecationWarnings:ok,dispose:ye,disposeVariables:ik,div:ue,divNoNan:Cm,dot:km,dropout:sg,einsum:Er,elu:za,enableDebugMode:rk,enableProdMode:sk,enclosingPowerOfTwo:rg,engine:Bn,ensureShape:Gw,env:V,equal:hn,erf:pd,euclideanNorm:Em,exp:tn,expandDims:Tt,expm1:Am,eye:fd,fft:iu,fill:lo,findBackend:pk,findBackendFactory:fk,floor:Ba,floorDiv:id,forceHalfFloat:CN,fused:O1,gather:Va,gatherND:T1,gather_util:wO,getBackend:Iw,getGradient:Wp,getKernel:Ni,getKernelsForBackend:Cc,gpgpu_util:u6,grad:M2,grads:B2,greater:qt,greaterEqual:Ps,ifft:_o,imag:Xl,image:Rn,inTopKAsync:E1,initializers:PL,input:d$,io:gg,irfft:Td,isFinite:Rm,isInf:Dm,isNaN:Om,keep:pt,kernel_impls:EO,layers:dz,leakyRelu:Yl,less:Ao,lessEqual:yr,linalg:ig,linspace:qw,loadGraphModel:cB,loadGraphModelSync:hB,loadLayersModel:kP,localResponseNormalization:_m,log:dn,log1p:Zl,logSigmoid:Fm,logSoftmax:gd,logSumExp:Jl,logicalAnd:On,logicalNot:Ql,logicalOr:yd,logicalXor:Lm,losses:B1,lowerBound:Xw,matMul:Se,math:cO,max:In,maxPool:eu,maxPool3d:Pm,maxPoolWithArgmax:Yw,maximum:gs,mean:Ye,memory:Yp,meshgrid:Zw,metrics:Ez,min:Eo,minimum:ir,mirrorPad:zm,mod:Mm,model:AP,models:Az,moments:tu,movingAverage:N1,mul:_,multiRNNCell:Jw,multinomial:Qw,neg:Ue,nextFrame:$g,norm:Ma,notEqual:qr,oneHot:Ro,ones:Yt,onesLike:pn,op:O,outerProduct:e1,pad:zs,pad1d:t1,pad2d:n1,pad3d:s1,pad4d:r1,pool:Bm,pow:ps,prelu:su,print:tm,prod:Vm,profile:lk,raggedGather:o1,raggedRange:a1,raggedTensorToTensor:i1,rand:l1,randomGamma:h1,randomNormal:bd,randomStandardNormal:d1,randomUniform:xr,randomUniformInt:p1,range:Kr,ready:hk,real:Do,reciprocal:qm,registerBackend:Xf,registerCallbackConstructor:DP,registerGradient:uw,registerKernel:rd,registerOp:zz,regularizers:_z,relu:Jn,relu6:wd,removeBackend:dk,reshape:L,reverse:Nn,reverse1d:f1,reverse2d:m1,reverse3d:g1,reverse4d:y1,rfft:lu,round:vd,rsqrt:$d,scalar:he,scatterND:C1,scatter_util:UA,searchSorted:xd,selu:Sd,separableConv2d:Id,sequential:RP,serialization:GD,setBackend:ck,setPlatform:mk,setWebGLContext:TI,setdiff1dAsync:x1,shared:cI,sigmoid:Gn,sign:Km,signal:M1,sin:Nd,sinh:Cd,slice:Te,slice1d:ru,slice2d:kd,slice3d:ou,slice4d:Oo,slice_util:av,softmax:au,softplus:uo,spaceToBatchND:nu,sparse:V1,sparseToDense:k1,spectral:z1,split:Zt,sqrt:$t,square:Pe,squaredDifference:Ed,squeeze:br,stack:Gt,step:co,stridedSlice:Xm,string:W1,sub:oe,sum:ie,sumOutType:od,tan:Ym,tanh:ar,tensor:cn,tensor1d:Rt,tensor2d:Qs,tensor3d:Zm,tensor4d:b1,tensor5d:w1,tensor6d:v1,tensorScatterUpdate:$1,tensor_util:XC,test_util:nA,tidy:B,tile:wn,time:uk,topk:Qm,train:kr,transpose:ke,truncatedNormal:Rd,unique:eg,unregisterGradient:TC,unregisterKernel:kC,unsortedSegmentSum:Dd,unstack:Cn,upcastType:Jt,upperBound:S1,util:PC,valueAndGrad:V2,valueAndGrads:W2,variable:tg,variableGrads:Kw,version:dQ,version_converter:J$,version_core:iv,version_cpu:hI,version_layers:ap,version_webgl:NN,webgl:TK,webgl_util:mq,where:wt,whereAsync:ng,zeros:lt,zerosLike:Ee},Symbol.toStringTag,{value:"Module"}));export{bQ as d,Wm as r};
